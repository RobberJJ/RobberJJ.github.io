<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Development cannot be enabled while your device is locked.]]></title>
    <url>%2F2018%2F07%2F17%2FDeviceConnotEnableWithLocked%2F</url>
    <content type="text"><![CDATA[有时候我们真机调试的时候，会遇到这样的报错： Development cannot be enabled while your device is locked. 但是！我TM手机明明解锁了啊，指纹解的锁不是？密码解的锁不是？没感应到？换个姿势再来一次？还是不行？？ 哈哈，有同样经历的点个赞吧。 估计是有这么个不经意的瞬间，手机首次插上mac的时候，苹果给你弹了个框框，让你trust (信任)它，然后我们手欠的点了不trust (信任)，然后它生气了，不让你用了，就是上面的局面。 关键的是，它从此以后就不再弹了。。。 我TM错了，还不行么？你回来再给我弹一次啊！！ 后悔药： 设置 –&gt; 通用 –&gt; 还原 –&gt; 还原位置和隐私 按照上面的操作之后，重插，就会弹了~~~ 不用谢我~ 后遗症： 位置和隐私被重置了，之前已经设置位置和隐私的APP们，你再次进去的时候，都开始积极的弹框让你赏口饭了。 【/笑哭】🤣 这块儿官网其实是有说明的：https://support.apple.com/en-us/HT202778 划重点:]]></content>
      <tags>
        <tag>xcode</tag>
        <tag>Locked</tag>
        <tag>真机运行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不升级XCode越版本真机Debug]]></title>
    <url>%2F2018%2F07%2F17%2FDeviceDebugWithoutUploadXcode%2F</url>
    <content type="text"><![CDATA[有时候我们的iPhone紧跟apple的步伐升级最新的版本了，但是Xcode并没有及时更新到最新版本(Xcode是在很大，而且有时候是需要最新的beta版本的)，这时候真机调试的时候就会出现下面这样的问题： 报错：Could not locate device support files.This iPhone 7 (Model 1660, 1778, 1779, 1780) is running iOS 11.3 (15E216), which may not be supported by this version of Xcode. 当然，我们升级Xcode到适当的版本(iPhone是release版本，一般Xcode升级到最新的release版本，iPhone是beta版本，一般Xcode升级到最新的beta版本)，但是上面提到升级Xcode时间实在太长，急性子的我们表示等不及。 下面介绍一种不用升级Xcode就是真机调试的方法： 更新Xcode真机运行支持包 Xcode真机运行支持包path在这里：Xcode路径/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport，打开后能看到这样的界面： 支持包这里下载：链接: https://pan.baidu.com/s/1eS20QS6 密码: 5v35 之后要做的就是，需要哪一个iPhone系统的支持包，下载解压，放进去就可以了，然后插入你的手机，等Xcode解析好你的手机文件就可以真机运行了。 有时候可能不生效，重启大法重启下Xcode再试试。]]></content>
      <tags>
        <tag>XCode</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github超过100M的大文件上传]]></title>
    <url>%2F2018%2F07%2F17%2FBigFileUploadToGithub%2F</url>
    <content type="text"><![CDATA[通常我们commit完成之后，往Github上push的时候，单个文件大小不会超过100M，所以基本不会遇到这种情况。但是，总会遇到的，当单个文件超过100M的时候，push的时候会出现下面这样的Error： remote: Resolving deltas: 100% (472/472), done.remote: error: GH001: Large files detected.You may want to try Git Large File Storage - https://git-lfs.github.com. 或者： Total 3007 (delta 664), reused 0 (delta 0)remote: error: GH001: Large files detected.remote: error: Trace: 7b7de6b9372ee392e0f3961b05ea6f33remote: error: See http://git.io/iEPt8g for more information.remote: error: File XXX/XXX/XXX is 234 MB; this exceeds GitHub‘s file size limit of 100.00 MBremote: error: File XXX/XXX/XXX is 234 MB; this exceeds GitHub‘s file size limit of 100.00 MB。 上面错误的原因很好理解就是GitHub不允许直接上传大文件（超过100M）的文件到远程仓库，若要想继续提交可以尝试使用大文件支持库：https://git-lfs.github.comLFS使用的简单步骤： 安装git - lfs到本机这里没有什么难度，根据官网安装就好。 之后就是提交大文件的顺序，下面是官网的顺序： 安装Git命令行扩展。只需要设置一次Git LFS。在项目目录下，执行以下命令： git lfs install 选择您希望Git LFS管理的文件类型（或直接编辑.gitattributes）。您可以随时配置其他文件扩展名。这一步成功后会生成一个gitattributes文件 git lfs track “ .a” –这里的 “ .a “就是你要上传的大文件的路径 添加并commit gitattributes文件 git add .gitattributes 然后再添加大文件到本地缓存区 git add demo.agit commit -m “提交.a大文件”git push 以上，按照上述的方法，第一次上传大文件基本还是会报错，而且百思不得其解~尼玛，新手入坑总是这个尿性。。 如下图： 出现上述问题，先reset 到你刚才commit的前一个commit,(意思就是撤销刚才的commit，回到起点再来一次。) 第一、二步同上，第三步的时候，先将 .gitattributes文件，单独commit，然后push，完成之后，在进行第四部(第四部add 之后 执行git lfs ls-files应该能看见东西了)。到这里应该就没问题了。]]></content>
      <tags>
        <tag>Github</tag>
        <tag>大文件</tag>
        <tag>git-lfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上的那些效率神器]]></title>
    <url>%2F2018%2F07%2F17%2FArtifactOnMac%2F</url>
    <content type="text"><![CDATA[为了提高效率，我们必须不择手段！！ 这里为大家推荐一波Mac上的神器。 ####No.1 Alfred 点我装备 这顶神奇的魔法帽到底能干啥？这绝对可以称得上一款神器，简单的一句话概括就是——只有你想不到的，没有Alfred做不到的。 哈哈~~是不是很夸张？！ 一会儿再来下定论 在这里我只是举一个简单的栗子，通常我们遇到不懂的英文单词，基本是这么一个操作过程： copy单词 打开翻译应用（比如自带词典） 输入或粘贴查询单词 翻译应用输出查询结果 查询过后，一般都需要 Cmd+Q 退出应用（或者 Cmd+H 隐藏词典，亦或 Cmd+Tab 切换回上一个应用） 或者是下面的步骤： copy单词 手动打开浏览器 进入谷歌首页 选中输入框 输入或粘贴查询单词，然后空格并加上「翻译」两个字，然后再回车 等待浏览器展示查询结果; 而用Alfred是只需要： 选中单词 CMD+Y（假如快捷键你设置的是这个） Done！！ 那么问题来了，Alfred到底具体能做什么？默认情况下，Alfred 至少能胜任 15 项工作： 应用搜索 文件或目录搜索 文本内容搜索 标记搜索 快捷网页搜索 书签搜索 计算器 词典搜索 通讯录搜索 剪切板搜索 代码片段搜索 iTunes 管理 1Password 搜索 系统常用命令快捷操作 直接唤起指定终端并执行命令 这里做了很详细的说明。 当然，Alfred真正核心的功能在于——Workflow 。 Alfred 几乎可以做任何自动化工作流的事情（只要能用代码描述这个工作流就行），它能彻底改变了你对 Mac 的认知。 网上有很多大神们写好的workflow，可以搜一搜，然后体验体验，在我们可以自己为所欲为之前，坚定一下信心。 No.2 Things 3 点我装备一句话总结：GTD神器，简洁但不简单。 No.3 Moom 点我装备一款窗口布局的神器。支持自定义快捷键实现相应的窗口布局。 No.3 CheatSheet 点我装备一键直观查看App的快捷键列表。 说道快捷键，是的，快捷键会很大程度上提高你的效率，Mac上就自带了很多的快捷键，记住这些快捷键招式，就能立马神装出山了。具体可以参见这里。 No.4 Vim细心一些我们会发现，当前主流的IDE，或者以前曾经主流过的，或者未来即将成为主流的，总会有一套Vim相关的插件。其实，这就已经很能说明问题了。 Vim在手，天下我有的赶脚，有木有？！ Vim各类IDE的插件安装在这里就不详细阐述了，推荐几个Atom上神装吧，仅供参考： Vim Mode Plus Vim主要功能插件，不多说，究竟怎么爽，谁用谁知道。 relative-numbers相对行数在Vim中的重要地位不言而喻了，这款插件能够直观的看出彼此的相对行数。 minimap Sublime 右侧的mini视图，对，就是这货。 activate-power-mode 这款插件绝对会让你有一种敲代码如同跳舞的动感，呃，提醒一句，注意休息眼睛。哈哈~~ 当然，Atom的插件还有很多，可以去他的官网淘出你需要的。 No.5 iTerm 点击装备iTerm2+ oh my zsh的组合，为你打造最强Mac终端便不只是梦。个性化的主题，私人订制属于自己的格调。一堆定义好的alias，省心省力，爽的飞起！ No.6 Vimium chrome下的Vim插件，让你浏览网页也能有Vim操作的快感。点击这里了解 最后，放上Vim快捷键的几张图，欢迎收藏：]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>效率</tag>
        <tag>神器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上的那些个快捷键们]]></title>
    <url>%2F2018%2F07%2F17%2FShortCutsOnMac%2F</url>
    <content type="text"><![CDATA[入了Mac的坑，在为其魅力折服的同时，不免时不时的会有一些挥之不去的痛点。 其实在Mac上有一大堆的快捷键，可以让你的效率有一个质的提高。 在这里官方给出了快捷键的说明。点我直达显然，快捷键量很大，全部记住并熟练应用不太可能，可以根据自己的习惯，逐渐的形成自己的套路，然后替身自己的工作(娱乐)效率。 当然，CMD + Q(W/O/N)、CMD + X(C/V/F/S/A)之流就不说了，太常用，大家都知道。下面主要列举一下我自己感觉比较效率，但是又容易被忽视的快捷键：CMD + ` 在同一个应用的各个标签页中切换。CMD + Tab在打开的应用中切换到下一个最近使用的应用,按住可切换到其他应用，亦可配合触摸板或者鼠标选中某个应用CMD + T打开新的标签CMD + H隐藏当前应用CMD + Alt + H隐藏除了当前应用外的其他应用CMD + M最小化当前应用CMD + Alt + M最小化除了当前应用外的其他应用CMD + Shift + 3 截取整个屏幕，并保存图片到桌面CMD + Shift + 4 自定义截图大小，按下 Space 键，可以选择窗口截图Ctrl + ←(→)可以切换屏幕CMD + ,打开偏好设置…… 类似的快捷键其实还有很多很多，根据自身的习惯取舍吧。 快捷键的初衷，其实是想让效率能够提升，是想工作(娱乐)起来更有效率。但是问题来了，快捷键记少了总感觉不够用，而想要记更多的快捷键，难免成为一种负担。 CheatSheet，一款App，一键查看所有快捷键的App。点我速度装备 其实在Mac上还要一些隐藏的或者说是并没有明说的快捷键。(Apple经常干这事儿，发现的时候总有些喜怒交加)。 在mac上，很多时候在文本输入时，总想着能有一些快捷键，能让光标快速移动，殊不知，mac本身就自带这个能力。 如：iTerm2, 终端, safari, Chrome, QQ, SourceTree, Xcode, MindNode Pro, Pages, Keynote, 便签, 邮件等，几乎有文本输入的地方似乎都是支持的~~~ 在这里我列举一下平时比较常用的快捷键以及帮助记忆的方法： 注：为与emacs教程习惯一致，Ctrl 简写成 C C - a 光标移到行首（abcde，a是开头） C - e 光标移到行尾（abcde，e是结尾） C - f 光标向文档结尾方向移（Forward首字母） C - b 光标向文档开头方向移（Back首字母） C - p 光标移向上一行（Previous首字母） C - n 光标移向下一行（Next首字母） C - l 使当前编辑的行居中（safari, qq）或清屏（iTerm2,终端） C - d 删除光标后的一个字符（Delete首字母） C - k 删除光标到行尾的内容（Kill首字母） C - y 将C-k删除的东西粘贴出来（Yank首字母） C - o 在光标后插入一个换行符 C - t 交换光标前和光标后的字符，同时光标后移（Transpose首字母） C - h 删除光标前的一个字符 Mac其实也可以很简单的输入一些特殊字符。 输入特殊符号：版权符号: Option + G = ©人民币符号: Option + Y = ¥商标符号: Option + 2 = ™已经注册的商标: Option + R = ® 数学符号：约等于: Option + X = ≈度数: Shift + Option + 8 = °除号: Option + / = ÷无穷: Option + 5 = ∞大于等于和小于等于: Option + , 和 Option + . = ≤ 和 ≥不等于: Option + = = ≠圆周率: Option + P = π加减: Shift + Option + = = ±开方: Option + V = √求和符号: Option + W = ∑ 是不是很神奇？！]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>效率</tag>
        <tag>shortcut</tag>
        <tag>快捷键</tag>
        <tag>键盘党</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC追根溯源之Class]]></title>
    <url>%2F2017%2F11%2F12%2Foc-class%2F</url>
    <content type="text"><![CDATA[前两天碰到一面试题：12345//分辨下面res的是非BOOL res1 = [[NSObject class] isKindOfClass:[NSObject class]];BOOL res2 = [[NSObject class] isMemberOfClass:[NSObject class]];BOOL res3 = [[Sark class] isKindOfClass:[Sark class]];BOOL res4 = [[Sark class] isMemberOfClass:[Sark class]]; 在这之前，我们先了解一下相关的定义： Class 在objc.h中Class是这么定义的：12/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class; objc_class又是啥呢？在runtime.h中能看见： 12345678910111213141516struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; MetaClass 上面能看到Class中有个isa参数，它是指向Class的元类（MetaClass）的指针。 注意到isa也是一个Class的结构体，也就是说MetaClass其本质也是一个Class。 我们可以把Meta Class理解为 一个Class对象的Class。简单的说： 当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类的方法列表里查找 当我们发送一个消息给一个类时，这条消息会在类的Meta Class的方法列表里查找 之后就有了下面的这张图： 能看到： 每个Class都有一个isa指针指向一个唯一的MetaClass 每一个MetaClass的isa指针都指向最上层的MetaClass（图中的NSObject的MetaClass） 最上层的MetaClass的isa指针指向自己，形成一个回路 每一个MetaClass的super class指针指向它原本Class的 Super Class的MetaClass。 最上层的MetaClass的 Super Class指向NSObject Class本身 最上层的NSObject Class的super class指向 nil 接下来我们看看objc源码中(源码可到这里下载)，在文件Object.mm内，上面相关方法的定义： 123+ (Class)class &#123; return self; &#125; 12345678- (BOOL)isKindOf:aClass&#123; Class cls; for (cls = isa; cls; cls = cls-&gt;superclass) if (cls == (Class)aClass) return YES; return NO;&#125; 1234- (BOOL)isMemberOf:aClass&#123; return isa == (Class)aClass;&#125; 那么，BOOL res1 = [[NSObject class] isKindOfClass:[NSObject class]];就可以这样对应起来理解了： [NSObject class]拿到的是self，类方法的return self,即上图紫色的NSObject(Class)。 根据上面- (BOOL)isKindOf:aClass的实现，for循环首先拿到的cls = isa,也就是cls为NSObject(Class)的MetaClass。显然这时候cls == (Class)aClass不成立。 随后，cls = cls-&gt;superclass，即cls变成了NSObject(Class)的MetaClass的superclass,根据图示可以，superclass指向的是NSObject(Class)，至此cls == (Class)aClass成立，返回YES。 同样的道理，分析BOOL res3 = [[Sark class] isKindOfClass:[Sark class]];: [Sark class]拿到的是Sark(Class),而- (BOOL)isKindOf:aClass中cls拿到的值依次是Sark Meta Class-&gt;NSObject Meta Class-&gt;NSObject Class -&gt; nil,没有相等的，return NO。 剩下两个，根据- (BOOL)isMemberOf:aClass的实现，很容易得出结论会return NO。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>OC</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac开发之监听拦截键盘输入keycode]]></title>
    <url>%2F2017%2F11%2F04%2FKeyCodes%2F</url>
    <content type="text"><![CDATA[最近在自己写一个mac上图片预览的功能，仿系统的预览，想要在预览的时候，加入快捷键，实现放大、缩小、前一张、后一张等功能。 因为总感觉，弄个鼠标啪啪的点，很土。。。 PS:不上源码你说个JJ 。。。 源码在这里 查阅相关资料，其实并不难实现，只需要在预览的window里面实现键盘的监听就好，具体如下： 12345678910111213141516//overriding -[NSWindow keyDown:].- (void)keyDown:(NSEvent *)theEvent&#123; unsigned short keycode = [theEvent keyCode]; //是否同时按下CMD int flags = 0; BOOL cmdkeydown = ([[NSApp currentEvent] modifierFlags] &amp; NSCommandKeyMask) == NSCommandKeyMask; if (cmdkeydown) &#123; flags = flags | NSCommandKeyMask; &#125; if (keycode == 49) &#123; //space //空格键去干点啥。。 &#125;&#125; 可以拿到键盘对应的 key code，这个值其实是固定的，比如上面的空格键键值是49。 那么问题来了，总不能每个键去输入一下，打个断点看看值是多少吧，太土了。。。 其实SDK里面是有相应的 enum的，位置在这里： Virtual key codes 在 Carbon framework 的这个文件里面 果断add Carbon.framework,但是并不能import &lt;HIToolbox/Events.h&gt;。很奇怪，没明白。。。 好在这样就可以：#import &lt;Carbon/Carbon.h&gt; 你就可以这样搞了：123if (keycode == kVK_Space) &#123; //space //空格键去干点啥。。 &#125; 可以在这里找到HIToolbox/Events.h文件：1/System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/Headers/Events.h 然后你就能看见下面的这些ENUM了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147/* * Summary: * Virtual keycodes * * Discussion: * These constants are the virtual keycodes defined originally in * Inside Mac Volume V, pg. V-191. They identify physical keys on a * keyboard. Those constants with "ANSI" in the name are labeled * according to the key position on an ANSI-standard US keyboard. * For example, kVK_ANSI_A indicates the virtual keycode for the key * with the letter 'A' in the US keyboard layout. Other keyboard * layouts may have the 'A' key label on a different physical key; * in this case, pressing 'A' will generate a different virtual * keycode. */ enum &#123; kVK_ANSI_A = 0x00, kVK_ANSI_S = 0x01, kVK_ANSI_D = 0x02, kVK_ANSI_F = 0x03, kVK_ANSI_H = 0x04, kVK_ANSI_G = 0x05, kVK_ANSI_Z = 0x06, kVK_ANSI_X = 0x07, kVK_ANSI_C = 0x08, kVK_ANSI_V = 0x09, kVK_ANSI_B = 0x0B, kVK_ANSI_Q = 0x0C, kVK_ANSI_W = 0x0D, kVK_ANSI_E = 0x0E, kVK_ANSI_R = 0x0F, kVK_ANSI_Y = 0x10, kVK_ANSI_T = 0x11, kVK_ANSI_1 = 0x12, kVK_ANSI_2 = 0x13, kVK_ANSI_3 = 0x14, kVK_ANSI_4 = 0x15, kVK_ANSI_6 = 0x16, kVK_ANSI_5 = 0x17, kVK_ANSI_Equal = 0x18, kVK_ANSI_9 = 0x19, kVK_ANSI_7 = 0x1A, kVK_ANSI_Minus = 0x1B, kVK_ANSI_8 = 0x1C, kVK_ANSI_0 = 0x1D, kVK_ANSI_RightBracket = 0x1E, kVK_ANSI_O = 0x1F, kVK_ANSI_U = 0x20, kVK_ANSI_LeftBracket = 0x21, kVK_ANSI_I = 0x22, kVK_ANSI_P = 0x23, kVK_ANSI_L = 0x25, kVK_ANSI_J = 0x26, kVK_ANSI_Quote = 0x27, kVK_ANSI_K = 0x28, kVK_ANSI_Semicolon = 0x29, kVK_ANSI_Backslash = 0x2A, kVK_ANSI_Comma = 0x2B, kVK_ANSI_Slash = 0x2C, kVK_ANSI_N = 0x2D, kVK_ANSI_M = 0x2E, kVK_ANSI_Period = 0x2F, kVK_ANSI_Grave = 0x32, kVK_ANSI_KeypadDecimal = 0x41, kVK_ANSI_KeypadMultiply = 0x43, kVK_ANSI_KeypadPlus = 0x45, kVK_ANSI_KeypadClear = 0x47, kVK_ANSI_KeypadDivide = 0x4B, kVK_ANSI_KeypadEnter = 0x4C, kVK_ANSI_KeypadMinus = 0x4E, kVK_ANSI_KeypadEquals = 0x51, kVK_ANSI_Keypad0 = 0x52, kVK_ANSI_Keypad1 = 0x53, kVK_ANSI_Keypad2 = 0x54, kVK_ANSI_Keypad3 = 0x55, kVK_ANSI_Keypad4 = 0x56, kVK_ANSI_Keypad5 = 0x57, kVK_ANSI_Keypad6 = 0x58, kVK_ANSI_Keypad7 = 0x59, kVK_ANSI_Keypad8 = 0x5B, kVK_ANSI_Keypad9 = 0x5C &#125;; /* keycodes for keys that are independent of keyboard layout*/ enum &#123; kVK_Return = 0x24, kVK_Tab = 0x30, kVK_Space = 0x31, kVK_Delete = 0x33, kVK_Escape = 0x35, kVK_Command = 0x37, kVK_Shift = 0x38, kVK_CapsLock = 0x39, kVK_Option = 0x3A, kVK_Control = 0x3B, kVK_RightShift = 0x3C, kVK_RightOption = 0x3D, kVK_RightControl = 0x3E, kVK_Function = 0x3F, kVK_F17 = 0x40, kVK_VolumeUp = 0x48, kVK_VolumeDown = 0x49, kVK_Mute = 0x4A, kVK_F18 = 0x4F, kVK_F19 = 0x50, kVK_F20 = 0x5A, kVK_F5 = 0x60, kVK_F6 = 0x61, kVK_F7 = 0x62, kVK_F3 = 0x63, kVK_F8 = 0x64, kVK_F9 = 0x65, kVK_F11 = 0x67, kVK_F13 = 0x69, kVK_F16 = 0x6A, kVK_F14 = 0x6B, kVK_F10 = 0x6D, kVK_F12 = 0x6F, kVK_F15 = 0x71, kVK_Help = 0x72, kVK_Home = 0x73, kVK_PageUp = 0x74, kVK_ForwardDelete = 0x75, kVK_F4 = 0x76, kVK_End = 0x77, kVK_F2 = 0x78, kVK_PageDown = 0x79, kVK_F1 = 0x7A, kVK_LeftArrow = 0x7B, kVK_RightArrow = 0x7C, kVK_DownArrow = 0x7D, kVK_UpArrow = 0x7E &#125;; /* ISO keyboards only*/ enum &#123; kVK_ISO_Section = 0x0A &#125;; /* JIS keyboards only*/ enum &#123; kVK_JIS_Yen = 0x5D, kVK_JIS_Underscore = 0x5E, kVK_JIS_KeypadComma = 0x5F, kVK_JIS_Eisu = 0x66, kVK_JIS_Kana = 0x68 &#125;;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>shortcuts</tag>
        <tag>KeyCodes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[This app was unable to be installed.]]></title>
    <url>%2F2017%2F10%2F28%2FUnableInstalled-md%2F</url>
    <content type="text"><![CDATA[今天升级XCode 9.1 beta，编译项目正常，模拟器运行出现以下错误弹框： APP无法安装到模拟器上，也看不见任何提示，由于mac中存在多个XCode 版本，尝试下面命令： sudo xcode-select -s /Applications/Xcode-beta.app 并不好使。 这种问题看不见任何其他的问题提示，有点无从查起的赶脚。 stackoverflow上找到下面的方法： 1234xcrun simctl spawn booted log show//或者可以标出这个错误提示相关的，很容易看到相关的错误提示xcrun simctl spawn booted log show | grep &quot;This app was unable to be installed. 然后，基本就能定位问题了，我这里出现的问题是： Info.plist文件中缺少CFBundleExecutable，加上即可。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[High Sierra bad interpreter]]></title>
    <url>%2F2017%2F10%2F28%2FPodError-md%2F</url>
    <content type="text"><![CDATA[升级到mac OS High Sierra之后，pod失败，错误如下： -bash: /usr/local/bin/pod: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby: bad interpreter: No such file or directory 解决方案： 12sudo gem update --systemsudo gem install -n /usr/local/bin cocoapods]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS build error framework not found FileProvider for architecture x86_64]]></title>
    <url>%2F2017%2F10%2F28%2FNotFoundFileProvider-md%2F</url>
    <content type="text"><![CDATA[最近升级mac OS 到 High Sierra之后 XCode并没有立马升级，还是xcode 8.x，编译的时候，出现这样的问题： iOS build error: framework not found FileProvider for architecture x86_64 解决办法：update XCode to 9.x即可]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>xcode</tag>
        <tag>FileProvider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The document could not be autosaved. The file doesn’t exist.]]></title>
    <url>%2F2017%2F09%2F24%2FDocumentNotAutosaved%2F</url>
    <content type="text"><![CDATA[有时候莫名其妙的pod update之后(可能是拖拽文件到pod子项目导致的，具体忘了，出现问题的时候已经忘了之前干啥了。。。囧~)，然后某一个或者几个文件就不能编辑保存了，编译不过，如下： The document could not be autosaved. The file doesn’t exist. 而且，这个文件并没有路径显示： 从左侧栏右键Show in Finder，之后可以看到该文件在项目根目录下面的ProjectRootPath/Pods/Headers/Public/IMSDK/QCIMChatRoomVC.h 各种尝试不好使啊，重新pod也不管用，最终将子项目的该文件覆盖copy到上面的pods路径(ProjectRootPath/Pods/Headers/Public/IMSDK/QCIMChatRoomVC.h)下面，好使了。 以上，记一笔，出现好几次了，每次都是莫名其妙的出现了，然后莫名其妙的好了。。。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>autosaved</tag>
        <tag>exist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[resource fork, Finder information, or similar detritus not allowed]]></title>
    <url>%2F2017%2F09%2F24%2FResourceFork%2F</url>
    <content type="text"><![CDATA[XCode 8之后，上传AppStore可能会出现下面的错误： CodeSign /Users/gururajtallur/Library/Developer/Xcode/DerivedData/Flow-bkqjkvtmvjovpyepfjeyqmjpintj/Build/Products/Debug-iphoneos/Super\ Flow\ Flip.app cd “/Volumes/Development/Project/Top Best Games/19. Lets Flow/35/let’s FLOW - source/proj.ios_mac” export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate export PATH=”/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin”Signing Identity: “iPhone Distribution: New Free Games (2CHN583K4J)”Provisioning Profile: “Super Flow Flipp AppStore” (c6c30d2a-1025-4a23-8d12-1863ff684a05) /usr/bin/codesign --force --sign E48B98966150110E55EAA9B149F731901A41B37F --entitlements /Users/gururajtallur/Library/Developer/Xcode/DerivedData/Flow-bkqjkvtmvjovpyepfjeyqmjpintj/Build/Intermediates/Flow.build/Debug-iphoneos/Super\ Flow\ Flip.build/Super\ Flow\ Flip.app.xcent --timestamp=none /Users/gururajtallur/Library/Developer/Xcode/DerivedData/Flow-bkqjkvtmvjovpyepfjeyqmjpintj/Build/Products/Debug-iphoneos/Super\ Flow\ Flip.app /Users/gururajtallur/Library/Developer/Xcode/DerivedData/Flow-bkqjkvtmvjovpyepfjeyqmjpintj/Build/Products/Debug-iphoneos/Super Flow Flip.app: resource fork, Finder information, or similar detritus not allowedCommand /usr/bin/codesign failed with exit code 1 用下面的方法解决：终端，cd 到项目的根目录，然后依次执行下面的命令：1234find . -type f -name &apos;*.jpeg&apos; -exec xattr -c &#123;&#125; \;find . -type f -name &apos;*.jpg&apos; -exec xattr -c &#123;&#125; \;find . -type f -name &apos;*.png&apos; -exec xattr -c &#123;&#125; \;find . -type f -name &apos;*.json&apos; -exec xattr -c &#123;&#125; \; Clean Xcode and Re Build. Done. 如果还是未解决，请参考这里Â]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>osx</tag>
        <tag>mac os</tag>
        <tag>resource fork</tag>
        <tag>Finder information</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Compile warning:Embedded binary's NSExtensionActivationRule is TRUEPREDICATE]]></title>
    <url>%2F2017%2F09%2F24%2FNSExtensionActivationRule%2F</url>
    <content type="text"><![CDATA[上传AppStore的时候出现如下BUG： warning: Embedded binary’s NSExtensionActivationRule is TRUEPREDICATE. Before you submit your containing app to the App Store, be sure to replace all uses of TRUEPREDICATE with specific predicate statements or NSExtensionActivationRule keys. If any extensions in your containing app include TRUEPREDICATE, the app will be rejected. ShareExtnesion的plist文件中 NSExtensionActivationRule属性值为TRUEPREDICATE。 官方文档中提到： During development only, you can use the TRUEPREDICATE constant (which always evaluates to true) as a stub predicate statement, to test your code path before you implement your predicate statement. 注意: development only,所以上架的时候不能用。 可以参考下图修改 NSExtensionActivationRule的属性值可以参考这里]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>NSExtensionActivationRule</tag>
        <tag>TRUEPREDICATE</tag>
        <tag>osx</tag>
        <tag>mac os</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac中NSScrollView自定义滑动条NSScroller]]></title>
    <url>%2F2017%2F09%2F24%2FNSScroller%2F</url>
    <content type="text"><![CDATA[最近在捣鼓mac上开发app，本以为iOS、mac开发本是同根生，弄起来应该差不多，上手之后才发现iOS是多么的优雅自在，而mac是干啥都觉得不太顺手，UIKit跟AppKit差别还真是不一般的大。 最近，感觉NSScrollView右侧的滑动条长得不好看，想把滑动条的背景去掉，本想着设置个某个属性就能轻而易举的搞定，谁不知捣鼓半天没弄出来，mac开发的相关资料也着实太少，在这里记一笔，加深一下印象。 Tips：需要的同学，可以直接前往这里指点批评，或者为我转身点亮一颗小星星。 滑动条需要瞒住一下几个方面的需求： 滑动页面时候，显现滑动条，跟随滑动； 停止滑动页面的时候，自动隐藏滑动条； 任何时候滑动条背景色为透明； 下面直接上一下，NSScroller子类 JJScroller的.m文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990@implementation JJScroller- (id)initWithFrame:(NSRect)frameRect&#123; self = [super initWithFrame:frameRect]; if (self == nil) &#123; return nil; &#125; [self commonInitializer]; return self;&#125;- (void)awakeFromNib&#123; [super awakeFromNib]; [self commonInitializer];&#125;- (void)commonInitializer&#123; NSTrackingArea *trackingArea = [[NSTrackingArea alloc] initWithRect:self.bounds options:(NSTrackingMouseEnteredAndExited | NSTrackingActiveInActiveApp | NSTrackingMouseMoved) owner:self userInfo:nil]; [self addTrackingArea:trackingArea];&#125;- (void)drawRect:(NSRect)dirtyRect &#123; // Do some custom drawing... // Call NSScroller's drawKnob method (or your own if you overrode it) [self drawKnob];&#125;- (void)drawKnobSlotInRect:(NSRect)slotRect highlight:(BOOL)flag&#123; // Don't draw the background. Should only be invoked when using overlay scrollers&#125;- (void)mouseExited:(NSEvent *)theEvent&#123; [super mouseExited:theEvent]; [self fadeOut];&#125;- (void)mouseEntered:(NSEvent *)theEvent&#123; [super mouseEntered:theEvent]; [NSAnimationContext runAnimationGroup:^(NSAnimationContext *context) &#123; context.duration = 0.1f; [self.animator setAlphaValue:1.0f]; &#125; completionHandler:^&#123; &#125;]; [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(fadeOut) object:nil];&#125;- (void)mouseMoved:(NSEvent *)theEvent&#123; [super mouseMoved:theEvent]; self.alphaValue = 1.0f;&#125;- (void)setFloatValue:(float)aFloat&#123; [super setFloatValue:aFloat]; [self.animator setAlphaValue:1.0f]; [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(fadeOut) object:nil]; [self performSelector:@selector(fadeOut) withObject:nil afterDelay:1.5f];&#125;- (void)fadeOut&#123; [NSAnimationContext runAnimationGroup:^(NSAnimationContext *context) &#123; context.duration = 0.3f; [self.animator setAlphaValue:0.0f]; &#125; completionHandler:^&#123; &#125;];&#125;+(CGFloat)scrollerWidthForControlSize:(NSControlSize)controlSize scrollerStyle:(NSScrollerStyle)scrollerStyle&#123; return 15;&#125;+ (BOOL)isCompatibleWithOverlayScrollers&#123; return self == [JJScroller class];&#125;@end]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>osx</tag>
        <tag>mac os</tag>
        <tag>NSScrollView</tag>
        <tag>NSScroller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac中NSScrollView滑动监测]]></title>
    <url>%2F2017%2F09%2F24%2FNSScrollViewSliding%2F</url>
    <content type="text"><![CDATA[不同于iOS中的UIScrollView，mac中的NSScrollView并没有一堆靠谱好用的delegate来帮助我们方便的监控ScrollView的状态。 iOS中我们可以通过UIScrollView的contentOffset属性来获知滑动的位置，而在mac中我们是通过NSScrollView的contentView(NSClipView的实例)的documentVisibleRect.origin来获知滑动的相对位置。 在iOS中我们可以通过UISCrollView的delegate方法- (void)scrollViewDidScroll:(UIScrollView *)scrollView;来在滑动的过程中做一些我们爱做的事儿呢。 那么在mac中NSScrollView我们有没有同样的东西来做我们爱做的事儿呢？当然是有的，只是跟iOS中有些许的区别，NSScrollView是通过通知来实现的，直接上代码： 123456//找个合适的地儿，注册通知NSNotificationCenter *center = [NSNotificationCenter defaultCenter] ; [center addObserver: self selector: @selector(boundsDidChangeNotification:) name: NSViewBoundsDidChangeNotification object: [self.scrollView contentView]]; 需要注意的是 ，在上面通知注册之前，你需要加上这么一句： 1[[self.scrollView contentView] setPostsBoundsChangedNotifications: YES]; 然后在NSScrollView滑动的时候，你就能在你实现下面这个方法的地方，做你想做的爱做的事儿了： 123456789101112- (void) boundsDidChangeNotification: (NSNotification *) notification&#123; // 在这里进行处理 NSClipView *changedContentView=[notification object]; // get the origin of the NSClipView of the scroll view that // we're watching NSPoint changedBoundsOrigin = [changedContentView documentVisibleRect].origin;&#125; 以上，欢迎典藏。]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>osx</tag>
        <tag>mac os</tag>
        <tag>NSScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xcode快捷键你知多少？]]></title>
    <url>%2F2017%2F07%2F30%2Fxcode-shortcuts%2F</url>
    <content type="text"><![CDATA[常言道，工欲善其事必先利其器。 了解xcode常用快捷键在coding中的使用，很容易摆脱鼠标的拖累，大大提高coding的效率。 快速搜索跳转文件快捷键：cmd + shift + o 这个快捷键的使用频率非常高，是摆脱鼠标的一大利器。 注意：o是表示惊讶的哦..😯，不是考试得到的零蛋0，o == open。 快速跳至某行快捷键：cmd + l 常用这个快捷键，首先你要留意一下行号。 注意：字母l并不是大写的I，也不是数字1，是大写字母L的小写，l == line。 代码块上下移动快捷键：option + cmd + [(or ]) 很多时候，你需要将某几行代码交换位子顺序，或者某几行代码前移/后移几行，那么这个快捷键就有了用武之地了。 注意：移动前选中你要移动的所有行。 .h/.m文件之间快速切换快捷键：ctrl + cmd + ↑(or ↓) ↑(or ↓)效果一样 前进/后退快捷键：ctrl + cmd + ←(or →) ←(or →)跟浏览器上一页or下一页类似。 显示当前类的方法列表，可搜索快捷键：ctrl + 6 上述快捷键之后，可方向键选择后回车，也可触摸板滑动选择。 最重要的是显示列表之后，可直接输入相关字符搜索。 搜索、替换文件类搜索：cmd + f 文件类替换：cmd + option + f 全局搜索：cmd + shift + f 全局替换：cmd + shift + option + f 注意：全局搜索替换可以指定目录，也可以选择匹配格式，这个选择在搜索框与替换框之间。 文件类与全局都可以在搜索框最前面的🔍位置点击切换搜索/替换。 打开Related Items列表快捷键：ctrl + 1 光标停留在相应的关键词中，此快捷键可查看父类，调用者，被调用者，includes，included by等诸多信息。 收起/展开代码块快捷键：option + cmd + ←(or →) 在左侧目录中快速定位当前文件位置快捷键：cmd + shift + j 快速切换左边导航栏快捷键：cmd + 1~8 注意：cmd + 0是‘显示/隐藏左侧栏’，cmd + cmd + option + 0是‘显示/隐藏右侧栏’。 全局修改局部变量快捷键：ctrl + cmd + e 当你想要将button换一个变量名的时候，这个快捷键绝对能爽死你，当然你也能用鼠标或者触摸板实现这个功能，选中变量名，移动光标会出现一个小箭头，点开会有快捷菜单，选择Edit All in Scope。 当然还有一些基础的快捷键在这里就不一一列举了，相信大家也都知道，比如，编译(cmd + b)，运行(cmd + r)，clean(cmd + shift + k)，快速移动光标(cmd + 方向键)，快速选择代码(cmd + shift + 方向键)等。 值得注意的是，除了上述快捷键之外，右键快捷菜单也是很有用处的，举个栗子： 光标置于类名中，右键(或者触摸板两手指头单击)显示快捷菜单，选择Refactor -- Rename，全局替换类名。 XVim最后，我想说的是，想要快捷键运用的炉火纯青，而且不会因为软件间系统间的各种差异出现很大的变化，vim！！ 这个绝对是神器，xcode可以安装vim插件XVim。 注意： xcode 8之后，需要先安装证书. 下载下来编译不过的话，是因为类IDEPlaygroundEditor没实现(IDEPlaygroundEditor+XVim.h中)，加上实现@implementation即可，或者直接删除报错的文件以及引用此文件头文件的地方。 XVim快捷键使用见这里。 放出一张vim命令图解：]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>xcode</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift闭包--简不简洁？！优不优雅？！]]></title>
    <url>%2F2017%2F07%2F22%2FClosures%2F</url>
    <content type="text"><![CDATA[闭包(Closures) 闭包是自包含的函数代码块，可以在代码中被传递和使用。 Closures are self-contained blocks of functionality that can be passed around and used in your code.–摘自官方文档 相信大家都熟悉C 和 Objective-C 中的代码块(blocks)或者其他一些编程语言中的匿名函数，Swift中的闭包与之相类似。 闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为包裹常量和变量。 注意: 如果你不熟悉捕获(capturing)这个概念也不用担心，在后面文章会对其进行详细介绍(我要尾随)。 Swift会为你管理在捕获过程中涉及到的所有内存操作。(PS:类似于Objective-C,不会让你过多的经历花费在内存管理上，而应该更过的考虑其他更重要的事情，本该如此!) 闭包一般采取以下三种形式： 全局函数是一个有名字但不会捕获任何值的闭包 嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包 闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包 Swift简洁优雅的个性在闭包中有很好的体现，主要优化如下： 利用上下文推断参数和返回值类型 隐式返回单表达式闭包，即单表达式闭包可以省略return关键字 参数名称缩写 尾随闭包语法 闭包表达式 闭包表达式是一种利用简洁语法构建内联闭包的方式。闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。 下面我们来看一个例子： Swift标准库提供了名为sorted(by:)的方法，它会根据你所提供的用于排序的闭包函数将已知类型数组中的值进行排序。一旦排序完成，sorted(by:)方法会返回一个与原数组大小相同，包含同类型元素且元素已正确排序的新数组。原数组不会被sorted(by:)方法修改。 举个栗子：闭包表达式示例使用sorted(by:)方法对一个String类型的数组进行字母逆序排序。 通常我们会这样写： 1234567891011//初始化一个字符串类型数组let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]//定义排序闭包函数func backward(_ s1: String, _ s2: String) -&gt; Bool &#123; return s1 &gt; s2&#125;//执行排序操作var reversedNames = names.sorted(by: backward)// reversedNames 为 ["Ewa", "Daniella", "Chris", "Barry", "Alex"] sorted(by:)方法接受一个闭包(其实就是一个函数指针)，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值前面，排序闭包函数需要返回true，反之返回false。 该例子对一个String类型的数组进行排序，因此排序闭包函数(func backward)类型需为(String, String) -&gt; Bool(即函数指针类型，两个参数String类型，返回值是Bool类型的函数指针)。 如果第一个字符串(s1)大于第二个字符串(s2)，backward(_:_:)函数会返回true，表示在新的数组中s1应该出现在s2前。对于字符串中的字符来说，“大于”表示“按照字母顺序较晚出现”。这意味着字母&quot;B&quot;大于字母&quot;A&quot;，字符串&quot;Tom&quot;大于字符串&quot;Tim&quot;。该闭包将进行字母逆序排序，&quot;Barry&quot;将会排在&quot;Alex&quot;之前。 然而，以这种方式来编写一个实际上很简单的表达式(a &gt; b)，确实太过繁琐了。对于这个例子来说，利用闭包 表达式语法可以更好地构造一个内联排序闭包。 闭包表达式语法有如下的一般形式: 123&#123; (parameters) -&gt; returnType in statements&#125; 闭包表达式参数可以是in-out参数，但不能设定默认值。也可以使用具名的可变参数(注意:但是如果可变参数不放在参数列表的最后一位的话，调用闭包的时时编译器将报错。)。元组也可以作为参数和返回值。 于是，我们可以将之前backward(_:_:)函数用闭包表达式优化，如下： 123reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2&#125;) 这个闭包的函数体部分如此短，以至于可以将其改写成一行代码:1reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 &#125; ) 该例中sorted(by:)方法的整体调用保持不变，一对圆括号仍然包裹住了方法的整个参数。然而，参数现在变成了内联闭包。 写到这里，如果你认为就此结束了的话，Swift君只能说你还是太年轻。 开篇我们提到，闭包会有这样一条优化：利用上下文推断参数和返回值类型。 排序闭包函数是作为sorted(by:)方法的参数传入的，Swift可以推断其参数和返回值的类型。sorted(b y:)方法被一个字符串数组调用，因此其参数必须是 (String, String) -&gt; Bool类型的函数。这意味着(String, String)和Bool类型并不需要作为闭包表达式定义的一部分。因为所有的类型都可以被正确推断，返回箭头(-&gt;)和围绕在参数周围的括号也可以被省略: 1reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; ) 实际上，通过内联闭包表达式构造的闭包作为参数传递给函数或方法时，总是能够推断出闭包的参数和返回值类型。这意味着闭包作为函数或者方法的参数时，你几乎不需要利用完整格式构造内联闭包。 其实，return关键词我们也是可以省略的，因为可以 单表达式闭包隐式返回 ,这也是闭包的主要优化之一。 如上的例子可以改写为:1reversedNames = names.sorted(by: &#123; s1, s2 in s1 &gt; s2 &#125; ) sorted(by:)方法的参数类型明确了闭包必须返回一个Bool类型值。因为闭包函数体只包含了一个单一表达式(s1 &gt; s2)，该表达式返回Bool类型值，因此这里没有歧义，return关键字可以省略。 开篇提到的闭包优化的几点中，还有说道 参数名称缩写 功能。 Swift君有说：你可以直接通过$0，$1，$2来顺序调用闭包的参数，以此类推。如果你在闭包表达式中使用参数名称缩写，你可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。 in关键字也同样可以被省略,因为…，看下面优化后的代码你明白，in在这里确实没什么卵用了： 1reversedNames = names.sorted(by: &#123; $0 &gt; $1 &#125; ) 其中，$0和$1表示闭包中第一个和第二个String类型的参数. 我次奥！！！到这里，我相信大家会有跟我一样的感叹，哈哈~ 所以，最后还是有必要来一记大招：1reversedNames = names.sorted(by: &gt;) 是的，你没有看错，这才是最终的形态。 Swift的String类型定义了关于大于号(&gt;)的字符串实现，其作为一个函数接受两个String类型的参数并返回Bool类型的值。而这正好与sorted(by:)方法的参数需要的函数类型相符合。因此，你可以简单地传递一个大于号，Swift可以自动推断出你想使用大于号的字符串函数实现。 贴上大于号(&gt;)的定义： 12345678910/// Returns a Boolean value indicating whether the value of the first argument/// is greater than that of the second argument.////// This is the default implementation of the greater-than operator (`&gt;`) for/// any type that conforms to `Comparable`.////// - Parameters:/// - lhs: A value to compare./// - rhs: Another value to compare.public func &gt;&lt;T&gt;(lhs: T, rhs: T) -&gt; Bool where T : Comparable 当然还有更多的运算符方法，想到这里，我就想问你，简洁不简洁，优雅不优雅，刺激不刺激？！哈哈。。。]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 9.0之后NSString encode方法替换]]></title>
    <url>%2F2017%2F07%2F22%2FEncode_Update%2F</url>
    <content type="text"><![CDATA[在iOS 9.0之后，以前常用的NSString编码的方法stringByAddingPercentEscapesUsingEncoding:被弃用了，项目中可能会出现一堆如下⚠️： ‘stringByAddingPercentEscapesUsingEncoding:’ is deprecated: first deprecated in iOS 9.0 - Use-stringByAddingPercentEncodingWithAllowedCharacters: instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid. 作为一个有强迫症的优秀程序猿，表示不能忍！ 文档里面是这么说的： 1- (nullable NSString *)stringByAddingPercentEscapesUsingEncoding:(NSStringEncoding)enc NS_DEPRECATED(10_0, 10_11, 2_0, 9_0, &quot;Use -stringByAddingPercentEncodingWithAllowedCharacters: instead,which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid.&quot;); 很明白，用stringByAddingPercentEncodingWithAllowedCharacters:方法替换之。 这个方法官方文档是这么说的： // Returns a new string made from the receiver by replacing all characters not in the allowedCharacters set with percent encoded characters. UTF-8 encoding is used to determine the correct percent encoded characters. Entire URL strings cannot be percent-encoded. This method is intended to percent-encode an URL component or subcomponent string, NOT the entire URL string. Any characters in allowedCharacters outside of the 7-bit ASCII range are ignored. 最后一句Any characters in allowedCharacters outside of the 7-bit ASCII range are ignored.，意思就是说，任何非7-bit ASCII字符搁到allowedCharacters里面也将被忽略，也就是allowedCharacters里面的字符跟7-bit ASCII字符不会被编码，比如中文。 换句话说，上面方法在处理的时候会编码url的中的非7-bit ASCII字符，如这些【`#%^{}\”[]|\&lt;&gt;】，如果需要忽略之，需要通过(NSCharacterSet *)allowedCharacters这个参数指定。总结如下 1234[aString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];//等价于[aString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet characterSetWithCharactersInString:@&quot;`#%^&#123;&#125;\&quot;[]|\\&lt;&gt; &quot;]]; 注意： 字符集最后是一个空格！ 这里字符集的意思就是，字符串中含有字符集里面的字符将会会被编码。 另外，URL中常用的NSCharacterSet类型定义在分类NSCharacterSet (NSURLUtilities)中，包含字符集如下： 1234567891011URLHostAllowedCharacterSet &quot;#%/&lt;&gt;?@\^`&#123;|&#125;URLFragmentAllowedCharacterSet &quot;#%&lt;&gt;[\]^`&#123;|&#125;URLPasswordAllowedCharacterSet &quot;#%/:&lt;&gt;?@[\]^`&#123;|&#125;URLPathAllowedCharacterSet &quot;#%;&lt;&gt;?[\]^`&#123;|&#125;URLQueryAllowedCharacterSet &quot;#%&lt;&gt;[\]^`&#123;|&#125;URLUserAllowedCharacterSet &quot;#%/:&lt;&gt;?@[\]^` 以上，还在等什么，全局搜索替换吧，消灭⚠️！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>encode</tag>
        <tag>NSString</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS脚本自动编译静态包/静态库]]></title>
    <url>%2F2017%2F07%2F22%2Fautobuild%2F</url>
    <content type="text"><![CDATA[在iOS开发中，有时候为了项目模块间的相互独立性，降低模块间的耦合，通常将底层相对稳定的模块抽取出来，形成SDK，以静态包或者静态库的形式引入项目。这中间免不了编译打包静态包/库，通常的做法是模拟器和真机分别编译，然后再将两个静态包或者库lipo合并成一个。这样的工作做多了，难免觉得麻烦，想省事儿，整一脚本变得自然而然了。 1. 创建一个静态包/库工程(已有请跳过这一步) 创建如下图： 在Trargets下面，点击左下角的“+”,选择添加一个新的Target， 然后选择“Aggregate”选项，新建一个集合类target，如下图所示： 2. 给集合类添加依赖 在Targets下面选中我们新建的集合类，然后Build Phases –&gt; Target Dependencies 下面添加我们需要编译的静态库,如下图所示： 3. 添加脚本 在Targets下面选中我们新建的集合类,然后在Build Phases下，点击左上角的“+”，选择”New Run Script Phase”选项,如下图： 然后设置我们运行的脚本的所在位置,如下图所示: 注意： ../scripts/build-framework.sh 表示脚本的位置在当前工程的上一个目录下地scripts文件夹下. 当然”../“也可以用”${SRCROOT}/../“来代替. 脚本位置可根据实际情况自行设置。 4. 选择我们创建的集合类的target，编译 在编译时，你可能会遇到下面的错误：1Permission denied. 这是因为shell脚本，还没有添加可执行的权限。 解决办法：在终端上， cd 进入到脚本所在的文件夹； 然后使用 chmod +x ./yourShellName.sh 命令， 成功之后，就可以正常的运行Xcode工程了。 5. 指定target 一般来说我们编译的target名称，跟我们的project工程的名称是一样的，但是，如果我们修改了我们的target名称，需要在我们制定脚本的位置后面跟上我们需要编译的target名称，既:脚本位置+空格+target名称。如下图： 6. shell脚本源码 编译library的脚本 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/sh#要build的target名target_Name=$&#123;PROJECT_NAME&#125;if [[ $1 ]]thentarget_Name=$1fiUNIVERSAL_OUTPUT_FOLDER="$&#123;SRCROOT&#125;/$&#123;PROJECT_NAME&#125;_Products"# 创建输出目录，并删除之前的文件rm -rf "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;"mkdir -p "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;"# 分别编译真机和模拟器版本xcodebuild -target "$&#123;target_Name&#125;" ONLY_ACTIVE_ARCH=NO -configuration $&#123;CONFIGURATION&#125; -sdk iphoneos BUILD_DIR="$&#123;BUILD_DIR&#125;" BUILD_ROOT="$&#123;BUILD_ROOT&#125;" clean buildxcodebuild -target "$&#123;target_Name&#125;" ONLY_ACTIVE_ARCH=NO -configuration $&#123;CONFIGURATION&#125; -sdk iphonesimulator BUILD_DIR="$&#123;BUILD_DIR&#125;" BUILD_ROOT="$&#123;BUILD_ROOT&#125;" clean build#复制头文件到目标文件夹HEADER_FOLDER="$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/include/$&#123;target_Name&#125;"if [[ -d "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/usr/local/include" ]]then HEADER_FOLDER="$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/usr/local/include"ficp -R "$&#123;HEADER_FOLDER&#125;" "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;"#合成模拟器和真机.a包lipo -create "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/lib$&#123;target_Name&#125;.a" "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphoneos/lib$&#123;target_Name&#125;.a" -output "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/lib$&#123;target_Name&#125;.a"# 判断build文件夹是否存在，存在则删除if [ -d "$&#123;SRCROOT&#125;/build" ]thenrm -rf "$&#123;SRCROOT&#125;/build"fi#打开目标文件夹open "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;" 编译framework的shell脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/bin/sh#要build的target名TARGET_NAME=$&#123;PROJECT_NAME&#125;if [[ $1 ]]thenTARGET_NAME=$1fiUNIVERSAL_OUTPUT_FOLDER="$&#123;SRCROOT&#125;/$&#123;PROJECT_NAME&#125;_Products/"#创建输出目录，并删除之前的framework文件mkdir -p "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;"rm -rf "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/$&#123;TARGET_NAME&#125;.framework"#分别编译模拟器和真机的Frameworkxcodebuild -target "$&#123;TARGET_NAME&#125;" ONLY_ACTIVE_ARCH=NO -configuration $&#123;CONFIGURATION&#125; -sdk iphoneos BUILD_DIR="$&#123;BUILD_DIR&#125;" BUILD_ROOT="$&#123;BUILD_ROOT&#125;" clean buildxcodebuild -target "$&#123;TARGET_NAME&#125;" ONLY_ACTIVE_ARCH=NO -configuration $&#123;CONFIGURATION&#125; -sdk iphonesimulator BUILD_DIR="$&#123;BUILD_DIR&#125;" BUILD_ROOT="$&#123;BUILD_ROOT&#125;" clean build#拷贝framework到univer目录cp -R "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;TARGET_NAME&#125;.framework" "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;"#合并framework，输出最终的framework到build目录lipo -create -output "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/$&#123;TARGET_NAME&#125;.framework/$&#123;TARGET_NAME&#125;" "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;TARGET_NAME&#125;.framework/$&#123;TARGET_NAME&#125;" "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphoneos/$&#123;TARGET_NAME&#125;.framework/$&#123;TARGET_NAME&#125;"#删除编译之后生成的无关的配置文件dir_path="$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/$&#123;TARGET_NAME&#125;.framework/"for file in ls $dir_pathdoif [[ $&#123;file&#125; =~ ".xcconfig" ]]thenrm -f "$&#123;dir_path&#125;/$&#123;file&#125;"fidone#判断build文件夹是否存在，存在则删除if [ -d "$&#123;SRCROOT&#125;/build" ]thenrm -rf "$&#123;SRCROOT&#125;/build"firm -rf "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator" "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphoneos"#打开合并后的文件夹open "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;"]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--单例模式]]></title>
    <url>%2F2017%2F07%2F16%2FDesignPattern_Singleton%2F</url>
    <content type="text"><![CDATA[单例模式(singleton) 单例模式最初的定义出现于《设计模式》(Addison-Wesley,1994) 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式几乎是设计模式的最简单形式了，这一模式的意图是使得类的一个对象成为系统中的唯一实例。要实现这一点，可以从客户端对其进行实例化开始。因此需要一种只允许生成对象类的唯一实例的机制，“阻止”所有想要生成对象的访问。我们可以用工厂方法来限制实例化的过程。这个方法应该为静态方法(类方法)，因为我们让类的实例去生成另一个唯一实例毫无意义。 单例模式的类图如下： static uniqueInstance是Singleton的唯一实例，static sharedInstance将它返回给客户端。通常，sharedInstance会检查uniqueInstance是否已经被实例化，如果没有，它会生成一个实例后返回uniqueInstance。 何时使用原型模式？在以下情形，会考虑使用原型模式： 类只有一个实例，而且必须从一个为人熟知的访问点对其进行访问，比如工厂方法； 这个唯一实例只能通过子类化进行扩展，而且扩展的对象不会破坏客户端代码。 使用Cocoa Touch框架中使用单例模式Cocoa Touch框架中使用了大量的单例类。下面讨论其中的几个： 1.UIApplication类 框架中使用最常用的一个类是UIApplication类。它提供了一个控制并协调iOS应用程序的集中点。 每个应用程序有且仅有一个UIApplication的实例。它由UIApplicationMain函数在应用程序启动时创建为单例对象。之后，对同一UIApplication实例可以通过其sharedApplication类方法进行访问。 UIApplication对象为应用程序处理许多内存管理任务(housekepping task)，包括传入事件的最初路由，以及为UIControl分发动作消息给核实的目标对象。它还维护应用程序中的所有UIWindow对象的列表。。应用程序对象总是被分配一个UIApplicationDelegate对象，应用程序将把重要的运行时状态通知给它，比如iOS应用程序中的应用程序启动、内存不足警告、应用程序终止和后台进行执行。这让委托(delegate)有机会做出适当的响应。 2.UIAcceleremeter类 Cocoa Touch框架中另一个常用的单例是UIAcceleremeter.UIAcceleremeter让应用程序可以注册，以接收来自iOS设备内置的加速度计的加速度的相关数据。应用程序会收到三维空间中沿主轴的线性加速度变化，可以使用这一数据检测设备的当前方向和当前方向的瞬间变化。 UIAcceleremeter是单例，所以不能直接生成它的对象。而是应该调用其sharedAcceleremeter单例类方法以访问它的唯一实例。然后设定它的updateInterval属性，并用自己的delegate对象设定delegate属性，以接收来自单例实例的加速度数据。 3.NSFileManager类 在Mac OS X v10.5和iOS2.0之前，NSFileManager曾经是单例模式的“严格”实现。调用它的init方法是空操作，并且唯一实例可以通过defaultManager类方法创建和访问。然而其单例实现并不是线程安全的。现在推荐生成新的NSFileManager实例以保证线程安全。这一方式被认为是更灵活的单例实现，其中工厂方法总是返回同一实例，但是也可以分配并初始化另外的实例。 附上单例模式的Demo：DesignPattern_Singleton]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--生成器(建造者)]]></title>
    <url>%2F2017%2F07%2F09%2FDesignPattern_Builder%2F</url>
    <content type="text"><![CDATA[生成器模式(Builder) 生成器模式最初的定义出现于《设计模式》(Addison-Wesley,1994) 生成器模式：将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表现。 生成器模式的类图如下： 除了客户与其所要的产品，生成器模式还包含两个重要角色：Director(指导者)和Builder(生成器)。Builder知道究竟如何在缺少某些特定信息的情况下建造产品(什么)。Director知道Builder应该建造什么，以参数向其提供缺少的信息来建造特定产品。尽管Director知道Builder应该建造什么，这并不意味着Director知道具体Builder究竟是什么。他们的静态关系如上图中的类图所示。 Builder是一个抽象接口，声明了一个buildPart方法，该builder方法由ConcreteBuilder实现，以构造实际产品(Product)。ConcreteBuilder有个getResult方法，向客户端返回构造完毕的Product。Director定义了一个construct方法，命令Builder的实例去builderPart。Director与Builder形成了一种聚合关系。这意味着Builder是一个组成部分，与Director结合，以使整个模式运转，但同时，Director并不负责Builder的生存期。 何时使用生成器模式？在以下情形，你自然会想到使用工厂方法模式： 需要创建设计各种部件的负责对象。创建对象的算法应该独立于部件的装配方式。 构建过程需要以不同的方式(例如，部件或者表现的不同组合)构建对象。 生成器与抽象工厂对比 生成器 抽象工厂 构建负责对象 构建简单或者复杂对象 以多个步骤构建对象 以单一步骤构建对象 以多种方式构建对象 以单一方式构建对象 在构建过程的最后一步返回产品 立刻返回产品 专注一个特定产品 强调一套产品 附生成器模式的Demo：DesignPattern_Builder]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--抽象工厂]]></title>
    <url>%2F2017%2F07%2F08%2FDesignPattern_AbstractFactory%2F</url>
    <content type="text"><![CDATA[抽象工厂模式(abstract factory) 抽象工厂模式最初的定义出现于《设计模式》(Addison-Wesley,1994) 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。 抽象工厂模式的类图如下： 在软件设计中，如果客户端想手工创建一个类的对象，那么客户端需要首先知道这个类的细节。更糟的情况是，一组相关的对象可以在运行时按照不同的标准创建得不一样，此时客户端就需要知道全部细节才能创建他们。这种情况就可以用抽象工厂模式来解决这个问题。 抽象工厂提供一个固定的接口，用于创建一系列有关联或相互依存的对象，而不必指定其具体类或创建细节。客户端与从工厂得到的具体对象之间没有耦合。 Client只知道AbstractFactory和AbstractProduct。每个工厂类中，结构与实际操作的细节按黑箱对待。甚至产品也不知道谁将负责创建他们。只有具体工厂知道为客户端创建什么、如何创建。这个模式有趣的一点是，很多时候他都是用哪个工厂方法模式来实现。工厂方法吧实际的创建过程推迟到重载它的子类中。在类图中，方法createProductA和createProductB是工厂方法。最初的抽象方法什么也不创建。这种抽象非常通用，广泛用于任何需要抽象创建过程的场合。 抽象模式常与原型模式、单例模式、享元模式等其他设计模式一起使用。 抽象工厂模式与工厂方法模式 抽象工厂模式 工厂方法模式 通过对象组合创建抽象产品 通过类继承创建抽象产品 创建多系列产品 创建一种产品 必须修改父类才能支持新的产品 子类化创建者并重载工厂方法以创建新产品 软件设计黄金法则： 变动需要抽象 在Cocoa Touch框架中使用抽象工厂抽象工厂模式常见于Cocoa Touch框架。有很多基础类采用了这一模式。特别常见的一个就是NSNumber。创建NSNumber实例的方式完全符合抽象工厂模式。 创建Cocoa Touch对象有两种方式：使用先alloc再init的方法(两步创建过程)，或者使用类中的+className...方法。在Cocoa Touch的基础框架中，NSNumber类有很多类方法用于创建各种类型的NSNumber对象，像下面这样的：12345NSNumber * boolNumber = [NSNumber numberWithBool:YES];NSNumber * charNumber = [NSNumber numbberWithChar:'a'];NSNumber * intNumber = [NSNumber numberWithInt:1];NSNumber * floatNumber = [NSNumber numberWithFloat:1.0];NSNumber * doubleNumber = [NSNumber numberWithDouble:1.0]; 每个返回的对象属于代表最初输入值的不同私有子类。可以像这样列出他们的描述： 12345NSLog(@"%@",[[boolNumber class] description]);NSLog(@"%@",[[charNumber class] description]);NSLog(@"%@",[[intNumber class] description]);NSLog(@"%@",[[floatNumber class] description]);NSLog(@"%@",[[doubleNumber class] description]); 将看到控制台输出： 12345NSCFBolleanNSCFNumberNSCFNumberNSCFNumberNSCFNumber 除了boolNumber的实际类型是NSCFBoolean以外，大多数实际类为NSCFNumber类型。尽管这些+className...类工厂方法返回NSNumber具体子类的实例，但是返回的实例确实支持NSNumber的公有接口。 虽然它们属于NSNumber的不同具体子类，但是其行为由抽象超类NSNumber定义，而且是公有的。若执行以下代码段，就会明白我的意思。 12NSLog(@"%@",[boolNumber intValue]);NSLog(@"%@",[charNumber boolValue] ? @"YES" : @"NO"); 将看到控制台输出： 121YES boolNumber 内部保持布尔值YES，但是仍然实现了公有intValue方法，返回反映其内部布尔值的适当整数值。charNumber也是如此，它重载了boolValue方法，返回反映其内部布尔值的适当布尔值。 接受不同类型的参数并返回NSNumber实例的类方法是类工厂方法(工厂方法模式)。NSNumber的类工厂方法生产各种“数工厂”。numberWithBool:创建NSCFBoolean工厂的实例，而numberWithInt:创建NSCFNumber的实例。NSNumber中的类工厂方法定义了决定实例化何种私有具体子类(比如，NSCFBoolean或NSCFNumber)的默认行为。这一版本的工厂方法是传统工厂方法的一个变体，虽然它达成了返回抽象产品的目的，此处的抽象产品为作为工厂的具体NSNumber子类。NSNumber是抽象工厂实现的一个例子。基础框架中抽象工厂的此种特点被称为“类簇”(Class Cluster)。 类簇是基础框架中一种常见的设计模式，基于抽象工厂模式的思想，它将若干相关的私有具体工厂子类集合到一个公有的抽象超类之下。类簇是抽象工厂的一种形式。 创建抽象产品的工厂方法与创建抽象工厂的工厂方法之前有个不同点。显然，像intValue和boolValue这样的工厂方法，应该在具体工厂(NSCFNumber和NSCFBoolean)中重载以返回实际值(产品)。其它像numberWithBool:和numberWithInt:这样的工厂方法并不是为了返回产品，而是为了返回能返回产品的工厂，因此它们不应在具体工厂子类中重载。 其它实现为类簇的基础类有NSData,NSArray,NSDictionary和NSString。 附上抽象工厂模式的Demo：DesignPattern_AbstractFactory]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown中插入表格/图表，位置居中/左/右，这一篇就够了！]]></title>
    <url>%2F2017%2F07%2F08%2FMarkdown_Table%2F</url>
    <content type="text"><![CDATA[Markdown中插入表格时只需要复制一下下面【】内的即可(注意：不要复制【】)。 说明： 两竖线|中间为一个单元格，每行列数即为每行竖线数-1； 行数-1为表格行数，因为第二行为配置行，配置表格显示用，并不显示出来； 【|标题一|标题二|标题三|标题四||- |:—|—:|:—:||xxxxxxxxx|xxxxxxxxx|xxxxxxxxx|xxxxxxxxx||xxxxxxxxxxxxxx|xxxxxxxxxxxxxx|xxxxxxxxxxxxxx|xxxxxxxxxxxxxx||xxxxxxxxx|xxxxxxxxx|xxxxxxxxx|xxxxxxxxx||】 标题一 标题二 标题三 标题四 xxxxxxxxx xxxxxxxxx xxxxxxxxx xxxxxxxxx xxxxxxxxxxxxxx xxxxxxxxxxxxxx xxxxxxxxxxxxxx xxxxxxxxxxxxxx xxxxxxxxx xxxxxxxxx xxxxxxxxx xxxxxxxxx]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--工厂方法]]></title>
    <url>%2F2017%2F07%2F02%2FDesignPattern_FactoryMethod%2F</url>
    <content type="text"><![CDATA[工厂方法模式(factory method) 工厂方法模式最初的定义出现于《设计模式》(Addison-Wesley,1994) 工厂方法模式：定义创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到其子类。 工厂方法模式的类图如下： 工厂方法也成为虚构造器(virtual constructor)。它适用于这种情况：一个类无法预期需要生成哪个类的对象，想让其子类来指定所生成的对象。 抽象的Product(产品)定义了工厂方法创建的对象的接口。ConcreteProduct实现了Product接口。Creator定义了返回Product对象的工厂方法。它也可以为工厂方法定义一个默认实现，返回默认ConcreteProduct对象。Creator的其他操作可以调用此工厂方法创建Product对象。ConcreteProduct是creator的子类。它重载了工厂方法，以返回ConcreteProduct的实例。 工厂方法的最初定义好像专注于让子类决定创建什么对象。有一种变体，抽象类使用工厂方法创建其私有子类或者任何其他类的对象(抽象工厂模式)。(接下来的文章会详细描述抽象工厂模式) 何时使用工厂方法模式？在以下情形，你自然会想到使用工厂方法模式： 编译时无法确定预期要创建的对象的类； 类想让其子类决定是在运行时创建什么； 类有若干辅助类为其子类，而你想将返回哪个子类这一信息局部化。 在Cocoa Touch框架中应用工厂方法工厂方法在Cocoa Touch框架中几乎随处可见。大家知道常见的两步对象创建法[[SomeClass alloc] init]。有时，我们会注意到有一些“便利”方法返回类的实例。例如，NSNumber有很多numberWith*方法，其中有两个是numberWithBool:和numbberWithChar:。它们是类方法，也就是说，我们向NSNumber发送[NSNumber numberWithBool:bool]与[NSNumber numbberWithChar:char],以获得与传入参数同类型的各种NSNumber实例。与如何创建NSNumber的具体实例有关的所有细节，都是 由NSNumber的类工厂方法负责。 [NSNumber numberWithBool:bool]的情况是，方法接受值bool，并把NSNumber的内部子类(实际上是NSCFBoolean类)的一个实例初始化，让他能够反映传入的值bool. 附上工厂方法模式的Demo：DesignPattern_FactoryMethod]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--原型模式]]></title>
    <url>%2F2017%2F07%2F02%2FDesignPattern_Prototype%2F</url>
    <content type="text"><![CDATA[原型模式(prototype) 原型模式最初的定义出现于《设计模式》(Addison-Wesley,1994) 原型模式：使用原型实例指定创建对象的种类。并通过复制这个原型创建新的对象。 原型模式的类图如下： 原型模式是一种非常简单的设计模式。客户端知道抽象Prototype类，在运行时，抽象Prototype子类的任何对象都可以按客户端的意愿被复制。因此，无需手工创建就可以制造同意类型的多个实例。 Prototype声明了复制自身的接口。作为Prototype的子类，ConcretePrototype实现了Concrete复制自身的clone操作。 这里，客户端通过请求原型复制其自身，创建了一个新的对象。 何时使用原型模式？在以下情形，会考虑使用原型模式： 需要创建的对象独立于其类型与创建的方式； 实例化的类是在运行时决定的； 不想要与产品层次相对应的工厂层次； 不同类的实例间的差异仅是状态的若干组合，这样复制相应数量的原型比手工实例化更加方便； 类不容易创建，比如每个组件可把其他组件作为子节点的组合对象，复制已有的组合对象并对副本进行修改会更加容易。 使用Cocoa Touch框架中的对象复制 值得注意的是：浅复制与深复制的区别 浅复制只是复制了对象的指针，而同时指向相同的对象资源，也就是说只是复制了栈里面的内容，而同时指向相同的堆空间。改变其对象值得时候，复制对象间会相互影响。 深复制是同时复制对象的指针跟对象本身，也就是同时复制了堆栈空间的内容。 Cocoa Touch框架为NSObject的派生类提供了实现深复制的协议。NSObject的子类需要实现NSCopying协议及其方法-(id)copyWithZone:(NSZone *)zone。NSObject有一个实例方法叫-(id)copy。默认的copy方法调用[self copyWithZone:nil]。对于采纳了NSCopying协议的子类，需要实现这个方法。否则将引发异常。iOS中，这个方法保持新的副本对象，然后将其返回。 附上原型模式的Demo：DesignPattern_Prototype]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一行命令搞定node.js升级]]></title>
    <url>%2F2017%2F06%2F25%2Fnode_update%2F</url>
    <content type="text"><![CDATA[node有一个模块叫n，是专门用来管理node.js的版本的。 首先安装n模块： 1npm install -g n 第二步：升级node.js到最新稳定版 1n stable 完工！是不是很简单？！n后面也可以跟随版本号比如： 123n v0.10.26或n 0.10.26 就这么简单…]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行常用命令--软连接]]></title>
    <url>%2F2017%2F06%2F23%2FcommandLine_softconnection%2F</url>
    <content type="text"><![CDATA[比如，想要用命令行指定特定程序打开文件。 如果文件已被指定默认程序： 1open httpd.conf 指定一个特定程序打开文件 12# 用 sublime text 打开 httpd.confopen -a /Applications/Sublime\ Text.app/ httpd.conf 如果使用频繁，还可以添加软连接 1sudo ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/bin/sublime 输入sublime httpd.conf就可以用 sublime text 打开文件 mac Mac OS X 11之后的版本，上述操作你可能会遇到下面的问题：1ln: /usr/bin/sublime: Operation not permitted 使用管理员sudo命令,依旧失败! 原来MacOS 10.11开始apple引入了Rootless机制,你再也不能随心所欲的改写很多关键路径了,就算你是Root用户也不行,除非是Apple自身签名的软件（含命令行工具）才可以!用Apple的话来说: Rootless机制将成为对抗恶意程序的最后防线。 Mac OS X 11中的/usr/bin 的“Operation not permitted” 如果要关闭Rootless必须重启Mac进入恢复模式,然而关闭它意味着你的MacOS安全大门变得有些薄弱,这并不是什么好消息!!!!! 那么有没有什么办法即可以不用关闭Rootless又可以设置Sublime Text3的快捷方式呢!? 答案是:必须的!!! 我们只需要将其路径添加到/usr/local/bin下即可,Rootless并没有限制该目录的修改,而且bash也会从该目录中寻找可执行的bin!YES!!!1sudo ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/sublime]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
        <tag>软连接</tag>
        <tag>Open File</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIImageView添加圆角的几种方法]]></title>
    <url>%2F2017%2F06%2F22%2FUIImageView_layer_corner%2F</url>
    <content type="text"><![CDATA[创建一个UIImageView对象：1UIImageView * poImgView = [[UIImageView alloc] init]; 第一种方法 123poImgView.layer.cornerRadius = poImgView.frame.size.width/2.0;poImgView.layer.masksToBounds = YES;（或者 poImgView.clipsToBounds = YES;） clipsToBounds是对view的切割，masksToBounds是对layer的切割。 性能消耗：这个是离屏渲染（off-screen-rendering），对性能消耗比较大。fps大致在45帧左右（每个cell 做2个imageview）（正常fps是60帧，越小，用户体验越差）。 离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。由上面的一个结论视图和圆角的大小对帧率并没有什么卵影响，数量才是伤害的核心输出啊。可以知道离屏渲染耗时是发生在离屏这个动作上面，而不是渲染。为什么离屏这么耗时？原因主要有创建缓冲区和上下文切换。创建新的缓冲区代价都不算大，付出最大代价的是上下文切换。 第二种方法 1234CAShapeLayer *layer = [CAShapeLayer layer];UIBezierPath *aPath = [UIBezierPath bezierPathWithOvalInRect:aImageView.bounds];layer.path = aPath.CGPath;poImgView.layer.mask = layer; 性能消耗：测试fps大致在20帧左右，比方案A的消耗更大。 第三种方法 12345678910- (UIImage *)imageWithCornerRadius:(CGFloat)radius &#123; CGRect rect = (CGRect)&#123;0.f, 0.f, self.size&#125;; UIGraphicsBeginImageContextWithOptions(self.size, NO, UIScreen.mainScreen.scale); CGContextAddPath(UIGraphicsGetCurrentContext(),[UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath); CGContextClip(UIGraphicsGetCurrentContext()); [self drawInRect:rect]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 性能消耗：这个是on-screen-rendering相当于时时去做渲染，相比于A.B方案的离线渲染，此方法对性能消耗最低，推荐用此方案。 值得一提第一种跟第二种方法都是比较常见的方式，但是都不推荐，对此的优化方案是是用第三种方式，但是如果非要使用第一种跟第二种，补救措施是： 12self.layer.shouldRasterize = YES;self.layer.rasterizationScale = [UIScreen mainScreen].scale; 当shouldRasterize设成true时，layer被渲染成一个bitmap，并缓存起来，等下次使用时不会再重新去渲染了。 实现圆角本身就是在做颜色混合（blending），如果每次页面出来时都blending，消耗太大，这时shouldRasterize = yes，下次就只是简单的从渲染引擎的cache里读取那张bitmap，节约系统资源。 如果在滚动tableView时，每次都执行圆角设置，肯定会阻塞UI，设置这个将会使滑动更加流畅。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UIImageView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD：串行/并行/主队列下，同步/异步的执行方式]]></title>
    <url>%2F2017%2F06%2F22%2FGCD_syn_asyn%2F</url>
    <content type="text"><![CDATA[GCD中获取各种类型的队列：12345678//获取串行的队列 dispatch_queue_t singalQueue = dispatch_queue_create("single",DISPATCH_QUEUE_SERIAL);//获取并发执行的队列dispatch_queue_t concrtQueue = dispatch_queue_create("queue", DISPATCH_QUEUE_CONCURRENT);//获取主队列dispatch_queue_t mainQueue = dispatch_get_main_queue();//获取全局的队列（并发的）dispatch_queue_t gobalqueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 串行队列异步执行任务 异步具有创建新线程的能力，会开辟新线程去执行任务； 按照串行的方式去执行任务。 如下调用方式可参考：123456- (void)singalAsynQueue&#123; //创建串行队列 dispatch_queue_t singalQueue = dispatch_queue_create("singal", DISPATCH_QUEUE_SERIAL); //在singalQueue中异步执行任务(该方法实现在本文后续中) [self asynWithQueue: singalQueue]; &#125; 串行队列同步执行任务 同步不具有创建新的线程的能力， 不会开辟新的线程去执行任务，会在当前的程序的主线程中去执行任务； 按照串行的方式去执行任务。 如下调用方式可参考：123456- (void)singalSynQueue&#123; //创建串行队列 dispatch_queue_t singalQueue = dispatch_queue_create("singal", DISPATCH_QUEUE_SERIAL); //在singalQueue中同步执行任务(该方法实现在本文后续中) [self synWithQueue: singalQueue];&#125; 并发队列异步执行任务（常用） 异步具有创建新的线程的能力，会开辟新的线程去执行任务，不会在当前的程序的主线程中去执行任务； 按照并发的方式去执行任务。 如下调用方式可参考：12345678- (void)concrtAsynQueue&#123; //创建并发执行的队列// dispatch_queue_t concrtQueue = dispatch_queue_create("concrtQueue", DISPATCH_QUEUE_CONCURRENT); //获取全局的队列 dispatch_queue_t concrtQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //在concrtQueue中异步执行任务(该方法实现在本文后续中) [self asynWithQueue:concrtQueue];&#125; 并发队列同步执行任务 同步不具有创建新的线程的能力， 不会开辟新的线程去执行任务，会在当前的程序的主线程中去执行任务； 按照同步的方式去执行任务。 如下调用方式可参考：12345678- (void)concrtSynQueue&#123; //创建并发执行的队列// dispatch_queue_t concrtQueue = dispatch_queue_create("concrtQueue", DISPATCH_QUEUE_CONCURRENT); //获取全局的队列 dispatch_queue_t concrtQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //在concrtQueue中同步执行任务(该方法实现在本文后续中) [self synWithQueue:concrtQueue];&#125; 主队列的同步(会造成程序的死锁) 如下：123456- (void)mainSynQueue&#123; //获取主队列 dispatch_queue_t mainQueue = dispatch_get_main_queue(); //在mainQueue中同步执行任务(该方法实现在本文后续中) [self synWithQueue:mainQueue];&#125; 主队列的异步(在主线程中顺序执行) 新添加到主队列中的任务会放到队列的最尾部，等到当前主线程中的任务结束之后然后再从队列的头部取出依次执行（FIFO）先进先出。 如下调用方式可参考：123456- (void)mainAsynQueue&#123; //获取主队列 dispatch_queue_t mainQueue = dispatch_get_main_queue(); //在mainQueue中异步执行任务(该方法实现在本文后续中) [self asynWithQueue:mainQueue]; &#125; 异步方法的实现123456789101112131415161718192021- (void)asynWithQueue:(dispatch_queue_t)queue&#123; NSLog(@"%@",[NSThread currentThread]); dispatch_async(queue, ^&#123; NSLog(@"----1----%@",[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@"----2----%@",[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@"----3----%@",[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@"----4----%@",[NSThread currentThread]); &#125;); NSLog(@"--------end------------");&#125; 同步方法的实现123456789101112131415161718192021- (void)synWithQueue:(dispatch_queue_t)queue&#123; NSLog(@"%@",[NSThread currentThread]); dispatch_sync(queue, ^&#123; NSLog(@"----1----%@",[NSThread currentThread]); &#125;); dispatch_sync(queue, ^&#123; NSLog(@"----2----%@",[NSThread currentThread]); &#125;); dispatch_sync(queue, ^&#123; NSLog(@"----3----%@",[NSThread currentThread]); &#125;); dispatch_sync(queue, ^&#123; NSLog(@"----4----%@",[NSThread currentThread]); &#125;); NSLog(@"--------end------------");&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
</search>