<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[grep命令常用参数]]></title>
    <url>%2F2018%2F09%2F26%2FGrepCommonParams%2F</url>
    <content type="text"><![CDATA[-A num, --after-context=num - 打印出找到的匹配行后num行。这个跟-B，-C类似功能，主要用于查看上下文。 -B num, --before-context=num - 打印出找到的匹配行前num行。 -C[num, --context=num] - 打印出找到的匹配行前后num行，相当于-A num -B num。 -c, --count - 统计出匹配的总行数，同一行有两个匹配也只算一行。 --colour=[when, --color=[when]] - 将匹配的字符标记为彩色，when可以是’never’，‘auto’或’always’。 -e pattern, --regexp=pattern - 制定在搜索中使用的匹配模式，多用于指定多个匹配模式的情况。 -H - 在每一行前面打印出匹配的文件名，在多个文件的情况下这个是默认选项。 -h - 在多个文件的情况下不打印出匹配的文件名。 -n - 打印出匹配所在行的行数。 -i, --ignore-case - 查找时忽略大小写。 -R, -r, --recursive - 递归的去查找子目录下的文件。 -v, --invert-match - 打印出不匹配的行。 -w, --word-regexp - 只匹配整个单词。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git clone --depth=1之后拉取其他分支]]></title>
    <url>%2F2018%2F09%2F25%2FGitDepthOtherBr%2F</url>
    <content type="text"><![CDATA[当项目过大时，git clone会出现超时失败，这时候我们可以只拉去最新的一次或者几次commit: 1git clone --depth=1 xxxxxx 有时候，我们总是图一时之快，而忽略了其他的问题。 你可能很快会发现，拉下来的只是默认的分支，而要想拉取其他分支代码的时候，一脸懵逼，有木有？？ 其实也很简单：123$ git remote set-branches origin &apos;remote_branch_name&apos;$ git fetch --depth 1 origin remote_branch_name$ git checkout remote_branch_name 搞定收工。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>depth</tag>
        <tag>分支</tag>
        <tag>clone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim一次复制，多次粘贴]]></title>
    <url>%2F2018%2F09%2F08%2FVimOneCopyMutablePaste%2F</url>
    <content type="text"><![CDATA[我们平常在使用Vim时候，通过viwy或者yy等复制操作之后，p操作粘贴的时候，只能粘贴一次，想要粘贴多次怎么办？ 解决方案：在使用p的是时候使用&quot;0p，这样就能无限制的一直粘贴了。 可是，为什么呢？ 因为，寄存器位置0的地方存放的就是最近复制的内容。（使用:reg可以查看寄存器存储列表） 类似的使用xxp就能粘贴相应位置的内容了。（xx标识reg列表前面的序号） 哈哈，是不是很神奇？！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>copy</tag>
        <tag>复制</tag>
        <tag>粘贴</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html/Xml中的转义字符]]></title>
    <url>%2F2018%2F08%2F29%2FCharTransferred%2F</url>
    <content type="text"><![CDATA[HTML中的转义字符 HTML中&lt;, &gt;，&amp;等有特殊含义，(前两个字符用于链接签，&amp;用于转义)，不能直接使用。使用这三个字符时，应使用它们的转义序列，如下所示： 转义字符 源字符 描述 &amp;amp; 或 &amp; &amp; 和 &amp;lt; 或 &lt; &lt; 小于号 &amp;gt; 或 &gt; &gt; 大于号 &amp;quot; “ 双引号 &amp;nbsp; 空格 &amp;copy; © 版权符 &amp;reg ® 注册符 需要说明的是： a. 转义序列各字符间不能有空格； b. 转义序列必须以”；”结束； c. 单独的&amp;不被认为是转义开始； d. 区分大小写。 XML转义字符 不合法的XML字符必须被替换为相应的实体。 下面是五个在XML文档中预定义好的实体： 转义字符 源字符 描述 &amp;amp; &amp; 和 &amp;lt; 或 &lt; &lt; 小于号 &amp;gt; 或 &gt; &gt; 大于号 &amp;quot; “ 双引号 &amp;quot; ‘ 单引号 注意: 只有”&lt;” 字符和”&amp;”字符对于XML来说是严格禁止使用的。剩下的都是合法的，为了减少出错，使用实体是一个好习惯。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>xml</tag>
        <tag>转义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS编码规范]]></title>
    <url>%2F2018%2F08%2F08%2FiOSEncoding%2F</url>
    <content type="text"><![CDATA[本文档旨在总结出一份通用的编码规范，欢迎随时探讨补充。 代码格式空格 不要在工程里使用Tab键，使用空格来进行缩进。在Xcode &gt; Preferences &gt; Text Editing将Tab和自动缩进都设置为4个空格。（Google的标准是使用两个空格来缩进，但这里还是推荐使用Xcode默认的设置。） 方法之间应该要有一个空行来帮助代码看起来清晰且有组织。 方法内的空行应该用来分离功能，但是通常不同的功能应该用新的方法来定义。 方法的书写一个典型的Objective-C函数应该是这样的： 123- (void)writeVideoFrameWithData:(NSData *)frameData timeStamp:(int)timeStamp &#123; ...&#125; 在-和(void)之间应该有一个空格，第一个大括号{的位置在函数所在行的末尾，同样应该有一个空格。 在使用{的位置都遵循Egyptian风格 (又称 K&amp;R 风格，代码段括号的开始位于一行的末尾，而不是另外起一行的风格。)，比如，控制语句 (if-else, for, switch)。 如果一个函数有特别多的参数或者名称很长，应该将其按照:来对齐分行显示： 1234567891011-(id)initWithModel:(IPCModle)model ConnectType:(IPCConnectType)connectType Resolution:(IPCResolution)resolution AuthName:(NSString *)authName Password:(NSString *)password MAC:(NSString *)mac AzIp:(NSString *)az_ip AzDns:(NSString *)az_dns Token:(NSString *)token Email:(NSString *)email Delegate:(id&lt;IPCConnectHandlerDelegate&gt;)delegate; 在分行时，如果第一段名称过短，后续名称可以以Tab的长度（4个空格）为单位进行缩进： 123456- (void)short:(GTMFoo *)theFoo longKeyword:(NSRect)theRect evenLongerKeyword:(float)theInterval error:(NSError **)theError &#123; ...&#125; 函数调用函数调用的格式和书写差不多，可以按照函数的长短来选择写在一行或者分成多行： 12345678910111213//写在一行[myObject doFooWith:arg1 name:arg2 error:arg3];//分行写，按照&apos;:&apos;对齐[myObject doFooWith:arg1 name:arg2 error:arg3];//第一段名称过短的话后续可以进行缩进[myObj short:arg1 longKeyword:arg2 evenLongerKeyword:arg3 error:arg4]; @public和@private标记符@public和@private标记符应该以一个空格来进行缩进： 1234567@interface MyClass : NSObject &#123; @public ... @private ...&#125;@end 协议（Protocols）在书写协议的时候注意用&lt;&gt;括起来的协议和类型名之间是没有空格的，比如IPCConnectHandler()&lt;IPCPreconnectorDelegate&gt;,这个规则适用所有书写协议的地方，包括函数声明、类声明、实例变量等等： 1234567@interface MyProtocoledClass : NSObject&lt;NSWindowDelegate&gt; &#123; @private id&lt;MyFancyDelegate&gt; _delegate;&#125;- (void)setDelegate:(id&lt;MyFancyDelegate&gt;)aDelegate;@end 闭包（Blocks）根据block的长度，有不同的书写规则： 较短的block可以写在一行内。 如果分行显示的话，block的右括号}应该和调用block那行代码的第一个非空字符对齐。 block内的代码采用4个空格的缩进。 如果block过于庞大，应该单独声明成一个变量来使用。 ^和(之间，^和{之间都没有空格，参数列表的右括号)和{之间有一个空格。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//较短的block写在一行内[operation setCompletionBlock:^&#123; [self onOperationDone]; &#125;];//分行书写的block，内部使用4空格缩进[operation setCompletionBlock:^&#123; [self.delegate newDataAvailable];&#125;];//使用C语言API调用的block遵循同样的书写规则dispatch_async(_fileIOQueue, ^&#123; NSString* path = [self sessionFilePath]; if (path) &#123; // ... &#125;&#125;);//较长的block关键字可以缩进后在新行书写，注意block的右括号&apos;&#125;&apos;和调用block那行代码的第一个非空字符对齐[[SessionService sharedService] loadWindowWithCompletionBlock:^(SessionWindow *window) &#123; if (window) &#123; [self windowDidLoad:window]; &#125; else &#123; [self errorLoadingWindow]; &#125; &#125;];//较长的block参数列表同样可以缩进后在新行书写[[SessionService sharedService] loadWindowWithCompletionBlock: ^(SessionWindow *window) &#123; if (window) &#123; [self windowDidLoad:window]; &#125; else &#123; [self errorLoadingWindow]; &#125; &#125;];//庞大的block应该单独定义成变量使用void (^largeBlock)(void) = ^&#123; // ...&#125;;[_operationQueue addOperationWithBlock:largeBlock];//在一个调用中使用多个block，注意到他们不是像函数那样通过&apos;:&apos;对齐的，而是同时进行了4个空格的缩进[myObject doSomethingWith:arg1 firstBlock:^(Foo *a) &#123; // ... &#125; secondBlock:^(Bar *b) &#123; // ... &#125;]; 数据结构的语法糖应该使用可读性更好的语法糖来构造NSArray，NSDictionary等数据结构，避免使用冗长的alloc,init方法。 如果构造代码写在一行，需要在括号两端留有一个空格，使得被构造的元素于与构造语法区分开来： 1234567//正确，在语法糖的&quot;[]&quot;或者&quot;&#123;&#125;&quot;两端留有空格NSArray *array = @[ [foo description], @&quot;Another String&quot;, [bar description] ];NSDictionary *dict = @&#123; NSForegroundColorAttributeName : [NSColor redColor] &#125;;//不正确，不留有空格降低了可读性NSArray* array = @[[foo description], [bar description]];NSDictionary* dict = @&#123;NSForegroundColorAttributeName: [NSColor redColor]&#125;; 如果构造代码不写在一行内，构造元素需要使用两个空格来进行缩进，右括号]或者}写在新的一行，并且与调用语法糖那行代码的第一个非空字符对齐： 1234567891011NSArray *array = @[ @&quot;This&quot;, @&quot;is&quot;, @&quot;an&quot;, @&quot;array&quot;];NSDictionary *dictionary = @&#123; NSFontAttributeName : [NSFont fontWithName:@&quot;Helvetica-Bold&quot; size:12], NSForegroundColorAttributeName : fontColor&#125;; 构造字典时，字典的Key和Value与中间的冒号:都要留有一个空格，多行书写时，也可以将Value对齐： 123456789101112131415161718192021222324252627//正确，冒号&apos;:&apos;前后留有一个空格NSDictionary *option1 = @&#123; NSFontAttributeName : [NSFont fontWithName:@&quot;Helvetica-Bold&quot; size:12], NSForegroundColorAttributeName : fontColor&#125;;//正确，按照Value来对齐NSDictionary *option2 = @&#123; NSFontAttributeName : [NSFont fontWithName:@&quot;Arial&quot; size:12], NSForegroundColorAttributeName : fontColor&#125;;//错误，冒号前应该有一个空格NSDictionary *wrong = @&#123; AKey: @&quot;b&quot;, BLongerKey: @&quot;c&quot;,&#125;;//错误，每一个元素要么单独成为一行，要么全部写在一行内NSDictionary *alsoWrong= @&#123; AKey : @&quot;a&quot;, BLongerKey : @&quot;b&quot; &#125;;//错误，在冒号前只能有一个空格，冒号后才可以考虑按照Value对齐NSDictionary *stillWrong = @&#123; AKey : @&quot;b&quot;, BLongerKey : @&quot;c&quot;,&#125;; 命名规范基本原则 清晰 命名应该尽可能的清晰和简洁，但在Objective-C中，清晰比简洁更重要。由于Xcode强大的自动补全功能，我们不必担心名称过长的问题。 1234567891011//清晰insertObject:atIndex://不清晰，insert的对象类型和at的位置属性没有说明insert:at://清晰removeObjectAtIndex://不清晰，remove的对象类型没有说明，参数的作用没有说明remove: 不要使用单词的简写，拼写出完整的单词： 1234567//清晰destinationSelectionsetBackgroundColor://不清晰，不要使用简写destSelsetBkgdColor: 然而，有部分单词简写在Objective-C编码过程中是非常常用的，以至于成为了一种规范，这些简写可以在代码中直接使用，下面列举了部分： 12345678910alloc == Allocate max == Maximumalt == Alternate min == Minimumapp == Application msg == Messagecalc == Calculate nib == Interface Builder archivedealloc == Deallocate pboard == Pasteboardfunc == Function rect == Rectanglehoriz == Horizontal Rep == Representation (used in class name such as NSBitmapImageRep).info == Information temp == Temporaryinit == Initialize vert == Verticalint == Integer 命名方法或者函数时要避免歧义 12345//有歧义，是返回sendPort还是send一个Port？sendPort//有歧义，是返回一个名字属性的值还是display一个name的动作？displayName 一致性 整个工程的命名风格要保持一致性，最好和苹果SDK的代码保持统一。不同类中完成相似功能的方法应该叫一样的名字，比如我们总是用count来返回集合的个数，不能在A类中使用count而在B类中使用getNumber。 使用前缀 如果代码需要打包成Framework给别的工程使用，或者工程项目非常庞大，需要拆分成不同的模块，使用命名前缀是非常有用的。 前缀由大写的字母缩写组成，比如Cocoa中NS前缀代表Founation框架中的类，IB则代表Interface Builder框架。 可以在为类、协议、函数、常量以及typedef宏命名的时候使用前缀，但注意不要为成员变量或者方法使用前缀，因为他们本身就包含在类的命名空间内。 命名前缀的时候不要和苹果SDK框架冲突。 命名类和协议(Class &amp; Protocol)类名以大写字母开头，应该包含一个名词来表示它代表的对象类型，同时可以加上必要的前缀，比如NSString, NSDate, NSScanner, NSApplication等等。 而协议名称应该清晰地表示它所执行的行为，而且要和类名区别开来，所以通常使用ing词尾来命名一个协议，比如NSCopying,NSLocking。 有些协议本身包含了很多不相关的功能，主要用来为某一特定类服务，这时候可以直接用类名来命名这个协议，比如NSObject协议，它包含了id对象在生存周期内的一系列方法。 命名头文件（Headers）源码的头文件名应该清晰地暗示它的功能和包含的内容： 如果头文件内只定义了单个类或者协议，直接用类名或者协议名来命名头文件，比如NSLocale.h定义了NSLocale类。 如果头文件内定义了一系列的类、协议、类别，使用其中最主要的类名来命名头文件，比如NSString.h定义了NSString和NSMutableString。 每一个Framework都应该有一个和框架同名的头文件，包含了框架中所有公共类头文件的引用，比如Foundation.h Framework中有时候会实现在别的框架中类的类别扩展，这样的文件通常使用被扩展的框架名+Additions的方式来命名，比如NSBundleAdditions.h。 命名方法（Methods）Objective-C的方法名通常都比较长，这是为了让程序有更好地可读性，按苹果的说法“好的方法名应当可以以一个句子的形式朗读出来”。 方法一般以小写字母打头，每一个后续的单词首字母大写，方法名中不应该有标点符号（包括下划线），有两个例外： 可以用一些通用的大写字母缩写打头方法，比如PDF,TIFF等。 可以用带下划线的前缀来命名私有方法或者类别中的方法。 如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用do，does这种多余的关键字，动词本身的暗示就足够了： 123//动词打头的方法表示让对象执行一个动作- (void)invokeWithTarget:(id)target;- (void)selectTabViewItem:(NSTabViewItem *)tabViewItem; 如果方法是为了获取对象的一个属性值，直接用属性名称来命名这个方法，注意不要添加get或者其他的动词前缀： 123456//正确，使用属性名来命名方法- (NSSize)cellSize;//错误，添加了多余的动词前缀- (NSSize)calcCellSize;- (NSSize)getCellSize; 对于有多个参数的方法，务必在每一个参数前都添加关键词，关键词应当清晰说明参数的作用： 1234567891011//正确，保证每个参数都有关键词修饰- (void)sendAction:(SEL)aSelector toObject:(id)anObject forAllCells:(BOOL)flag;//错误，遗漏关键词- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;//正确- (id)viewWithTag:(NSInteger)aTag;//错误，关键词的作用不清晰- (id)taggedView:(int)aTag; 不要用and来连接两个参数，通常and用来表示方法执行了两个相对独立的操作（从设计上来说，这时候应该拆分成两个独立的方法）： 12345//错误，不要使用&quot;and&quot;来连接参数- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;//正确，使用&quot;and&quot;来表示两个相对独立的操作- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag; 方法的参数命名也有一些需要注意的地方: 和方法名类似，参数的第一个字母小写，后面的每一个单词首字母大写 不要再方法名中使用类似pointer,ptr这样的字眼去表示指针，参数本身的类型足以说明 不要使用只有一两个字母的参数名 不要使用简写，拼出完整的单词 下面列举了一些常用参数名： 12345678910111213141516...action:(SEL)aSelector...alignment:(int)mode...atIndex:(int)index...content:(NSRect)aRect...doubleValue:(double)aDouble...floatValue:(float)aFloat...font:(NSFont *)fontObj...frame:(NSRect)frameRect...intValue:(int)anInt...keyEquivalent:(NSString *)charCode...length:(int)numBytes...point:(NSPoint)aPoint...stringValue:(NSString *)aString...tag:(int)anInt...target:(id)anObject...title:(NSString *)aString 存取方法（Accessor Methods）存取方法是指用来获取和设置类属性值的方法，属性的不同类型，对应着不同的存取方法规范： 1234567891011121314151617181920//属性是一个名词时的存取方法范式- (type)noun;- (void)setNoun:(type)aNoun;//栗子- (NSString *)title;- (void)setTitle:(NSString *)aTitle;//属性是一个形容词时存取方法的范式- (BOOL)isAdjective;- (void)setAdjective:(BOOL)flag;//栗子- (BOOL)isEditable;- (void)setEditable:(BOOL)flag;//属性是一个动词时存取方法的范式- (BOOL)verbObject;- (void)setVerbObject:(BOOL)flag;//栗子- (BOOL)showsAlpha;- (void)setShowsAlpha:(BOOL)flag; 命名存取方法时不要将动词转化为被动形式来使用： 1234567//正确- (void)setAcceptsGlyphInfo:(BOOL)flag;- (BOOL)acceptsGlyphInfo;//错误，不要使用动词的被动形式- (void)setGlyphInfoAccepted:(BOOL)flag;- (BOOL)glyphInfoAccepted; 可以使用can,should,will等词来协助表达存取方法的意思，但不要使用do,和does： 123456789//正确- (void)setCanHide:(BOOL)flag;- (BOOL)canHide;- (void)setShouldCloseDocument:(BOOL)flag;- (BOOL)shouldCloseDocument;//错误，不要使用&quot;do&quot;或者&quot;does&quot;- (void)setDoesAcceptGlyphInfo:(BOOL)flag;- (BOOL)doesAcceptGlyphInfo; 为什么Objective-C中不适用get前缀来表示属性获取方法？因为get在Objective-C中通常只用来表示从函数指针返回值的函数： 12//三个参数都是作为函数的返回值来使用的，这样的函数名可以使用&quot;get&quot;前缀- (void)getLineDash:(float *)pattern count:(int *)count phase:(float *)phase; 命名委托（Delegate）当特定的事件发生时，对象会触发它注册的委托方法。委托是Objective-C中常用的传递消息的方式。委托有它固定的命名范式。 一个委托方法的第一个参数是触发它的对象，第一个关键词是触发对象的类名，除非委托方法只有一个名为sender的参数： 123456//第一个关键词为触发委托的类名- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(int)row;- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;//当只有一个&quot;sender&quot;参数时可以省略类名- (BOOL)applicationOpenUntitledFile:(NSApplication *)sender; 根据委托方法触发的时机和目的，使用should,will,did等关键词 12345- (void)browserDidScroll:(NSBrowser *)sender;- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window;、- (BOOL)windowShouldClose:(id)sender; 集合操作类方法（Collection Methods）有些对象管理着一系列其它对象或者元素的集合，需要使用类似“增删查改”的方法来对集合进行操作，这些方法的命名范式一般为： 123456789//集合操作范式- (void)addElement:(elementType)anObj;- (void)removeElement:(elementType)anObj;- (NSArray *)elements;//栗子- (void)addLayoutManager:(NSLayoutManager *)obj;- (void)removeLayoutManager:(NSLayoutManager *)obj;- (NSArray *)layoutManagers; 注意，如果返回的集合是无序的，使用NSSet来代替NSArray。如果需要将元素插入到特定的位置，使用类似于这样的命名： 12- (void)insertLayoutManager:(NSLayoutManager *)obj atIndex:(int)index;- (void)removeLayoutManagerAtIndex:(int)index; 如果管理的集合元素中有指向管理对象的指针，要设置成weak类型以防止引用循环。 下面是SDK中NSWindow类的集合操作方法： 12345- (void)addChildWindow:(NSWindow *)childWin ordered:(NSWindowOrderingMode)place;- (void)removeChildWindow:(NSWindow *)childWin;- (NSArray *)childWindows;- (NSWindow *)parentWindow;- (void)setParentWindow:(NSWindow *)window; 命名函数（Functions）在很多场合仍然需要用到函数，比如说如果一个对象是一个单例，那么应该使用函数来代替类方法执行相关操作。 函数的命名和方法有一些不同，主要是： 函数名称一般带有缩写前缀，表示方法所在的框架。 前缀后的单词以“驼峰”表示法显示，第一个单词首字母大写。 函数名的第一个单词通常是一个动词，表示方法执行的操作： 12NSHighlightRectNSDeallocateObject 如果函数返回其参数的某个属性，省略动词： 12unsigned int NSEventMaskFromType(NSEventType type)float NSHeight(NSRect aRect) 如果函数通过指针参数来返回值，需要在函数名中使用Get： 1const char *NSGetSizeAndAlignment(const char *typePtr, unsigned int *sizep, unsigned int *alignp) 函数的返回类型是BOOL时的命名： 1BOOL NSDecimalIsNotANumber(const NSDecimal *decimal) 命名属性和实例变量（Properties&amp;Instance Variables）属性和对象的存取方法相关联，属性的第一个字母小写，后续单词首字母大写，不必添加前缀。属性按功能命名成名词或者动词： 12345//名词属性@property (strong) NSString *title;//动词属性@property (assign) BOOL showsAlpha; 属性也可以命名成形容词，这时候通常会指定一个带有is前缀的get方法来提高可读性： 1@property (assign, getter=isEditable) BOOL editable; 命名实例变量，在变量名前加上_前缀（有些有历史的代码会将_放在后面），其它和命名属性一样： 123@implementation MyClass &#123; BOOL _showsTitle;&#125; 一般来说，类需要对使用者隐藏数据存储的细节，所以不要将实例方法定义成公共可访问的接口，可以使用@private，@protected前缀。 按苹果的说法，不建议在除了init和dealloc方法以外的地方直接访问实例变量，但很多人认为直接访问会让代码更加清晰可读，只在需要计算或者执行操作的时候才使用存取方法访问，我就是这种习惯，所以这里不作要求。 命名常量（Constants）如果要定义一组相关的常量，尽量使用枚举类型（enumerations），枚举类型的命名规则和函数的命名规则相同。建议使用 NS_ENUM 和 NS_OPTIONS 宏来定义枚举类型，参见官方的 Adopting Modern Objective-C 一文： 1234567//定义一个枚举typedef NS_ENUM(NSInteger, NSMatrixMode) &#123; NSRadioModeMatrix, NSHighlightModeMatrix, NSListModeMatrix, NSTrackModeMatrix&#125;; 定义bit map： 1234567typedef NS_OPTIONS(NSUInteger, NSWindowMask) &#123; NSBorderlessWindowMask = 0, NSTitledWindowMask = 1 &lt;&lt; 0, NSClosableWindowMask = 1 &lt;&lt; 1, NSMiniaturizableWindowMask = 1 &lt;&lt; 2, NSResizableWindowMask = 1 &lt;&lt; 3&#125;; 使用const定义浮点型或者单个的整数型常量，如果要定义一组相关的整数常量，应该优先使用枚举。常量的命名规范和函数相同： 1const float NSLightGray; 不要使用#define宏来定义常量，如果是整型常量，尽量使用枚举，浮点型常量，使用const定义。#define通常用来给编译器决定是否编译某块代码，比如常用的： 1#ifdef DEBUG 注意到一般由编译器定义的宏会在前后都有一个__，比如__MACH__。 命名通知（Notifications）通知常用于在模块间传递消息，所以通知要尽可能地表示出发生的事件，通知的命名范式是： 1[触发通知的类名] + [Did | Will] + [动作] + Notification 栗子： 1234NSApplicationDidBecomeActiveNotificationNSWindowDidMiniaturizeNotificationNSTextViewDidChangeSelectionNotificationNSColorPanelColorDidChangeNotification 命名类别（Categories）虽然我们知道这样写很丑, 但是我们应该要在我们的 category 方法前加上自己的小写前缀以及下划线，比如- (id)zoc_myCategoryMethod。 这种实践同样被苹果推荐。 一个好的实践是在 category 名中使用前缀。 例子 123@interface NSDate (ZOCTimeExtensions)- (NSString *)zoc_timeAgoShort;@end 注释读没有注释代码的痛苦你我都体会过，好的注释不仅能让人轻松读懂你的程序，还能提升代码的逼格。注意注释是为了让别人看懂，而不是仅仅你自己。 文件注释每一个文件都必须写文件注释，文件注释通常包含 文件所在模块 作者信息 历史版本信息 版权信息 文件包含的内容，作用 一段良好文件注释的栗子： 1234567891011121314151617181920212223242526272829303132/******************************************************************************* Copyright (C), 2011-2013, Andrew Min Chang File name: AMCCommonLib.h Author: Andrew Chang (Zhang Min) E-mail: LaplaceZhang@126.com Description: This file provide some covenient tool in calling library tools. One can easily include library headers he wants by declaring the corresponding macros. I hope this file is not only a header, but also a useful Linux library note. History: 2012-??-??: On about come date around middle of Year 2012, file created as &quot;commonLib.h&quot; 2012-08-20: Add shared memory library; add message queue. 2012-08-21: Add socket library (local) 2012-08-22: Add math library 2012-08-23: Add socket library (internet) 2012-08-24: Add daemon function 2012-10-10: Change file name as &quot;AMCCommonLib.h&quot; 2012-12-04: Add UDP support in AMC socket library 2013-01-07: Add basic data type such as &quot;sint8_t&quot; 2013-01-18: Add CFG_LIB_STR_NUM. 2013-01-22: Add CFG_LIB_TIMER. 2013-01-22: Remove CFG_LIB_DATA_TYPE because there is already AMCDataTypes.h Copyright information: This file was intended to be under GPL protocol. However, I may use this library in my work as I am an employee. And my company may require me to keep it secret. Therefore, this file is neither open source nor under GPL control. ********************************************************************************/ 文件注释的格式通常不作要求，能清晰易读就可以了，但在整个工程中风格要统一。 代码注释好的代码应该是“自解释”（self-documenting）的，但仍然需要详细的注释来说明参数的意义、返回值、功能以及可能的副作用。 方法、函数、类、协议、类别的定义都需要注释，推荐采用Apple的标准注释风格，好处是可以在引用的地方alt+点击自动弹出注释，非常方便。 有很多可以自动生成注释格式的插件，推荐使用系统自带方法注释功能（Cmd + Alt + /）： 一些良好的注释： 1234567891011121314151617181920212223242526272829/** * Create a new preconnector to replace the old one with given mac address. * NOTICE: We DO NOT stop the old preconnector, so handle it by yourself. * * @param type Connect type the preconnector use. * @param macAddress Preconnector&apos;s mac address. */- (void)refreshConnectorWithConnectType:(IPCConnectType)type Mac:(NSString *)macAddress;/** * Stop current preconnecting when application is going to background. */-(void)stopRunning;/** * Get the COPY of cloud device with a given mac address. * * @param macAddress Mac address of the device. * * @return Instance of IPCCloudDevice. */-(IPCCloudDevice *)getCloudDeviceWithMac:(NSString *)macAddress;// A delegate for NSApplication to handle notifications about app// launch and shutdown. Owned by the main app controller.@interface MyAppDelegate : NSObject &#123; ...&#125;@end 协议、委托的注释要明确说明其被触发的条件： 12/** Delegate - Sent when failed to init connection, like p2p failed. */-(void)initConnectionDidFailed:(IPCConnectHandler *)handler; 如果在注释中要引用参数名或者方法函数名，使用||将参数或者方法括起来以避免歧义： 123// Sometimes we need |count| to be less than zero.// Remember to call |StringWithoutSpaces(&quot;foo bar baz&quot;)| 定义在头文件里的接口方法、属性必须要有注释！ 编码风格每个人都有自己的编码风格，这里总结了一些比较好的Cocoa编程风格和注意点。 不要使用尤达表达式尤达表达式是指，拿一个常量去和变量比较而不是拿变量去和常量比较。它就像是在表达 “蓝色是不是天空的颜色” 或者 “高个是不是这个男人的属性” 而不是 “天空是不是蓝的” 或者 “这个男人是不是高个子的” 推荐: 1if ([myValue isEqual:@42]) &#123; ... 不推荐: 1if ([@42 isEqual:myValue]) &#123; ... 黄金大道在使用条件语句编程时，代码的左边距应该是一条“黄金”或者“快乐”的大道。 也就是说，不要嵌套 if 语句。使用多个 return 可以避免增加循环的复杂度，并提高代码的可读性。因为方法的重要部分没有嵌套在分支里面，并且你可以很清楚地找到相关的代码。 推荐: 1234567- (void)someMethod &#123; if (![someOther boolValue]) &#123; return; &#125; //Do something important&#125; 不推荐: 12345- (void)someMethod &#123; if ([someOther boolValue]) &#123; //Do something important &#125;&#125; 复杂的表达式当你有一个复杂的 if 子句的时候，你应该把它们提取出来赋给一个 BOOL 变量，这样可以让逻辑更清楚，而且让每个子句的意义体现出来。 1234567BOOL nameContainsSwift = [sessionName containsString:@&quot;Swift&quot;];BOOL isCurrentYear = [sessionDateCompontents year] == 2014;BOOL isSwiftSession = nameContainsSwift &amp;&amp; isCurrentYear;if (isSwiftSession) &#123; // Do something very cool&#125; 三元运算符三元运算符 ? 应该只用在它能让代码更加清楚的地方。 一个条件语句的所有的变量应该是已经被求值了的。类似 if 语句，计算多个条件子句通常会让语句更加难以理解。或者可以把它们重构到实例变量里面。 推荐: 1result = a &gt; b ? x : y; 不推荐: 1result = a &gt; b ? x = c &gt; d ? c : d : y; 当三元运算符的第二个参数（if 分支）返回和条件语句中已经检查的对象一样的对象的时候，下面的表达方式更灵巧： 推荐: 1result = object ? : [self createObject]; 不推荐: 1result = object ? object : [self createObject]; PragmaPragma Mark#pragma mark - 是一个在类内部组织代码并且帮助你分组方法实现的好办法。 我们建议使用 #pragma mark - 来分离: 不同功能组的方法 protocols 的实现 对父类方法的重写 12345678910111213141516171819202122232425262728293031323334353637- (void)dealloc &#123; /* ... */ &#125;- (instancetype)init &#123; /* ... */ &#125;#pragma mark - View Lifecycle （View 的生命周期）- (void)viewDidLoad &#123; /* ... */ &#125;- (void)viewWillAppear:(BOOL)animated &#123; /* ... */ &#125;- (void)didReceiveMemoryWarning &#123; /* ... */ &#125;#pragma mark - Custom Accessors （自定义访问器）- (void)setCustomProperty:(id)value &#123; /* ... */ &#125;- (id)customProperty &#123; /* ... */ &#125;#pragma mark - IBActions - (IBAction)submitData:(id)sender &#123; /* ... */ &#125;#pragma mark - Public - (void)publicMethod &#123; /* ... */ &#125;#pragma mark - Private- (void)zoc_privateMethod &#123; /* ... */ &#125;#pragma mark - UITableViewDataSource- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; /* ... */ &#125;#pragma mark - ZOCSuperclass// ... 重载来自 ZOCSuperclass 的方法#pragma mark - NSObject- (NSString *)description &#123; /* ... */ &#125; 上面的标记能明显分离和组织代码。你还可以用 cmd+Click 来快速跳转到符号定义地方。 但是小心，即使 paragma mark 是一门手艺，但是它不是让你类里面方法数量增加的一个理由：类里面有太多方法说明类做了太多事情，需要考虑重构了。 关于 pragma在 http://raptureinvenice.com/pragmas-arent-just-for-marks 有很好的关于 pragma 的讨论了，在这边我们再做部分说明。 大多数 iOS 开发者平时并没有和很多编译器选项打交道。一些选项是对控制严格检查（或者不检查）你的代码或者错误的。有时候，你想要用 pragma 直接产生一个异常，临时打断编译器的行为。 当你使用ARC的时候，编译器帮你插入了内存管理相关的调用。但是这样可能产生一些烦人的事情。比如你使用 NSSelectorFromString 来动态地产生一个 selector 调用的时候，ARC不知道这个方法是哪个并且不知道应该用那种内存管理方法，你会被提示 performSelector may cause a leak because its selector is unknown（执行 selector 可能导致泄漏，因为这个 selector 是未知的）. 如果你知道你的代码不会导致内存泄露，你可以通过加入这些代码忽略这些警告 123456#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;[myObj performSelector:mySelector withObject:name];#pragma clang diagnostic pop 注意我们是如何在相关代码上下文中用 pragma 停用 -Warc-performSelector-leaks 检查的。这确保我们没有全局禁用。如果全局禁用，可能会导致错误。 全部的选项可以在 The Clang User’s Manual 找到并且学习。 忽略没用使用变量的编译警告告诉你申明的变量它将不会被使用，这种做法很有用。大多数情况下，你希望移除这些引用来（稍微地）提高性能，但是有时候你希望保留它们。为什么？或许它们以后有用，或者有些特性只是暂时移除。无论如何，一个消除这些警告的好方法是用相关语句进行注解，使用 #pragma unused(): 1234567- (NSInteger)giveMeFive&#123; NSString *foo; #pragma unused (foo) return 5;&#125; 现在你的代码不用任何编译警告了。注意你的 pragma 需要标记到问题代码之下。 明确编译器警告和错误编译器是一个机器人，它会标记你代码中被 Clang 规则定义为错误的地方。但是，你总是比 Clang 更聪明。通常，你会发现一些讨厌的代码会导致这个问题，但是暂时却解决不了。你可以这样明确一个错误： 12345- (NSInteger)divide:(NSInteger)dividend by:(NSInteger)divisor&#123; #error Whoa, buddy, you need to check for zero here! return (dividend / divisor);&#125; 类似的，你可以这样标明一个警告 12345678910- (float)divide:(float)dividend by:(float)divisor&#123; #warning Dude, don&apos;t compare floating point numbers like this! if (divisor != 0.0) &#123; return (dividend / divisor); &#125; else &#123; return NAN; &#125;&#125; NSCache 构建缓存时选用NSCache 而非NSDictionary 如果我们缓存使用得当，那么应用程序的响应速度就会提高。只有那种“重新计算起来很费事的数据，才值得放入缓存”，比如那些需要从网络获取或从磁盘读取的数据。 在构建缓存的时候很多人习惯用NSDictionary或者NSMutableDictionary，但是作者建议大家使用NSCache，它作为管理缓存的类，有很多特点要优于字典，因为它本来就是为了管理缓存而设计的。 NSCache优于NSDictionary的几点： 当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。 NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。 NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。 不要使用new方法尽管很多时候能用new代替alloc init方法，但这可能会导致调试内存时出现不可预料的问题。Cocoa的规范就是使用alloc init方法，使用new会让一些读者困惑。 #import和#include#import是Cocoa中常用的引用头文件的方式，它能自动防止重复引用文件，什么时候使用#import，什么时候使用#include呢？ 当引用的是一个Objective-C或者Objective-C++的头文件时，使用#import 当引用的是一个C或者C++的头文件时，使用#include，这时必须要保证被引用的文件提供了保护域（#define guard）。 栗子： 1234#import &lt;Cocoa/Cocoa.h&gt;#include &lt;CoreFoundation/CoreFoundation.h&gt;#import &quot;GTMFoo.h&quot;#include &quot;base/basictypes.h&quot; 为什么不全部使用#import呢？主要是为了保证代码在不同平台间共享时不出现问题。 引用框架的根头文件上面提到过，每一个框架都会有一个和框架同名的头文件，它包含了框架内接口的所有引用，在使用框架的时候，应该直接引用这个根头文件，而不是其它子模块的头文件，即使是你只用到了其中的一小部分，编译器会自动完成优化的。 123456//正确，引用根头文件#import &lt;Foundation/Foundation.h&gt;//错误，不要单独引用框架内的其它头文件#import &lt;Foundation/NSArray.h&gt;#import &lt;Foundation/NSString.h&gt; BOOL的使用BOOL在Objective-C中被定义为signed char类型，这意味着一个BOOL类型的变量不仅仅可以表示YES(1)和NO(0)两个值，所以永远不要将BOOL类型变量直接和YES比较： 123456789//错误，无法确定|great|的值是否是YES(1)，不要将BOOL值直接与YES比较BOOL great = [foo isGreat];if (great == YES) // ...be great!//正确BOOL great = [foo isGreat];if (great) // ...be great! 同样的，也不要将其它类型的值作为BOOL来返回，这种情况下，BOOL变量只会取值的最后一个字节来赋值，这样很可能会取到0（NO）。但是，一些逻辑操作符比如&amp;&amp;,||,!的返回是可以直接赋给BOOL的： 1234567891011121314151617181920//错误，不要将其它类型转化为BOOL返回- (BOOL)isBold &#123; return [self fontTraits] &amp; NSFontBoldTrait;&#125;- (BOOL)isValid &#123; return [self stringValue];&#125;//正确- (BOOL)isBold &#123; return ([self fontTraits] &amp; NSFontBoldTrait) ? YES : NO;&#125;//正确，逻辑操作符可以直接转化为BOOL- (BOOL)isValid &#123; return [self stringValue] != nil;&#125;- (BOOL)isEnabled &#123; return [self isValid] &amp;&amp; [self isBold];&#125; 另外BOOL类型可以和_Bool,bool相互转化，但是不能和Boolean转化。 在init和dealloc中不要用存取方法访问实例变量当init``dealloc方法被执行时，类的运行时环境不是处于正常状态的，使用存取方法访问变量可能会导致不可预料的结果，因此应当在这两个方法内直接访问实例变量。 12345678910111213141516171819202122232425//正确，直接访问实例变量- (instancetype)init &#123; self = [super init]; if (self) &#123; _bar = [[NSMutableString alloc] init]; &#125; return self;&#125;- (void)dealloc &#123; [_bar release]; [super dealloc];&#125;//错误，不要通过存取方法访问- (instancetype)init &#123; self = [super init]; if (self) &#123; self.bar = [NSMutableString string]; &#125; return self;&#125;- (void)dealloc &#123; self.bar = nil; [super dealloc];&#125; 保证NSString在赋值时被复制NSString非常常用，在它被传递或者赋值时应当保证是以复制（copy）的方式进行的，这样可以防止在不知情的情况下String的值被其它对象修改。 123- (void)setFoo:(NSString *)aFoo &#123; _foo = [aFoo copy];&#125; 使用NSNumber的语法糖使用带有@符号的语法糖来生成NSNumber对象能使代码更简洁： 123456NSNumber *fortyTwo = @42;NSNumber *piOverTwo = @(M_PI / 2);enum &#123; kMyEnum = 2;&#125;;NSNumber *myEnum = @(kMyEnum); nil检查因为在Objective-C中向nil对象发送命令是不会抛出异常或者导致崩溃的，只是完全的“什么都不干”，所以，只在程序中使用nil来做逻辑上的检查。 另外，不要使用诸如nil == Object或者Object == nil的形式来判断。 123456789//正确，直接判断if (!objc) &#123; ... &#125;//错误，不要使用nil == Object的形式if (nil == objc) &#123; ... &#125; Delegate要使用弱引用一个类的Delegate对象通常还引用着类本身，这样很容易造成引用循环的问题，所以类的Delegate属性要设置为弱引用。 12/** delegate */@property (nonatomic, weak) id &lt;IPCConnectHandlerDelegate&gt; delegate; 单例使用dispatch_once来生成单例，建议单例类方法名命名保持一致。 推荐这样写： 123456789+ (instancetype)sharedInstance &#123; static id sharedInstance = nil; static dispatch_once_t onceToken = 0; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance; &#125; Block循环引用问题当使用代码块和异步分发的时候，要注意避免引用循环。 总是使用 weak 来引用对象，避免引用循环。（译者注：这里更为优雅的方式是采用影子变量@weakify/@strongify 这里有更为详细的说明） 此外，把持有 block 的属性设置为 nil (比如 self.completionBlock = nil) 是一个好的实践。它会打破 block 捕获的作用域带来的引用循环。 例子: 1234__weak __typeof(self) weakSelf = self;[self executeBlock:^(NSData *data, NSError *error) &#123; [weakSelf doSomethingWithData:data];&#125;]; 不要这样: 123[self executeBlock:^(NSData *data, NSError *error) &#123; [self doSomethingWithData:data];&#125;]; 多个语句的例子: 12345678__weak __typeof(self)weakSelf = self;[self executeBlock:^(NSData *data, NSError *error) &#123; __strong __typeof(weakSelf) strongSelf = weakSelf; if (strongSelf) &#123; [strongSelf doSomethingWithData:data]; [strongSelf doSomethingWithData:data]; &#125;&#125;]; 不要这样: 12345__weak __typeof(self)weakSelf = self;[self executeBlock:^(NSData *data, NSError *error) &#123; [weakSelf doSomethingWithData:data]; [weakSelf doSomethingWithData:data];&#125;]; 你应该把这两行代码作为 snippet 加到 Xcode 里面并且总是这样使用它们。 12__weak __typeof(self)weakSelf = self;__strong __typeof(weakSelf)strongSelf = weakSelf; 这里我们来讨论下 block 里面的 self 的 __weak 和 __strong 限定词的一些微妙的地方。简而言之，我们可以参考 self 在 block 里面的三种不同情况。 直接在 block 里面使用关键词 self 在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用 在 block 外定义一个 __weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 __strong的引用。 方案 1. 直接在 block 里面使用关键词 self 如果我们直接在 block 里面用 self 关键字，对象会在 block 的定义时候被 retain，（实际上 block 是 copied但是为了简单我们可以忽略这个）。 一个 const 的对 self 的引用在 block 里面有自己的位置并且它会影响对象的引用计数。 如果这个block被其他的类使用并且(或者)彼此间传来传去，我们可能想要在 block 中保留 self，就像其他在 block 中使用的对象一样. 因为他们是block执行所需要的. 12345678dispatch_block_t completionBlock = ^&#123; NSLog(@&quot;%@&quot;, self);&#125;MyViewController *myController = [[MyViewController alloc] init...];[self presentViewController:myController animated:YES completion:completionHandler]; 没啥大不了。但是如果通过一个属性中的 self 保留 了这个 block（就像下面的例程一样）,对象( self )保留了 block 会怎么样呢？ 12345678self.completionHandler = ^&#123; NSLog(@&quot;%@&quot;, self);&#125;MyViewController *myController = [[MyViewController alloc] init...];[self presentViewController:myController animated:YES completion:self.completionHandler]; 这就是有名的 retain cycle, 并且我们通常应该避免它。这种情况下我们收到 CLANG 的警告： 1Capturing &apos;self&apos; strongly in this block is likely to lead to a retain cycle （在 block 里面发现了 `self` 的强引用，可能会导致循环引用） 所以 __weak 就有用武之地了。 方案 2. 在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用 这样会避免循坏引用，也是通常情况下我们的block作为类的属性被self retain 的时候会做的。 123456789__weak typeof(self) weakSelf = self;self.completionHandler = ^&#123; NSLog(@&quot;%@&quot;, weakSelf);&#125;;MyViewController *myController = [[MyViewController alloc] init...];[self presentViewController:myController animated:YES completion:self.completionHandler]; 这个情况下 block 没有 retain 对象并且对象在属性里面 retain 了 block 。所以这样我们能保证了安全的访问 self。 不过糟糕的是，它可能被设置成 nil 的。问题是：如何让 self 在 block 里面安全地被销毁。 考虑这么个情况：block 作为属性(property)赋值的结果，从一个对象被复制到另一个对象(如 myController)，在这个复制的 block 执行之前，前者（即之前的那个对象）已经被解除分配。 下面的更有意思。 方案 3. 在 block 外定义一个 weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个strong 的引用 你可能会想，首先，这是避免 retain cycle 警告的一个技巧。这不是重点，这个 self 的强引用是在block 执行时 被创建的，但是否使用 self 在 block 定义时就已经定下来了， 因此self (在block执行时) 会被 retain。 Apple 文档 中表示 “为了 non-trivial cycles ，你应该这样” ： 1234567891011121314MyViewController *myController = [[MyViewController alloc] init...];// ...MyViewController * __weak weakMyController = myController;myController.completionHandler = ^(NSInteger result) &#123; MyViewController *strongMyController = weakMyController; if (strongMyController) &#123; // ... [strongMyController dismissViewControllerAnimated:YES completion:nil]; // ... &#125; else &#123; // Probably nothing... &#125;&#125;; 首先，我觉得这个例子看起来是错误的。如果 block 本身在 completionHandler 属性中被 retain 了，那么 self 如何被 delloc 和在 block 之外赋值为 nil 呢? completionHandler 属性可以被声明为 assign 或者 unsafe_unretained 的，来允许对象在 block 被传递之后被销毁。 我不能理解这样做的理由，如果其他对象需要这个对象（self），block 被传递的时候应该 retain 对象，所以 block 应该不被作为属性存储。这种情况下不应该用 __weak/__strong 总之，其他情况下，希望 weakSelf 变成 nil 的话，就像第二种情况解释那么写（在 block 之外定义一个弱应用并且在 block 里面使用）。 还有，Apple的 “trivial block” 是什么呢。我们的理解是 trivial block 是一个不被传送的 block ，它在一个良好定义和控制的作用域里面，weak 修饰只是为了避免循环引用。 虽然有 Kazuki Sakamoto 和 Tomohiko Furumoto) 讨论的 一 些 的 在线 参考, Matt Galloway 的 (Effective Objective-C 2.0 和 Pro Multithreading and Memory Management for iOS and OS X ，大多数开发者始终没有弄清楚概念。 在 block 内用强引用的优点是，抢占执行的时候的鲁棒性。在 block 执行的时候, 再次温故下上面的三个例子： 方案 1. 直接在 block 里面使用关键词 self 如果 block 被属性 retain，self 和 block 之间会有一个循环引用并且它们不会再被释放。如果 block 被传送并且被其他的对象 copy 了，self 在每一个 copy 里面被 retain 方案 2. 在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用 不管 block 是否通过属性被 retain ，这里都不会发生循环引用。如果 block 被传递或者 copy 了，在执行的时候，weakSelf 可能已经变成 nil。 block 的执行可以抢占，而且对 weakSelf 指针的调用时序不同可以导致不同的结果(如：在一个特定的时序下 weakSelf 可能会变成 nil )。 123456__weak typeof(self) weakSelf = self;dispatch_block_t block = ^&#123; [weakSelf doSomething]; // weakSelf != nil // preemption, weakSelf turned nil [weakSelf doSomethingElse]; // weakSelf == nil&#125;; 方案 3. 在 block 外定义一个 weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个strong 的引用。 不管 block 是否通过属性被 retain ，这里也不会发生循环引用。如果 block 被传递到其他对象并且被复制了，执行的时候，weakSelf 可能被nil，因为强引用被赋值并且不会变成nil的时候，我们确保对象 在 block 调用的完整周期里面被 retain了，如果抢占发生了，随后的对 strongSelf 的执行会继续并且会产生一样的值。如果 strongSelf 的执行到 nil，那么在 block 不能正确执行前已经返回了。 12345678910111213__weak typeof(self) weakSelf = self;myObj.myBlock = ^&#123; __strong typeof(self) strongSelf = weakSelf; if (strongSelf) &#123; [strongSelf doSomething]; // strongSelf != nil // preemption, strongSelf still not nil（抢占的时候，strongSelf 还是非 nil 的) [strongSelf doSomethingElse]; // strongSelf != nil &#125; else &#123; // Probably nothing... return; &#125;&#125;; 在ARC条件中，如果尝试用 -&gt; 符号访问一个实例变量，编译器会给出非常清晰的错误信息： 1Dereferencing a __weak pointer is not allowed due to possible null value caused by race condition, assign it to a strong variable first. (对一个 __weak 指针的解引用不允许的，因为可能在竞态条件里面变成 null, 所以先把他定义成 strong 的属性) 可以用下面的代码展示 1234__weak typeof(self) weakSelf = self;myObj.myBlock = ^&#123; id localVal = weakSelf-&gt;someIVar;&#125;; 在最后 方案 1: 只能在 block 不是作为一个 property 的时候使用，否则会导致 retain cycle。 方案 2: 当 block 被声明为一个 property 的时候使用。 方案 3: 和并发执行有关。当涉及异步的服务的时候，block 可以在之后被执行，并且不会发生关于 self 是否存在的问题。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>规范</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上的那些效率神器]]></title>
    <url>%2F2018%2F07%2F16%2FArtifactsOnMac%2F</url>
    <content type="text"><![CDATA[####No.1 Alfred 点我装备 这顶神奇的魔法帽到底能干啥？这绝对可以称得上一款神器，简单的一句话概括就是——只有你想不到的，没有Alfred做不到的。 哈哈~~是不是很夸张？！ 一会儿再来下定论 在这里我只是举一个简单的栗子，通常我们遇到不懂的英文单词，基本是这么一个操作过程： copy单词 打开翻译应用（比如自带词典） 输入或粘贴查询单词 翻译应用输出查询结果 查询过后，一般都需要 Cmd+Q 退出应用（或者 Cmd+H 隐藏词典，亦或 Cmd+Tab 切换回上一个应用） 或者是下面的步骤： copy单词 手动打开浏览器 进入谷歌首页 选中输入框 输入或粘贴查询单词，然后空格并加上「翻译」两个字，然后再回车 等待浏览器展示查询结果; 而用Alfred是只需要： 选中单词 CMD+Y（假如快捷键你设置的是这个） Done！！ 那么问题来了，Alfred到底具体能做什么？默认情况下，Alfred 至少能胜任 15 项工作： 应用搜索 文件或目录搜索 文本内容搜索 标记搜索 快捷网页搜索 书签搜索 计算器 词典搜索 通讯录搜索 剪切板搜索 代码片段搜索 iTunes 管理 1Password 搜索 系统常用命令快捷操作 直接唤起指定终端并执行命令 这里做了很详细的说明。 当然，Alfred真正核心的功能在于——Workflow 。 Alfred 几乎可以做任何自动化工作流的事情（只要能用代码描述这个工作流就行），它能彻底改变了你对 Mac 的认知。 网上有很多大神们写好的workflow，可以搜一搜，然后体验体验，在我们可以自己为所欲为之前，坚定一下信心。 No.2 Things 3 点我装备一句话总结：GTD神器，简洁但不简单。 No.3 Moom 点我装备一款窗口布局的神器。支持自定义快捷键实现相应的窗口布局。 No.3 CheatSheet 点我装备一键直观查看App的快捷键列表。 说道快捷键，是的，快捷键会很大程度上提高你的效率，Mac上就自带了很多的快捷键，记住这些快捷键招式，就能立马神装出山了。具体可以参见这里。 No.4 Vim细心一些我们会发现，当前主流的IDE，或者以前曾经主流过的，或者未来即将成为主流的，总会有一套Vim相关的插件。其实，这就已经很能说明问题了。 Vim在手，天下我有的赶脚，有木有？！ Vim各类IDE的插件安装在这里就不详细阐述了，推荐几个Atom上神装吧，仅供参考： Vim Mode Plus Vim主要功能插件，不多说，究竟怎么爽，谁用谁知道。 relative-numbers 相对行数在Vim中的重要地位不言而喻了，这款插件能够直观的看出彼此的相对行数。 minimap Sublime 右侧的mini视图，对，就是这货。 activate-power-mode 这款插件绝对会让你有一种敲代码如同跳舞的动感，呃，提醒一句，注意休息眼睛。哈哈~~ 当然，Atom的插件还有很多，可以去他的官网淘出你需要的。 No.5 iTerm 点击装备iTerm2+ oh my zsh的组合，为你打造最强Mac终端便不只是梦。个性化的主题，私人订制属于自己的格调。一堆定义好的alias，省心省力，爽的飞起！ No.6 Vimium chrome下的Vim插件，让你浏览网页也能有Vim操作的快感。点击这里了解 No.7 Surfingkeys chrome下的Vim插件，Vimium的强化版本。点击这里了解 最后，放上Vim快捷键的几张图，欢迎收藏：]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>效率</tag>
        <tag>app</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上的那些个快捷键们]]></title>
    <url>%2F2018%2F07%2F11%2FShortcutsOnMac%2F</url>
    <content type="text"><![CDATA[入了Mac的坑，在为其魅力折服的同时，不免时不时的会有一些挥之不去的痛点。 其实在Mac上有一大堆的快捷键，可以让你的效率有一个质的提高。 ⌘（command）⌥（option/alt）⇧（shift）⇪（caps lock）⌃（control/ctrl）⇤/⇥(Tab) 在这里官方给出了快捷键的说明。点我直达显然，快捷键量很大，全部记住并熟练应用不太可能，可以根据自己的习惯，逐渐的形成自己的套路，然后替身自己的工作(娱乐)效率。 当然，⌘ + Q(W/O/N)、⌘ + X(C/V/F/S/A)之流就不说了，太常用，大家都知道。下面主要列举一下我自己感觉比较效率，但是又容易被忽视的快捷键：⌘ + ` 在同一个应用的各个标签页中切换。⌘ + ⇤(⇥)在打开的应用中切换到下一个最近使用的应用,按住可切换到其他应用，亦可配合触摸板或者鼠标选中某个应用⌘ + T打开新的标签⌘ + H隐藏当前应用⌘ + Alt + H隐藏除了当前应用外的其他应用⌘ + M最小化当前应用⌘ + Alt + M最小化除了当前应用外的其他应用⌘ + Shift + 3 截取整个屏幕，并保存图片到桌面⌘ + Shift + 4 自定义截图大小，按下 Space 键，可以选择窗口截图⌃ + ←(→)可以切换屏幕⌘ + ,打开偏好设置…… 类似的快捷键其实还有很多很多，根据自身的习惯取舍吧。 快捷键的初衷，其实是想让效率能够提升，是想工作(娱乐)起来更有效率。但是问题来了，快捷键记少了总感觉不够用，而想要记更多的快捷键，难免成为一种负担。 CheatSheet，一款App，一键查看所有快捷键的App。点我速度装备 其实在Mac上还要一些隐藏的或者说是并没有明说的快捷键。(Apple经常干这事儿，发现的时候总有些喜怒交加)。 在mac上，很多时候在文本输入时，总想着能有一些快捷键，能让光标快速移动，殊不知，mac本身就自带这个能力。 如：iTerm2, 终端, safari, Chrome, QQ, SourceTree, Xcode, MindNode Pro, Pages, Keynote, 便签, 邮件等，几乎有文本输入的地方似乎都是支持的~~~ 在这里我列举一下平时比较常用的快捷键以及帮助记忆的方法： 注：为与emacs教程习惯一致，Ctrl 简写成 C C - a 光标移到行首（abcde，a是开头） C - e 光标移到行尾（abcde，e是结尾） C - f 光标向文档结尾方向移（Forward首字母） C - b 光标向文档开头方向移（Back首字母） C - p 光标移向上一行（Previous首字母） C - n 光标移向下一行（Next首字母） C - l 使当前编辑的行居中（safari, qq）或清屏（iTerm2,终端） C - d 删除光标后的一个字符（Delete首字母） C - k 删除光标到行尾的内容（Kill首字母） C - y 将C-k删除的东西粘贴出来（Yank首字母） C - o 在光标后插入一个换行符 C - t 交换光标前和光标后的字符，同时光标后移（Transpose首字母） C - h 删除光标前的一个字符 Mac其实也可以很简单的输入一些特殊字符。 输入特殊符号：版权符号: ⌥ + G = ©人民币符号: ⌥ + Y = ¥商标符号: ⌥ + 2 = ™已经注册的商标: ⌥ + R = ® 数学符号：约等于: ⌥ + X = ≈度数: ⌥ + ⇧ + 8 = °除号: ⌥ + / = ÷无穷: ⌥ + 5 = ∞大于等于和小于等于: ⌥ + , 和 ⌥ + . = ≤ 和 ≥不等于: ⌥ + = = ≠圆周率: ⌥ + P = π加减: ⇧ + ⌥ + = = ±开方: ⌥ + V = √求和符号: ⌥ + W = ∑ 是不是很神奇？！]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Development cannot be enabled while your device is locked.]]></title>
    <url>%2F2018%2F05%2F16%2FDevelopmentNotEnabledWhileLocked%2F</url>
    <content type="text"><![CDATA[有时候我们真机调试的时候，会遇到这样的报错： Development cannot be enabled while your device is locked. 但是！我TM手机明明解锁了啊，指纹解的锁不是？密码解的锁不是？没感应到？换个姿势再来一次？还是不行？？ 哈哈，有同样经历的点个赞吧。 估计是有这么个不经意的瞬间，手机首次插上mac的时候，苹果给你弹了个框框，让你trust (信任)它，然后我们手欠的点了不trust (信任)，然后它生气了，不让你用了，就是上面的局面。 关键的是，它从此以后就不再弹了。。。 我TM错了，还不行么？你回来再给我弹一次啊！！ 后悔药： 设置 –&gt; 通用 –&gt; 还原 –&gt; 还原位置和隐私 按照上面的操作之后，重插，就会弹了~~~ 不用谢我~ 后遗症： 位置和隐私被重置了，之前已经设置位置和隐私的APP们，你再次进去的时候，都开始积极的弹框让你赏口饭了。 【/笑哭】🤣 这块儿官网其实是有说明的：https://support.apple.com/en-us/HT202778 划重点:]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>XCode</tag>
        <tag>locked</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[This iPhone xxx is running iOS xxx, which may not be supported by this version of Xcode.]]></title>
    <url>%2F2018%2F05%2F16%2FiosRunningNotSupported%2F</url>
    <content type="text"><![CDATA[有时候我们的iPhone紧跟apple的步伐升级最新的版本了，但是Xcode并没有及时更新到最新版本(Xcode是在很大，而且有时候是需要最新的beta版本的)，这时候真机调试的时候就会出现下面这样的问题： 报错：Could not locate device support files.This iPhone 7 (Model 1660, 1778, 1779, 1780) is running iOS 11.3 (15E216), which may not be supported by this version of Xcode. 当然，我们升级Xcode到适当的版本(iPhone是release版本，一般Xcode升级到最新的release版本，iPhone是beta版本，一般Xcode升级到最新的beta版本)，但是上面提到升级Xcode时间实在太长，急性子的我们表示等不及。 下面介绍一种不用升级Xcode就是真机调试的方法： 更新Xcode真机运行支持包 Xcode真机运行支持包path在这里：Xcode路径/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport，打开后能看到这样的界面： 支持包这里下载：链接: https://pan.baidu.com/s/1eS20QS6 密码: 5v35 之后要做的就是，需要哪一个iPhone系统的支持包，下载解压，放进去就可以了，然后插入你的手机，等Xcode解析好你的手机文件就可以真机运行了。 有时候可能不生效，重启大法重启下Xcode再试试。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>not supported</tag>
        <tag>XCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github超过100M的大文件上传]]></title>
    <url>%2F2018%2F05%2F02%2FgithubUploadFileOver100M%2F</url>
    <content type="text"><![CDATA[通常我们commit完成之后，往Github上push的时候，单个文件大小不会超过100M，所以基本不会遇到这种情况。但是，总会遇到的，当单个文件超过100M的时候，push的时候会出现下面这样的Error： remote: Resolving deltas: 100% (472/472), done.remote: error: GH001: Large files detected.You may want to try Git Large File Storage - https://git-lfs.github.com. 或者： Total 3007 (delta 664), reused 0 (delta 0)remote: error: GH001: Large files detected.remote: error: Trace: 7b7de6b9372ee392e0f3961b05ea6f33remote: error: See http://git.io/iEPt8g for more information.remote: error: File XXX/XXX/XXX is 234 MB; this exceeds GitHub‘s file size limit of 100.00 MBremote: error: File XXX/XXX/XXX is 234 MB; this exceeds GitHub‘s file size limit of 100.00 MB。 上面错误的原因很好理解就是GitHub不允许直接上传大文件（超过100M）的文件到远程仓库，若要想继续提交可以尝试使用大文件支持库：https://git-lfs.github.comLFS使用的简单步骤： 安装git - lfs到本机这里没有什么难度，根据官网安装就好。 之后就是提交大文件的顺序，下面是官网的顺序： 安装Git命令行扩展。只需要设置一次Git LFS。在项目目录下，执行以下命令： git lfs install 选择您希望Git LFS管理的文件类型（或直接编辑.gitattributes）。您可以随时配置其他文件扩展名。这一步成功后会生成一个gitattributes文件 git lfs track “ .a” –这里的 “ .a “就是你要上传的大文件的路径 添加并commit gitattributes文件 git add .gitattributes 然后再添加大文件到本地缓存区 git add demo.agit commit -m “提交.a大文件”git push 以上，按照上述的方法，第一次上传大文件基本还是会报错，而且百思不得其解~尼玛，新手入坑总是这个尿性。。 如下图： 出现上述问题，先reset 到你刚才commit的前一个commit,(意思就是撤销刚才的commit，回到起点再来一次。) 第一、二步同上，第三步的时候，先将 .gitattributes文件，单独commit，然后push，完成之后，在进行第四部(第四部add 之后 执行git lfs ls-files应该能看见东西了)。到这里应该就没问题了。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>大文件</tag>
        <tag>upload</tag>
        <tag>上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC追根溯源之Class]]></title>
    <url>%2F2017%2F11%2F12%2Foc-class%2F</url>
    <content type="text"><![CDATA[前两天碰到一面试题：12345//分辨下面res的是非BOOL res1 = [[NSObject class] isKindOfClass:[NSObject class]];BOOL res2 = [[NSObject class] isMemberOfClass:[NSObject class]];BOOL res3 = [[Sark class] isKindOfClass:[Sark class]];BOOL res4 = [[Sark class] isMemberOfClass:[Sark class]]; 在这之前，我们先了解一下相关的定义： Class 在objc.h中Class是这么定义的：12/// An opaque type that represents an Objective-C class.typedef struct objc_class *Class; objc_class又是啥呢？在runtime.h中能看见： 12345678910111213141516struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; MetaClass 上面能看到Class中有个isa参数，它是指向Class的元类（MetaClass）的指针。 注意到isa也是一个Class的结构体，也就是说MetaClass其本质也是一个Class。 我们可以把Meta Class理解为 一个Class对象的Class。简单的说： 当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类的方法列表里查找 当我们发送一个消息给一个类时，这条消息会在类的Meta Class的方法列表里查找 之后就有了下面的这张图： 能看到： 每个Class都有一个isa指针指向一个唯一的MetaClass 每一个MetaClass的isa指针都指向最上层的MetaClass（图中的NSObject的MetaClass） 最上层的MetaClass的isa指针指向自己，形成一个回路 每一个MetaClass的super class指针指向它原本Class的 Super Class的MetaClass。 最上层的MetaClass的 Super Class指向NSObject Class本身 最上层的NSObject Class的super class指向 nil 接下来我们看看objc源码中(源码可到这里下载)，在文件Object.mm内，上面相关方法的定义： 123+ (Class)class &#123; return self; &#125; 12345678- (BOOL)isKindOf:aClass&#123; Class cls; for (cls = isa; cls; cls = cls-&gt;superclass) if (cls == (Class)aClass) return YES; return NO;&#125; 1234- (BOOL)isMemberOf:aClass&#123; return isa == (Class)aClass;&#125; 那么，BOOL res1 = [[NSObject class] isKindOfClass:[NSObject class]];就可以这样对应起来理解了： [NSObject class]拿到的是self，类方法的return self,即上图紫色的NSObject(Class)。 根据上面- (BOOL)isKindOf:aClass的实现，for循环首先拿到的cls = isa,也就是cls为NSObject(Class)的MetaClass。显然这时候cls == (Class)aClass不成立。 随后，cls = cls-&gt;superclass，即cls变成了NSObject(Class)的MetaClass的superclass,根据图示可以，superclass指向的是NSObject(Class)，至此cls == (Class)aClass成立，返回YES。 同样的道理，分析BOOL res3 = [[Sark class] isKindOfClass:[Sark class]];: [Sark class]拿到的是Sark(Class),而- (BOOL)isKindOf:aClass中cls拿到的值依次是Sark Meta Class-&gt;NSObject Meta Class-&gt;NSObject Class -&gt; nil,没有相等的，return NO。 剩下两个，根据- (BOOL)isMemberOf:aClass的实现，很容易得出结论会return NO。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>OC</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac开发之监听拦截键盘输入keycode]]></title>
    <url>%2F2017%2F11%2F04%2FKeyCodes%2F</url>
    <content type="text"><![CDATA[最近在自己写一个mac上图片预览的功能，仿系统的预览，想要在预览的时候，加入快捷键，实现放大、缩小、前一张、后一张等功能。 因为总感觉，弄个鼠标啪啪的点，很土。。。 PS:不上源码你说个JJ 。。。 源码在这里 查阅相关资料，其实并不难实现，只需要在预览的window里面实现键盘的监听就好，具体如下： 12345678910111213141516//overriding -[NSWindow keyDown:].- (void)keyDown:(NSEvent *)theEvent&#123; unsigned short keycode = [theEvent keyCode]; //是否同时按下CMD int flags = 0; BOOL cmdkeydown = ([[NSApp currentEvent] modifierFlags] &amp; NSCommandKeyMask) == NSCommandKeyMask; if (cmdkeydown) &#123; flags = flags | NSCommandKeyMask; &#125; if (keycode == 49) &#123; //space //空格键去干点啥。。 &#125;&#125; 可以拿到键盘对应的 key code，这个值其实是固定的，比如上面的空格键键值是49。 那么问题来了，总不能每个键去输入一下，打个断点看看值是多少吧，太土了。。。 其实SDK里面是有相应的 enum的，位置在这里： Virtual key codes 在 Carbon framework 的这个文件里面 果断add Carbon.framework,但是并不能import &lt;HIToolbox/Events.h&gt;。很奇怪，没明白。。。 好在这样就可以：#import &lt;Carbon/Carbon.h&gt; 你就可以这样搞了：123if (keycode == kVK_Space) &#123; //space //空格键去干点啥。。 &#125; 可以在这里找到HIToolbox/Events.h文件：1/System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/Headers/Events.h 然后你就能看见下面的这些ENUM了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147/* * Summary: * Virtual keycodes * * Discussion: * These constants are the virtual keycodes defined originally in * Inside Mac Volume V, pg. V-191. They identify physical keys on a * keyboard. Those constants with "ANSI" in the name are labeled * according to the key position on an ANSI-standard US keyboard. * For example, kVK_ANSI_A indicates the virtual keycode for the key * with the letter 'A' in the US keyboard layout. Other keyboard * layouts may have the 'A' key label on a different physical key; * in this case, pressing 'A' will generate a different virtual * keycode. */ enum &#123; kVK_ANSI_A = 0x00, kVK_ANSI_S = 0x01, kVK_ANSI_D = 0x02, kVK_ANSI_F = 0x03, kVK_ANSI_H = 0x04, kVK_ANSI_G = 0x05, kVK_ANSI_Z = 0x06, kVK_ANSI_X = 0x07, kVK_ANSI_C = 0x08, kVK_ANSI_V = 0x09, kVK_ANSI_B = 0x0B, kVK_ANSI_Q = 0x0C, kVK_ANSI_W = 0x0D, kVK_ANSI_E = 0x0E, kVK_ANSI_R = 0x0F, kVK_ANSI_Y = 0x10, kVK_ANSI_T = 0x11, kVK_ANSI_1 = 0x12, kVK_ANSI_2 = 0x13, kVK_ANSI_3 = 0x14, kVK_ANSI_4 = 0x15, kVK_ANSI_6 = 0x16, kVK_ANSI_5 = 0x17, kVK_ANSI_Equal = 0x18, kVK_ANSI_9 = 0x19, kVK_ANSI_7 = 0x1A, kVK_ANSI_Minus = 0x1B, kVK_ANSI_8 = 0x1C, kVK_ANSI_0 = 0x1D, kVK_ANSI_RightBracket = 0x1E, kVK_ANSI_O = 0x1F, kVK_ANSI_U = 0x20, kVK_ANSI_LeftBracket = 0x21, kVK_ANSI_I = 0x22, kVK_ANSI_P = 0x23, kVK_ANSI_L = 0x25, kVK_ANSI_J = 0x26, kVK_ANSI_Quote = 0x27, kVK_ANSI_K = 0x28, kVK_ANSI_Semicolon = 0x29, kVK_ANSI_Backslash = 0x2A, kVK_ANSI_Comma = 0x2B, kVK_ANSI_Slash = 0x2C, kVK_ANSI_N = 0x2D, kVK_ANSI_M = 0x2E, kVK_ANSI_Period = 0x2F, kVK_ANSI_Grave = 0x32, kVK_ANSI_KeypadDecimal = 0x41, kVK_ANSI_KeypadMultiply = 0x43, kVK_ANSI_KeypadPlus = 0x45, kVK_ANSI_KeypadClear = 0x47, kVK_ANSI_KeypadDivide = 0x4B, kVK_ANSI_KeypadEnter = 0x4C, kVK_ANSI_KeypadMinus = 0x4E, kVK_ANSI_KeypadEquals = 0x51, kVK_ANSI_Keypad0 = 0x52, kVK_ANSI_Keypad1 = 0x53, kVK_ANSI_Keypad2 = 0x54, kVK_ANSI_Keypad3 = 0x55, kVK_ANSI_Keypad4 = 0x56, kVK_ANSI_Keypad5 = 0x57, kVK_ANSI_Keypad6 = 0x58, kVK_ANSI_Keypad7 = 0x59, kVK_ANSI_Keypad8 = 0x5B, kVK_ANSI_Keypad9 = 0x5C &#125;; /* keycodes for keys that are independent of keyboard layout*/ enum &#123; kVK_Return = 0x24, kVK_Tab = 0x30, kVK_Space = 0x31, kVK_Delete = 0x33, kVK_Escape = 0x35, kVK_Command = 0x37, kVK_Shift = 0x38, kVK_CapsLock = 0x39, kVK_Option = 0x3A, kVK_Control = 0x3B, kVK_RightShift = 0x3C, kVK_RightOption = 0x3D, kVK_RightControl = 0x3E, kVK_Function = 0x3F, kVK_F17 = 0x40, kVK_VolumeUp = 0x48, kVK_VolumeDown = 0x49, kVK_Mute = 0x4A, kVK_F18 = 0x4F, kVK_F19 = 0x50, kVK_F20 = 0x5A, kVK_F5 = 0x60, kVK_F6 = 0x61, kVK_F7 = 0x62, kVK_F3 = 0x63, kVK_F8 = 0x64, kVK_F9 = 0x65, kVK_F11 = 0x67, kVK_F13 = 0x69, kVK_F16 = 0x6A, kVK_F14 = 0x6B, kVK_F10 = 0x6D, kVK_F12 = 0x6F, kVK_F15 = 0x71, kVK_Help = 0x72, kVK_Home = 0x73, kVK_PageUp = 0x74, kVK_ForwardDelete = 0x75, kVK_F4 = 0x76, kVK_End = 0x77, kVK_F2 = 0x78, kVK_PageDown = 0x79, kVK_F1 = 0x7A, kVK_LeftArrow = 0x7B, kVK_RightArrow = 0x7C, kVK_DownArrow = 0x7D, kVK_UpArrow = 0x7E &#125;; /* ISO keyboards only*/ enum &#123; kVK_ISO_Section = 0x0A &#125;; /* JIS keyboards only*/ enum &#123; kVK_JIS_Yen = 0x5D, kVK_JIS_Underscore = 0x5E, kVK_JIS_KeypadComma = 0x5F, kVK_JIS_Eisu = 0x66, kVK_JIS_Kana = 0x68 &#125;;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>shortcuts</tag>
        <tag>Mac</tag>
        <tag>KeyCodes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[This app was unable to be installed.]]></title>
    <url>%2F2017%2F10%2F28%2FUnableInstalled-md%2F</url>
    <content type="text"><![CDATA[今天升级XCode 9.1 beta，编译项目正常，模拟器运行出现以下错误弹框： APP无法安装到模拟器上，也看不见任何提示，由于mac中存在多个XCode 版本，尝试下面命令： sudo xcode-select -s /Applications/Xcode-beta.app 并不好使。 这种问题看不见任何其他的问题提示，有点无从查起的赶脚。 stackoverflow上找到下面的方法： 1234xcrun simctl spawn booted log show//或者可以标出这个错误提示相关的，很容易看到相关的错误提示xcrun simctl spawn booted log show | grep &quot;This app was unable to be installed. 然后，基本就能定位问题了，我这里出现的问题是： Info.plist文件中缺少CFBundleExecutable，加上即可。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[High Sierra bad interpreter]]></title>
    <url>%2F2017%2F10%2F28%2FPodError-md%2F</url>
    <content type="text"><![CDATA[升级到mac OS High Sierra之后，pod失败，错误如下： -bash: /usr/local/bin/pod: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby: bad interpreter: No such file or directory 解决方案： 12sudo gem update --systemsudo gem install -n /usr/local/bin cocoapods]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS build error framework not found FileProvider for architecture x86_64]]></title>
    <url>%2F2017%2F10%2F28%2FNotFoundFileProvider-md%2F</url>
    <content type="text"><![CDATA[最近升级mac OS 到 High Sierra之后 XCode并没有立马升级，还是xcode 8.x，编译的时候，出现这样的问题： iOS build error: framework not found FileProvider for architecture x86_64 解决办法：update XCode to 9.x即可]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>xcode</tag>
        <tag>FileProvider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The document could not be autosaved. The file doesn’t exist.]]></title>
    <url>%2F2017%2F09%2F24%2FDocumentNotAutosaved%2F</url>
    <content type="text"><![CDATA[有时候莫名其妙的pod update之后(可能是拖拽文件到pod子项目导致的，具体忘了，出现问题的时候已经忘了之前干啥了。。。囧~)，然后某一个或者几个文件就不能编辑保存了，编译不过，如下： The document could not be autosaved. The file doesn’t exist. 而且，这个文件并没有路径显示： 从左侧栏右键Show in Finder，之后可以看到该文件在项目根目录下面的ProjectRootPath/Pods/Headers/Public/IMSDK/QCIMChatRoomVC.h 各种尝试不好使啊，重新pod也不管用，最终将子项目的该文件覆盖copy到上面的pods路径(ProjectRootPath/Pods/Headers/Public/IMSDK/QCIMChatRoomVC.h)下面，好使了。 以上，记一笔，出现好几次了，每次都是莫名其妙的出现了，然后莫名其妙的好了。。。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>autosaved</tag>
        <tag>exist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[resource fork, Finder information, or similar detritus not allowed]]></title>
    <url>%2F2017%2F09%2F24%2FResourceFork%2F</url>
    <content type="text"><![CDATA[XCode 8之后，上传AppStore可能会出现下面的错误： CodeSign /Users/gururajtallur/Library/Developer/Xcode/DerivedData/Flow-bkqjkvtmvjovpyepfjeyqmjpintj/Build/Products/Debug-iphoneos/Super\ Flow\ Flip.app cd “/Volumes/Development/Project/Top Best Games/19. Lets Flow/35/let’s FLOW - source/proj.ios_mac” export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate export PATH=”/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin”Signing Identity: “iPhone Distribution: New Free Games (2CHN583K4J)”Provisioning Profile: “Super Flow Flipp AppStore” (c6c30d2a-1025-4a23-8d12-1863ff684a05) /usr/bin/codesign --force --sign E48B98966150110E55EAA9B149F731901A41B37F --entitlements /Users/gururajtallur/Library/Developer/Xcode/DerivedData/Flow-bkqjkvtmvjovpyepfjeyqmjpintj/Build/Intermediates/Flow.build/Debug-iphoneos/Super\ Flow\ Flip.build/Super\ Flow\ Flip.app.xcent --timestamp=none /Users/gururajtallur/Library/Developer/Xcode/DerivedData/Flow-bkqjkvtmvjovpyepfjeyqmjpintj/Build/Products/Debug-iphoneos/Super\ Flow\ Flip.app /Users/gururajtallur/Library/Developer/Xcode/DerivedData/Flow-bkqjkvtmvjovpyepfjeyqmjpintj/Build/Products/Debug-iphoneos/Super Flow Flip.app: resource fork, Finder information, or similar detritus not allowedCommand /usr/bin/codesign failed with exit code 1 用下面的方法解决：终端，cd 到项目的根目录，然后依次执行下面的命令：1234find . -type f -name &apos;*.jpeg&apos; -exec xattr -c &#123;&#125; \;find . -type f -name &apos;*.jpg&apos; -exec xattr -c &#123;&#125; \;find . -type f -name &apos;*.png&apos; -exec xattr -c &#123;&#125; \;find . -type f -name &apos;*.json&apos; -exec xattr -c &#123;&#125; \; Clean Xcode and Re Build. Done. 如果还是未解决，请参考这里Â]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>osx</tag>
        <tag>mac os</tag>
        <tag>resource fork</tag>
        <tag>Finder information</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Compile warning:Embedded binary's NSExtensionActivationRule is TRUEPREDICATE]]></title>
    <url>%2F2017%2F09%2F24%2FNSExtensionActivationRule%2F</url>
    <content type="text"><![CDATA[上传AppStore的时候出现如下BUG： warning: Embedded binary’s NSExtensionActivationRule is TRUEPREDICATE. Before you submit your containing app to the App Store, be sure to replace all uses of TRUEPREDICATE with specific predicate statements or NSExtensionActivationRule keys. If any extensions in your containing app include TRUEPREDICATE, the app will be rejected. ShareExtnesion的plist文件中 NSExtensionActivationRule属性值为TRUEPREDICATE。 官方文档中提到： During development only, you can use the TRUEPREDICATE constant (which always evaluates to true) as a stub predicate statement, to test your code path before you implement your predicate statement. 注意: development only,所以上架的时候不能用。 可以参考下图修改 NSExtensionActivationRule的属性值可以参考这里]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>NSExtensionActivationRule</tag>
        <tag>TRUEPREDICATE</tag>
        <tag>osx</tag>
        <tag>mac os</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac中NSScrollView自定义滑动条NSScroller]]></title>
    <url>%2F2017%2F09%2F24%2FNSScroller%2F</url>
    <content type="text"><![CDATA[最近在捣鼓mac上开发app，本以为iOS、mac开发本是同根生，弄起来应该差不多，上手之后才发现iOS是多么的优雅自在，而mac是干啥都觉得不太顺手，UIKit跟AppKit差别还真是不一般的大。 最近，感觉NSScrollView右侧的滑动条长得不好看，想把滑动条的背景去掉，本想着设置个某个属性就能轻而易举的搞定，谁不知捣鼓半天没弄出来，mac开发的相关资料也着实太少，在这里记一笔，加深一下印象。 Tips：需要的同学，可以直接前往这里指点批评，或者为我转身点亮一颗小星星。 滑动条需要瞒住一下几个方面的需求： 滑动页面时候，显现滑动条，跟随滑动； 停止滑动页面的时候，自动隐藏滑动条； 任何时候滑动条背景色为透明； 下面直接上一下，NSScroller子类 JJScroller的.m文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990@implementation JJScroller- (id)initWithFrame:(NSRect)frameRect&#123; self = [super initWithFrame:frameRect]; if (self == nil) &#123; return nil; &#125; [self commonInitializer]; return self;&#125;- (void)awakeFromNib&#123; [super awakeFromNib]; [self commonInitializer];&#125;- (void)commonInitializer&#123; NSTrackingArea *trackingArea = [[NSTrackingArea alloc] initWithRect:self.bounds options:(NSTrackingMouseEnteredAndExited | NSTrackingActiveInActiveApp | NSTrackingMouseMoved) owner:self userInfo:nil]; [self addTrackingArea:trackingArea];&#125;- (void)drawRect:(NSRect)dirtyRect &#123; // Do some custom drawing... // Call NSScroller's drawKnob method (or your own if you overrode it) [self drawKnob];&#125;- (void)drawKnobSlotInRect:(NSRect)slotRect highlight:(BOOL)flag&#123; // Don't draw the background. Should only be invoked when using overlay scrollers&#125;- (void)mouseExited:(NSEvent *)theEvent&#123; [super mouseExited:theEvent]; [self fadeOut];&#125;- (void)mouseEntered:(NSEvent *)theEvent&#123; [super mouseEntered:theEvent]; [NSAnimationContext runAnimationGroup:^(NSAnimationContext *context) &#123; context.duration = 0.1f; [self.animator setAlphaValue:1.0f]; &#125; completionHandler:^&#123; &#125;]; [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(fadeOut) object:nil];&#125;- (void)mouseMoved:(NSEvent *)theEvent&#123; [super mouseMoved:theEvent]; self.alphaValue = 1.0f;&#125;- (void)setFloatValue:(float)aFloat&#123; [super setFloatValue:aFloat]; [self.animator setAlphaValue:1.0f]; [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(fadeOut) object:nil]; [self performSelector:@selector(fadeOut) withObject:nil afterDelay:1.5f];&#125;- (void)fadeOut&#123; [NSAnimationContext runAnimationGroup:^(NSAnimationContext *context) &#123; context.duration = 0.3f; [self.animator setAlphaValue:0.0f]; &#125; completionHandler:^&#123; &#125;];&#125;+(CGFloat)scrollerWidthForControlSize:(NSControlSize)controlSize scrollerStyle:(NSScrollerStyle)scrollerStyle&#123; return 15;&#125;+ (BOOL)isCompatibleWithOverlayScrollers&#123; return self == [JJScroller class];&#125;@end]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>osx</tag>
        <tag>mac os</tag>
        <tag>NSScrollView</tag>
        <tag>NSScroller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac中NSScrollView滑动监测]]></title>
    <url>%2F2017%2F09%2F24%2FNSScrollViewSliding%2F</url>
    <content type="text"><![CDATA[不同于iOS中的UIScrollView，mac中的NSScrollView并没有一堆靠谱好用的delegate来帮助我们方便的监控ScrollView的状态。 iOS中我们可以通过UIScrollView的contentOffset属性来获知滑动的位置，而在mac中我们是通过NSScrollView的contentView(NSClipView的实例)的documentVisibleRect.origin来获知滑动的相对位置。 在iOS中我们可以通过UISCrollView的delegate方法- (void)scrollViewDidScroll:(UIScrollView *)scrollView;来在滑动的过程中做一些我们爱做的事儿呢。 那么在mac中NSScrollView我们有没有同样的东西来做我们爱做的事儿呢？当然是有的，只是跟iOS中有些许的区别，NSScrollView是通过通知来实现的，直接上代码： 123456//找个合适的地儿，注册通知NSNotificationCenter *center = [NSNotificationCenter defaultCenter] ; [center addObserver: self selector: @selector(boundsDidChangeNotification:) name: NSViewBoundsDidChangeNotification object: [self.scrollView contentView]]; 需要注意的是 ，在上面通知注册之前，你需要加上这么一句： 1[[self.scrollView contentView] setPostsBoundsChangedNotifications: YES]; 然后在NSScrollView滑动的时候，你就能在你实现下面这个方法的地方，做你想做的爱做的事儿了： 123456789101112- (void) boundsDidChangeNotification: (NSNotification *) notification&#123; // 在这里进行处理 NSClipView *changedContentView=[notification object]; // get the origin of the NSClipView of the scroll view that // we're watching NSPoint changedBoundsOrigin = [changedContentView documentVisibleRect].origin;&#125; 以上，欢迎典藏。]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>osx</tag>
        <tag>mac os</tag>
        <tag>NSScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xcode快捷键你知多少？]]></title>
    <url>%2F2017%2F07%2F30%2Fxcode-shortcuts%2F</url>
    <content type="text"><![CDATA[常言道，工欲善其事必先利其器。 了解xcode常用快捷键在coding中的使用，很容易摆脱鼠标的拖累，大大提高coding的效率。 快速搜索跳转文件快捷键：cmd + shift + o 这个快捷键的使用频率非常高，是摆脱鼠标的一大利器。 注意：o是表示惊讶的哦..😯，不是考试得到的零蛋0，o == open。 快速跳至某行快捷键：cmd + l 常用这个快捷键，首先你要留意一下行号。 注意：字母l并不是大写的I，也不是数字1，是大写字母L的小写，l == line。 代码块上下移动快捷键：option + cmd + [(or ]) 很多时候，你需要将某几行代码交换位子顺序，或者某几行代码前移/后移几行，那么这个快捷键就有了用武之地了。 注意：移动前选中你要移动的所有行。 .h/.m文件之间快速切换快捷键：ctrl + cmd + ↑(or ↓) ↑(or ↓)效果一样 前进/后退快捷键：ctrl + cmd + ←(or →) ←(or →)跟浏览器上一页or下一页类似。 显示当前类的方法列表，可搜索快捷键：ctrl + 6 上述快捷键之后，可方向键选择后回车，也可触摸板滑动选择。 最重要的是显示列表之后，可直接输入相关字符搜索。 搜索、替换文件类搜索：cmd + f 文件类替换：cmd + option + f 全局搜索：cmd + shift + f 全局替换：cmd + shift + option + f 注意：全局搜索替换可以指定目录，也可以选择匹配格式，这个选择在搜索框与替换框之间。 文件类与全局都可以在搜索框最前面的🔍位置点击切换搜索/替换。 打开Related Items列表快捷键：ctrl + 1 光标停留在相应的关键词中，此快捷键可查看父类，调用者，被调用者，includes，included by等诸多信息。 收起/展开代码块快捷键：option + cmd + ←(or →) 在左侧目录中快速定位当前文件位置快捷键：cmd + shift + j 快速切换左边导航栏快捷键：cmd + 1~8 注意：cmd + 0是‘显示/隐藏左侧栏’，cmd + cmd + option + 0是‘显示/隐藏右侧栏’。 全局修改局部变量快捷键：ctrl + cmd + e 当你想要将button换一个变量名的时候，这个快捷键绝对能爽死你，当然你也能用鼠标或者触摸板实现这个功能，选中变量名，移动光标会出现一个小箭头，点开会有快捷菜单，选择Edit All in Scope。 当然还有一些基础的快捷键在这里就不一一列举了，相信大家也都知道，比如，编译(cmd + b)，运行(cmd + r)，clean(cmd + shift + k)，快速移动光标(cmd + 方向键)，快速选择代码(cmd + shift + 方向键)等。 值得注意的是，除了上述快捷键之外，右键快捷菜单也是很有用处的，举个栗子： 光标置于类名中，右键(或者触摸板两手指头单击)显示快捷菜单，选择Refactor -- Rename，全局替换类名。 XVim最后，我想说的是，想要快捷键运用的炉火纯青，而且不会因为软件间系统间的各种差异出现很大的变化，vim！！ 这个绝对是神器，xcode可以安装vim插件XVim。 注意： xcode 8之后，需要先安装证书. 下载下来编译不过的话，是因为类IDEPlaygroundEditor没实现(IDEPlaygroundEditor+XVim.h中)，加上实现@implementation即可，或者直接删除报错的文件以及引用此文件头文件的地方。 XVim快捷键使用见这里。 放出一张vim命令图解：]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>xcode</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift闭包--简不简洁？！优不优雅？！]]></title>
    <url>%2F2017%2F07%2F22%2FClosures%2F</url>
    <content type="text"><![CDATA[闭包(Closures) 闭包是自包含的函数代码块，可以在代码中被传递和使用。 Closures are self-contained blocks of functionality that can be passed around and used in your code.–摘自官方文档 相信大家都熟悉C 和 Objective-C 中的代码块(blocks)或者其他一些编程语言中的匿名函数，Swift中的闭包与之相类似。 闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为包裹常量和变量。 注意: 如果你不熟悉捕获(capturing)这个概念也不用担心，在后面文章会对其进行详细介绍(我要尾随)。 Swift会为你管理在捕获过程中涉及到的所有内存操作。(PS:类似于Objective-C,不会让你过多的经历花费在内存管理上，而应该更过的考虑其他更重要的事情，本该如此!) 闭包一般采取以下三种形式： 全局函数是一个有名字但不会捕获任何值的闭包 嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包 闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包 Swift简洁优雅的个性在闭包中有很好的体现，主要优化如下： 利用上下文推断参数和返回值类型 隐式返回单表达式闭包，即单表达式闭包可以省略return关键字 参数名称缩写 尾随闭包语法 闭包表达式 闭包表达式是一种利用简洁语法构建内联闭包的方式。闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。 下面我们来看一个例子： Swift标准库提供了名为sorted(by:)的方法，它会根据你所提供的用于排序的闭包函数将已知类型数组中的值进行排序。一旦排序完成，sorted(by:)方法会返回一个与原数组大小相同，包含同类型元素且元素已正确排序的新数组。原数组不会被sorted(by:)方法修改。 举个栗子：闭包表达式示例使用sorted(by:)方法对一个String类型的数组进行字母逆序排序。 通常我们会这样写： 1234567891011//初始化一个字符串类型数组let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]//定义排序闭包函数func backward(_ s1: String, _ s2: String) -&gt; Bool &#123; return s1 &gt; s2&#125;//执行排序操作var reversedNames = names.sorted(by: backward)// reversedNames 为 ["Ewa", "Daniella", "Chris", "Barry", "Alex"] sorted(by:)方法接受一个闭包(其实就是一个函数指针)，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值前面，排序闭包函数需要返回true，反之返回false。 该例子对一个String类型的数组进行排序，因此排序闭包函数(func backward)类型需为(String, String) -&gt; Bool(即函数指针类型，两个参数String类型，返回值是Bool类型的函数指针)。 如果第一个字符串(s1)大于第二个字符串(s2)，backward(_:_:)函数会返回true，表示在新的数组中s1应该出现在s2前。对于字符串中的字符来说，“大于”表示“按照字母顺序较晚出现”。这意味着字母&quot;B&quot;大于字母&quot;A&quot;，字符串&quot;Tom&quot;大于字符串&quot;Tim&quot;。该闭包将进行字母逆序排序，&quot;Barry&quot;将会排在&quot;Alex&quot;之前。 然而，以这种方式来编写一个实际上很简单的表达式(a &gt; b)，确实太过繁琐了。对于这个例子来说，利用闭包 表达式语法可以更好地构造一个内联排序闭包。 闭包表达式语法有如下的一般形式: 123&#123; (parameters) -&gt; returnType in statements&#125; 闭包表达式参数可以是in-out参数，但不能设定默认值。也可以使用具名的可变参数(注意:但是如果可变参数不放在参数列表的最后一位的话，调用闭包的时时编译器将报错。)。元组也可以作为参数和返回值。 于是，我们可以将之前backward(_:_:)函数用闭包表达式优化，如下： 123reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2&#125;) 这个闭包的函数体部分如此短，以至于可以将其改写成一行代码:1reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2 &#125; ) 该例中sorted(by:)方法的整体调用保持不变，一对圆括号仍然包裹住了方法的整个参数。然而，参数现在变成了内联闭包。 写到这里，如果你认为就此结束了的话，Swift君只能说你还是太年轻。 开篇我们提到，闭包会有这样一条优化：利用上下文推断参数和返回值类型。 排序闭包函数是作为sorted(by:)方法的参数传入的，Swift可以推断其参数和返回值的类型。sorted(b y:)方法被一个字符串数组调用，因此其参数必须是 (String, String) -&gt; Bool类型的函数。这意味着(String, String)和Bool类型并不需要作为闭包表达式定义的一部分。因为所有的类型都可以被正确推断，返回箭头(-&gt;)和围绕在参数周围的括号也可以被省略: 1reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; ) 实际上，通过内联闭包表达式构造的闭包作为参数传递给函数或方法时，总是能够推断出闭包的参数和返回值类型。这意味着闭包作为函数或者方法的参数时，你几乎不需要利用完整格式构造内联闭包。 其实，return关键词我们也是可以省略的，因为可以 单表达式闭包隐式返回 ,这也是闭包的主要优化之一。 如上的例子可以改写为:1reversedNames = names.sorted(by: &#123; s1, s2 in s1 &gt; s2 &#125; ) sorted(by:)方法的参数类型明确了闭包必须返回一个Bool类型值。因为闭包函数体只包含了一个单一表达式(s1 &gt; s2)，该表达式返回Bool类型值，因此这里没有歧义，return关键字可以省略。 开篇提到的闭包优化的几点中，还有说道 参数名称缩写 功能。 Swift君有说：你可以直接通过$0，$1，$2来顺序调用闭包的参数，以此类推。如果你在闭包表达式中使用参数名称缩写，你可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。 in关键字也同样可以被省略,因为…，看下面优化后的代码你明白，in在这里确实没什么卵用了： 1reversedNames = names.sorted(by: &#123; $0 &gt; $1 &#125; ) 其中，$0和$1表示闭包中第一个和第二个String类型的参数. 我次奥！！！到这里，我相信大家会有跟我一样的感叹，哈哈~ 所以，最后还是有必要来一记大招：1reversedNames = names.sorted(by: &gt;) 是的，你没有看错，这才是最终的形态。 Swift的String类型定义了关于大于号(&gt;)的字符串实现，其作为一个函数接受两个String类型的参数并返回Bool类型的值。而这正好与sorted(by:)方法的参数需要的函数类型相符合。因此，你可以简单地传递一个大于号，Swift可以自动推断出你想使用大于号的字符串函数实现。 贴上大于号(&gt;)的定义： 12345678910/// Returns a Boolean value indicating whether the value of the first argument/// is greater than that of the second argument.////// This is the default implementation of the greater-than operator (`&gt;`) for/// any type that conforms to `Comparable`.////// - Parameters:/// - lhs: A value to compare./// - rhs: Another value to compare.public func &gt;&lt;T&gt;(lhs: T, rhs: T) -&gt; Bool where T : Comparable 当然还有更多的运算符方法，想到这里，我就想问你，简洁不简洁，优雅不优雅，刺激不刺激？！哈哈。。。]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>swift</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 9.0之后NSString encode方法替换]]></title>
    <url>%2F2017%2F07%2F22%2FEncode_Update%2F</url>
    <content type="text"><![CDATA[在iOS 9.0之后，以前常用的NSString编码的方法stringByAddingPercentEscapesUsingEncoding:被弃用了，项目中可能会出现一堆如下⚠️： ‘stringByAddingPercentEscapesUsingEncoding:’ is deprecated: first deprecated in iOS 9.0 - Use-stringByAddingPercentEncodingWithAllowedCharacters: instead, which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid. 作为一个有强迫症的优秀程序猿，表示不能忍！ 文档里面是这么说的： 1- (nullable NSString *)stringByAddingPercentEscapesUsingEncoding:(NSStringEncoding)enc NS_DEPRECATED(10_0, 10_11, 2_0, 9_0, &quot;Use -stringByAddingPercentEncodingWithAllowedCharacters: instead,which always uses the recommended UTF-8 encoding, and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid.&quot;); 很明白，用stringByAddingPercentEncodingWithAllowedCharacters:方法替换之。 这个方法官方文档是这么说的： // Returns a new string made from the receiver by replacing all characters not in the allowedCharacters set with percent encoded characters. UTF-8 encoding is used to determine the correct percent encoded characters. Entire URL strings cannot be percent-encoded. This method is intended to percent-encode an URL component or subcomponent string, NOT the entire URL string. Any characters in allowedCharacters outside of the 7-bit ASCII range are ignored. 最后一句Any characters in allowedCharacters outside of the 7-bit ASCII range are ignored.，意思就是说，任何非7-bit ASCII字符搁到allowedCharacters里面也将被忽略，也就是allowedCharacters里面的字符跟7-bit ASCII字符不会被编码，比如中文。 换句话说，上面方法在处理的时候会编码url的中的非7-bit ASCII字符，如这些【`#%^{}\”[]|\&lt;&gt;】，如果需要忽略之，需要通过(NSCharacterSet *)allowedCharacters这个参数指定。总结如下 1234[aString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];//等价于[aString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet characterSetWithCharactersInString:@&quot;`#%^&#123;&#125;\&quot;[]|\\&lt;&gt; &quot;]]; 注意： 字符集最后是一个空格！ 这里字符集的意思就是，字符串中含有字符集里面的字符将会会被编码。 另外，URL中常用的NSCharacterSet类型定义在分类NSCharacterSet (NSURLUtilities)中，包含字符集如下： 1234567891011URLHostAllowedCharacterSet &quot;#%/&lt;&gt;?@\^`&#123;|&#125;URLFragmentAllowedCharacterSet &quot;#%&lt;&gt;[\]^`&#123;|&#125;URLPasswordAllowedCharacterSet &quot;#%/:&lt;&gt;?@[\]^`&#123;|&#125;URLPathAllowedCharacterSet &quot;#%;&lt;&gt;?[\]^`&#123;|&#125;URLQueryAllowedCharacterSet &quot;#%&lt;&gt;[\]^`&#123;|&#125;URLUserAllowedCharacterSet &quot;#%/:&lt;&gt;?@[\]^` 以上，还在等什么，全局搜索替换吧，消灭⚠️！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>encode</tag>
        <tag>NSString</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS脚本自动编译静态包/静态库]]></title>
    <url>%2F2017%2F07%2F22%2Fautobuild%2F</url>
    <content type="text"><![CDATA[在iOS开发中，有时候为了项目模块间的相互独立性，降低模块间的耦合，通常将底层相对稳定的模块抽取出来，形成SDK，以静态包或者静态库的形式引入项目。这中间免不了编译打包静态包/库，通常的做法是模拟器和真机分别编译，然后再将两个静态包或者库lipo合并成一个。这样的工作做多了，难免觉得麻烦，想省事儿，整一脚本变得自然而然了。 1. 创建一个静态包/库工程(已有请跳过这一步) 创建如下图： 在Trargets下面，点击左下角的“+”,选择添加一个新的Target， 然后选择“Aggregate”选项，新建一个集合类target，如下图所示： 2. 给集合类添加依赖 在Targets下面选中我们新建的集合类，然后Build Phases –&gt; Target Dependencies 下面添加我们需要编译的静态库,如下图所示： 3. 添加脚本 在Targets下面选中我们新建的集合类,然后在Build Phases下，点击左上角的“+”，选择”New Run Script Phase”选项,如下图： 然后设置我们运行的脚本的所在位置,如下图所示: 注意： ../scripts/build-framework.sh 表示脚本的位置在当前工程的上一个目录下地scripts文件夹下. 当然”../“也可以用”${SRCROOT}/../“来代替. 脚本位置可根据实际情况自行设置。 4. 选择我们创建的集合类的target，编译 在编译时，你可能会遇到下面的错误：1Permission denied. 这是因为shell脚本，还没有添加可执行的权限。 解决办法：在终端上， cd 进入到脚本所在的文件夹； 然后使用 chmod +x ./yourShellName.sh 命令， 成功之后，就可以正常的运行Xcode工程了。 5. 指定target 一般来说我们编译的target名称，跟我们的project工程的名称是一样的，但是，如果我们修改了我们的target名称，需要在我们制定脚本的位置后面跟上我们需要编译的target名称，既:脚本位置+空格+target名称。如下图： 6. shell脚本源码 编译library的脚本 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/sh#要build的target名target_Name=$&#123;PROJECT_NAME&#125;if [[ $1 ]]thentarget_Name=$1fiUNIVERSAL_OUTPUT_FOLDER="$&#123;SRCROOT&#125;/$&#123;PROJECT_NAME&#125;_Products"# 创建输出目录，并删除之前的文件rm -rf "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;"mkdir -p "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;"# 分别编译真机和模拟器版本xcodebuild -target "$&#123;target_Name&#125;" ONLY_ACTIVE_ARCH=NO -configuration $&#123;CONFIGURATION&#125; -sdk iphoneos BUILD_DIR="$&#123;BUILD_DIR&#125;" BUILD_ROOT="$&#123;BUILD_ROOT&#125;" clean buildxcodebuild -target "$&#123;target_Name&#125;" ONLY_ACTIVE_ARCH=NO -configuration $&#123;CONFIGURATION&#125; -sdk iphonesimulator BUILD_DIR="$&#123;BUILD_DIR&#125;" BUILD_ROOT="$&#123;BUILD_ROOT&#125;" clean build#复制头文件到目标文件夹HEADER_FOLDER="$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/include/$&#123;target_Name&#125;"if [[ -d "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/usr/local/include" ]]then HEADER_FOLDER="$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/usr/local/include"ficp -R "$&#123;HEADER_FOLDER&#125;" "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;"#合成模拟器和真机.a包lipo -create "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/lib$&#123;target_Name&#125;.a" "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphoneos/lib$&#123;target_Name&#125;.a" -output "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/lib$&#123;target_Name&#125;.a"# 判断build文件夹是否存在，存在则删除if [ -d "$&#123;SRCROOT&#125;/build" ]thenrm -rf "$&#123;SRCROOT&#125;/build"fi#打开目标文件夹open "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;" 编译framework的shell脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/bin/sh#要build的target名TARGET_NAME=$&#123;PROJECT_NAME&#125;if [[ $1 ]]thenTARGET_NAME=$1fiUNIVERSAL_OUTPUT_FOLDER="$&#123;SRCROOT&#125;/$&#123;PROJECT_NAME&#125;_Products/"#创建输出目录，并删除之前的framework文件mkdir -p "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;"rm -rf "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/$&#123;TARGET_NAME&#125;.framework"#分别编译模拟器和真机的Frameworkxcodebuild -target "$&#123;TARGET_NAME&#125;" ONLY_ACTIVE_ARCH=NO -configuration $&#123;CONFIGURATION&#125; -sdk iphoneos BUILD_DIR="$&#123;BUILD_DIR&#125;" BUILD_ROOT="$&#123;BUILD_ROOT&#125;" clean buildxcodebuild -target "$&#123;TARGET_NAME&#125;" ONLY_ACTIVE_ARCH=NO -configuration $&#123;CONFIGURATION&#125; -sdk iphonesimulator BUILD_DIR="$&#123;BUILD_DIR&#125;" BUILD_ROOT="$&#123;BUILD_ROOT&#125;" clean build#拷贝framework到univer目录cp -R "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;TARGET_NAME&#125;.framework" "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;"#合并framework，输出最终的framework到build目录lipo -create -output "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/$&#123;TARGET_NAME&#125;.framework/$&#123;TARGET_NAME&#125;" "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;TARGET_NAME&#125;.framework/$&#123;TARGET_NAME&#125;" "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphoneos/$&#123;TARGET_NAME&#125;.framework/$&#123;TARGET_NAME&#125;"#删除编译之后生成的无关的配置文件dir_path="$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/$&#123;TARGET_NAME&#125;.framework/"for file in ls $dir_pathdoif [[ $&#123;file&#125; =~ ".xcconfig" ]]thenrm -f "$&#123;dir_path&#125;/$&#123;file&#125;"fidone#判断build文件夹是否存在，存在则删除if [ -d "$&#123;SRCROOT&#125;/build" ]thenrm -rf "$&#123;SRCROOT&#125;/build"firm -rf "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator" "$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphoneos"#打开合并后的文件夹open "$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;"]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--单例模式]]></title>
    <url>%2F2017%2F07%2F16%2FDesignPattern_Singleton%2F</url>
    <content type="text"><![CDATA[单例模式(singleton) 单例模式最初的定义出现于《设计模式》(Addison-Wesley,1994) 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式几乎是设计模式的最简单形式了，这一模式的意图是使得类的一个对象成为系统中的唯一实例。要实现这一点，可以从客户端对其进行实例化开始。因此需要一种只允许生成对象类的唯一实例的机制，“阻止”所有想要生成对象的访问。我们可以用工厂方法来限制实例化的过程。这个方法应该为静态方法(类方法)，因为我们让类的实例去生成另一个唯一实例毫无意义。 单例模式的类图如下： static uniqueInstance是Singleton的唯一实例，static sharedInstance将它返回给客户端。通常，sharedInstance会检查uniqueInstance是否已经被实例化，如果没有，它会生成一个实例后返回uniqueInstance。 何时使用原型模式？在以下情形，会考虑使用原型模式： 类只有一个实例，而且必须从一个为人熟知的访问点对其进行访问，比如工厂方法； 这个唯一实例只能通过子类化进行扩展，而且扩展的对象不会破坏客户端代码。 使用Cocoa Touch框架中使用单例模式Cocoa Touch框架中使用了大量的单例类。下面讨论其中的几个： 1.UIApplication类 框架中使用最常用的一个类是UIApplication类。它提供了一个控制并协调iOS应用程序的集中点。 每个应用程序有且仅有一个UIApplication的实例。它由UIApplicationMain函数在应用程序启动时创建为单例对象。之后，对同一UIApplication实例可以通过其sharedApplication类方法进行访问。 UIApplication对象为应用程序处理许多内存管理任务(housekepping task)，包括传入事件的最初路由，以及为UIControl分发动作消息给核实的目标对象。它还维护应用程序中的所有UIWindow对象的列表。。应用程序对象总是被分配一个UIApplicationDelegate对象，应用程序将把重要的运行时状态通知给它，比如iOS应用程序中的应用程序启动、内存不足警告、应用程序终止和后台进行执行。这让委托(delegate)有机会做出适当的响应。 2.UIAcceleremeter类 Cocoa Touch框架中另一个常用的单例是UIAcceleremeter.UIAcceleremeter让应用程序可以注册，以接收来自iOS设备内置的加速度计的加速度的相关数据。应用程序会收到三维空间中沿主轴的线性加速度变化，可以使用这一数据检测设备的当前方向和当前方向的瞬间变化。 UIAcceleremeter是单例，所以不能直接生成它的对象。而是应该调用其sharedAcceleremeter单例类方法以访问它的唯一实例。然后设定它的updateInterval属性，并用自己的delegate对象设定delegate属性，以接收来自单例实例的加速度数据。 3.NSFileManager类 在Mac OS X v10.5和iOS2.0之前，NSFileManager曾经是单例模式的“严格”实现。调用它的init方法是空操作，并且唯一实例可以通过defaultManager类方法创建和访问。然而其单例实现并不是线程安全的。现在推荐生成新的NSFileManager实例以保证线程安全。这一方式被认为是更灵活的单例实现，其中工厂方法总是返回同一实例，但是也可以分配并初始化另外的实例。 附上单例模式的Demo：DesignPattern_Singleton]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--生成器(建造者)]]></title>
    <url>%2F2017%2F07%2F09%2FDesignPattern_Builder%2F</url>
    <content type="text"><![CDATA[生成器模式(Builder) 生成器模式最初的定义出现于《设计模式》(Addison-Wesley,1994) 生成器模式：将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表现。 生成器模式的类图如下： 除了客户与其所要的产品，生成器模式还包含两个重要角色：Director(指导者)和Builder(生成器)。Builder知道究竟如何在缺少某些特定信息的情况下建造产品(什么)。Director知道Builder应该建造什么，以参数向其提供缺少的信息来建造特定产品。尽管Director知道Builder应该建造什么，这并不意味着Director知道具体Builder究竟是什么。他们的静态关系如上图中的类图所示。 Builder是一个抽象接口，声明了一个buildPart方法，该builder方法由ConcreteBuilder实现，以构造实际产品(Product)。ConcreteBuilder有个getResult方法，向客户端返回构造完毕的Product。Director定义了一个construct方法，命令Builder的实例去builderPart。Director与Builder形成了一种聚合关系。这意味着Builder是一个组成部分，与Director结合，以使整个模式运转，但同时，Director并不负责Builder的生存期。 何时使用生成器模式？在以下情形，你自然会想到使用工厂方法模式： 需要创建设计各种部件的负责对象。创建对象的算法应该独立于部件的装配方式。 构建过程需要以不同的方式(例如，部件或者表现的不同组合)构建对象。 生成器与抽象工厂对比 生成器 抽象工厂 构建负责对象 构建简单或者复杂对象 以多个步骤构建对象 以单一步骤构建对象 以多种方式构建对象 以单一方式构建对象 在构建过程的最后一步返回产品 立刻返回产品 专注一个特定产品 强调一套产品 附生成器模式的Demo：DesignPattern_Builder]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--抽象工厂]]></title>
    <url>%2F2017%2F07%2F08%2FDesignPattern_AbstractFactory%2F</url>
    <content type="text"><![CDATA[抽象工厂模式(abstract factory) 抽象工厂模式最初的定义出现于《设计模式》(Addison-Wesley,1994) 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。 抽象工厂模式的类图如下： 在软件设计中，如果客户端想手工创建一个类的对象，那么客户端需要首先知道这个类的细节。更糟的情况是，一组相关的对象可以在运行时按照不同的标准创建得不一样，此时客户端就需要知道全部细节才能创建他们。这种情况就可以用抽象工厂模式来解决这个问题。 抽象工厂提供一个固定的接口，用于创建一系列有关联或相互依存的对象，而不必指定其具体类或创建细节。客户端与从工厂得到的具体对象之间没有耦合。 Client只知道AbstractFactory和AbstractProduct。每个工厂类中，结构与实际操作的细节按黑箱对待。甚至产品也不知道谁将负责创建他们。只有具体工厂知道为客户端创建什么、如何创建。这个模式有趣的一点是，很多时候他都是用哪个工厂方法模式来实现。工厂方法吧实际的创建过程推迟到重载它的子类中。在类图中，方法createProductA和createProductB是工厂方法。最初的抽象方法什么也不创建。这种抽象非常通用，广泛用于任何需要抽象创建过程的场合。 抽象模式常与原型模式、单例模式、享元模式等其他设计模式一起使用。 抽象工厂模式与工厂方法模式 抽象工厂模式 工厂方法模式 通过对象组合创建抽象产品 通过类继承创建抽象产品 创建多系列产品 创建一种产品 必须修改父类才能支持新的产品 子类化创建者并重载工厂方法以创建新产品 软件设计黄金法则： 变动需要抽象 在Cocoa Touch框架中使用抽象工厂抽象工厂模式常见于Cocoa Touch框架。有很多基础类采用了这一模式。特别常见的一个就是NSNumber。创建NSNumber实例的方式完全符合抽象工厂模式。 创建Cocoa Touch对象有两种方式：使用先alloc再init的方法(两步创建过程)，或者使用类中的+className...方法。在Cocoa Touch的基础框架中，NSNumber类有很多类方法用于创建各种类型的NSNumber对象，像下面这样的：12345NSNumber * boolNumber = [NSNumber numberWithBool:YES];NSNumber * charNumber = [NSNumber numbberWithChar:'a'];NSNumber * intNumber = [NSNumber numberWithInt:1];NSNumber * floatNumber = [NSNumber numberWithFloat:1.0];NSNumber * doubleNumber = [NSNumber numberWithDouble:1.0]; 每个返回的对象属于代表最初输入值的不同私有子类。可以像这样列出他们的描述： 12345NSLog(@"%@",[[boolNumber class] description]);NSLog(@"%@",[[charNumber class] description]);NSLog(@"%@",[[intNumber class] description]);NSLog(@"%@",[[floatNumber class] description]);NSLog(@"%@",[[doubleNumber class] description]); 将看到控制台输出： 12345NSCFBolleanNSCFNumberNSCFNumberNSCFNumberNSCFNumber 除了boolNumber的实际类型是NSCFBoolean以外，大多数实际类为NSCFNumber类型。尽管这些+className...类工厂方法返回NSNumber具体子类的实例，但是返回的实例确实支持NSNumber的公有接口。 虽然它们属于NSNumber的不同具体子类，但是其行为由抽象超类NSNumber定义，而且是公有的。若执行以下代码段，就会明白我的意思。 12NSLog(@"%@",[boolNumber intValue]);NSLog(@"%@",[charNumber boolValue] ? @"YES" : @"NO"); 将看到控制台输出： 121YES boolNumber 内部保持布尔值YES，但是仍然实现了公有intValue方法，返回反映其内部布尔值的适当整数值。charNumber也是如此，它重载了boolValue方法，返回反映其内部布尔值的适当布尔值。 接受不同类型的参数并返回NSNumber实例的类方法是类工厂方法(工厂方法模式)。NSNumber的类工厂方法生产各种“数工厂”。numberWithBool:创建NSCFBoolean工厂的实例，而numberWithInt:创建NSCFNumber的实例。NSNumber中的类工厂方法定义了决定实例化何种私有具体子类(比如，NSCFBoolean或NSCFNumber)的默认行为。这一版本的工厂方法是传统工厂方法的一个变体，虽然它达成了返回抽象产品的目的，此处的抽象产品为作为工厂的具体NSNumber子类。NSNumber是抽象工厂实现的一个例子。基础框架中抽象工厂的此种特点被称为“类簇”(Class Cluster)。 类簇是基础框架中一种常见的设计模式，基于抽象工厂模式的思想，它将若干相关的私有具体工厂子类集合到一个公有的抽象超类之下。类簇是抽象工厂的一种形式。 创建抽象产品的工厂方法与创建抽象工厂的工厂方法之前有个不同点。显然，像intValue和boolValue这样的工厂方法，应该在具体工厂(NSCFNumber和NSCFBoolean)中重载以返回实际值(产品)。其它像numberWithBool:和numberWithInt:这样的工厂方法并不是为了返回产品，而是为了返回能返回产品的工厂，因此它们不应在具体工厂子类中重载。 其它实现为类簇的基础类有NSData,NSArray,NSDictionary和NSString。 附上抽象工厂模式的Demo：DesignPattern_AbstractFactory]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown中插入表格/图表，位置居中/左/右，这一篇就够了！]]></title>
    <url>%2F2017%2F07%2F08%2FMarkdown_Table%2F</url>
    <content type="text"><![CDATA[Markdown中插入表格时只需要复制一下下面【】内的即可(注意：不要复制【】)。 说明： 两竖线|中间为一个单元格，每行列数即为每行竖线数-1； 行数-1为表格行数，因为第二行为配置行，配置表格显示用，并不显示出来； 【|标题一|标题二|标题三|标题四||- |:—|—:|:—:||xxxxxxxxx|xxxxxxxxx|xxxxxxxxx|xxxxxxxxx||xxxxxxxxxxxxxx|xxxxxxxxxxxxxx|xxxxxxxxxxxxxx|xxxxxxxxxxxxxx||xxxxxxxxx|xxxxxxxxx|xxxxxxxxx|xxxxxxxxx||】 标题一 标题二 标题三 标题四 xxxxxxxxx xxxxxxxxx xxxxxxxxx xxxxxxxxx xxxxxxxxxxxxxx xxxxxxxxxxxxxx xxxxxxxxxxxxxx xxxxxxxxxxxxxx xxxxxxxxx xxxxxxxxx xxxxxxxxx xxxxxxxxx]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--工厂方法]]></title>
    <url>%2F2017%2F07%2F02%2FDesignPattern_FactoryMethod%2F</url>
    <content type="text"><![CDATA[工厂方法模式(factory method) 工厂方法模式最初的定义出现于《设计模式》(Addison-Wesley,1994) 工厂方法模式：定义创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到其子类。 工厂方法模式的类图如下： 工厂方法也成为虚构造器(virtual constructor)。它适用于这种情况：一个类无法预期需要生成哪个类的对象，想让其子类来指定所生成的对象。 抽象的Product(产品)定义了工厂方法创建的对象的接口。ConcreteProduct实现了Product接口。Creator定义了返回Product对象的工厂方法。它也可以为工厂方法定义一个默认实现，返回默认ConcreteProduct对象。Creator的其他操作可以调用此工厂方法创建Product对象。ConcreteProduct是creator的子类。它重载了工厂方法，以返回ConcreteProduct的实例。 工厂方法的最初定义好像专注于让子类决定创建什么对象。有一种变体，抽象类使用工厂方法创建其私有子类或者任何其他类的对象(抽象工厂模式)。(接下来的文章会详细描述抽象工厂模式) 何时使用工厂方法模式？在以下情形，你自然会想到使用工厂方法模式： 编译时无法确定预期要创建的对象的类； 类想让其子类决定是在运行时创建什么； 类有若干辅助类为其子类，而你想将返回哪个子类这一信息局部化。 在Cocoa Touch框架中应用工厂方法工厂方法在Cocoa Touch框架中几乎随处可见。大家知道常见的两步对象创建法[[SomeClass alloc] init]。有时，我们会注意到有一些“便利”方法返回类的实例。例如，NSNumber有很多numberWith*方法，其中有两个是numberWithBool:和numbberWithChar:。它们是类方法，也就是说，我们向NSNumber发送[NSNumber numberWithBool:bool]与[NSNumber numbberWithChar:char],以获得与传入参数同类型的各种NSNumber实例。与如何创建NSNumber的具体实例有关的所有细节，都是 由NSNumber的类工厂方法负责。 [NSNumber numberWithBool:bool]的情况是，方法接受值bool，并把NSNumber的内部子类(实际上是NSCFBoolean类)的一个实例初始化，让他能够反映传入的值bool. 附上工厂方法模式的Demo：DesignPattern_FactoryMethod]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--原型模式]]></title>
    <url>%2F2017%2F07%2F02%2FDesignPattern_Prototype%2F</url>
    <content type="text"><![CDATA[原型模式(prototype) 原型模式最初的定义出现于《设计模式》(Addison-Wesley,1994) 原型模式：使用原型实例指定创建对象的种类。并通过复制这个原型创建新的对象。 原型模式的类图如下： 原型模式是一种非常简单的设计模式。客户端知道抽象Prototype类，在运行时，抽象Prototype子类的任何对象都可以按客户端的意愿被复制。因此，无需手工创建就可以制造同意类型的多个实例。 Prototype声明了复制自身的接口。作为Prototype的子类，ConcretePrototype实现了Concrete复制自身的clone操作。 这里，客户端通过请求原型复制其自身，创建了一个新的对象。 何时使用原型模式？在以下情形，会考虑使用原型模式： 需要创建的对象独立于其类型与创建的方式； 实例化的类是在运行时决定的； 不想要与产品层次相对应的工厂层次； 不同类的实例间的差异仅是状态的若干组合，这样复制相应数量的原型比手工实例化更加方便； 类不容易创建，比如每个组件可把其他组件作为子节点的组合对象，复制已有的组合对象并对副本进行修改会更加容易。 使用Cocoa Touch框架中的对象复制 值得注意的是：浅复制与深复制的区别 浅复制只是复制了对象的指针，而同时指向相同的对象资源，也就是说只是复制了栈里面的内容，而同时指向相同的堆空间。改变其对象值得时候，复制对象间会相互影响。 深复制是同时复制对象的指针跟对象本身，也就是同时复制了堆栈空间的内容。 Cocoa Touch框架为NSObject的派生类提供了实现深复制的协议。NSObject的子类需要实现NSCopying协议及其方法-(id)copyWithZone:(NSZone *)zone。NSObject有一个实例方法叫-(id)copy。默认的copy方法调用[self copyWithZone:nil]。对于采纳了NSCopying协议的子类，需要实现这个方法。否则将引发异常。iOS中，这个方法保持新的副本对象，然后将其返回。 附上原型模式的Demo：DesignPattern_Prototype]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一行命令搞定node.js升级]]></title>
    <url>%2F2017%2F06%2F25%2Fnode_update%2F</url>
    <content type="text"><![CDATA[node有一个模块叫n，是专门用来管理node.js的版本的。 首先安装n模块： 1npm install -g n 第二步：升级node.js到最新稳定版 1n stable 完工！是不是很简单？！n后面也可以跟随版本号比如： 123n v0.10.26或n 0.10.26 就这么简单…]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行常用命令--软连接]]></title>
    <url>%2F2017%2F06%2F23%2FcommandLine_softconnection%2F</url>
    <content type="text"><![CDATA[比如，想要用命令行指定特定程序打开文件。 如果文件已被指定默认程序： 1open httpd.conf 指定一个特定程序打开文件 12# 用 sublime text 打开 httpd.confopen -a /Applications/Sublime\ Text.app/ httpd.conf 如果使用频繁，还可以添加软连接 1sudo ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/bin/sublime 输入sublime httpd.conf就可以用 sublime text 打开文件 mac Mac OS X 11之后的版本，上述操作你可能会遇到下面的问题：1ln: /usr/bin/sublime: Operation not permitted 使用管理员sudo命令,依旧失败! 原来MacOS 10.11开始apple引入了Rootless机制,你再也不能随心所欲的改写很多关键路径了,就算你是Root用户也不行,除非是Apple自身签名的软件（含命令行工具）才可以!用Apple的话来说: Rootless机制将成为对抗恶意程序的最后防线。 Mac OS X 11中的/usr/bin 的“Operation not permitted” 如果要关闭Rootless必须重启Mac进入恢复模式,然而关闭它意味着你的MacOS安全大门变得有些薄弱,这并不是什么好消息!!!!! 那么有没有什么办法即可以不用关闭Rootless又可以设置Sublime Text3的快捷方式呢!? 答案是:必须的!!! 我们只需要将其路径添加到/usr/local/bin下即可,Rootless并没有限制该目录的修改,而且bash也会从该目录中寻找可执行的bin!YES!!!1sudo ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/sublime]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>常用命令</tag>
        <tag>软连接</tag>
        <tag>Open File</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIImageView添加圆角的几种方法]]></title>
    <url>%2F2017%2F06%2F22%2FUIImageView_layer_corner%2F</url>
    <content type="text"><![CDATA[创建一个UIImageView对象：1UIImageView * poImgView = [[UIImageView alloc] init]; 第一种方法 123poImgView.layer.cornerRadius = poImgView.frame.size.width/2.0;poImgView.layer.masksToBounds = YES;（或者 poImgView.clipsToBounds = YES;） clipsToBounds是对view的切割，masksToBounds是对layer的切割。 性能消耗：这个是离屏渲染（off-screen-rendering），对性能消耗比较大。fps大致在45帧左右（每个cell 做2个imageview）（正常fps是60帧，越小，用户体验越差）。 离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。由上面的一个结论视图和圆角的大小对帧率并没有什么卵影响，数量才是伤害的核心输出啊。可以知道离屏渲染耗时是发生在离屏这个动作上面，而不是渲染。为什么离屏这么耗时？原因主要有创建缓冲区和上下文切换。创建新的缓冲区代价都不算大，付出最大代价的是上下文切换。 第二种方法 1234CAShapeLayer *layer = [CAShapeLayer layer];UIBezierPath *aPath = [UIBezierPath bezierPathWithOvalInRect:aImageView.bounds];layer.path = aPath.CGPath;poImgView.layer.mask = layer; 性能消耗：测试fps大致在20帧左右，比方案A的消耗更大。 第三种方法 12345678910- (UIImage *)imageWithCornerRadius:(CGFloat)radius &#123; CGRect rect = (CGRect)&#123;0.f, 0.f, self.size&#125;; UIGraphicsBeginImageContextWithOptions(self.size, NO, UIScreen.mainScreen.scale); CGContextAddPath(UIGraphicsGetCurrentContext(),[UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath); CGContextClip(UIGraphicsGetCurrentContext()); [self drawInRect:rect]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 性能消耗：这个是on-screen-rendering相当于时时去做渲染，相比于A.B方案的离线渲染，此方法对性能消耗最低，推荐用此方案。 值得一提第一种跟第二种方法都是比较常见的方式，但是都不推荐，对此的优化方案是是用第三种方式，但是如果非要使用第一种跟第二种，补救措施是： 12self.layer.shouldRasterize = YES;self.layer.rasterizationScale = [UIScreen mainScreen].scale; 当shouldRasterize设成true时，layer被渲染成一个bitmap，并缓存起来，等下次使用时不会再重新去渲染了。 实现圆角本身就是在做颜色混合（blending），如果每次页面出来时都blending，消耗太大，这时shouldRasterize = yes，下次就只是简单的从渲染引擎的cache里读取那张bitmap，节约系统资源。 如果在滚动tableView时，每次都执行圆角设置，肯定会阻塞UI，设置这个将会使滑动更加流畅。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>UIImageView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD：串行/并行/主队列下，同步/异步的执行方式]]></title>
    <url>%2F2017%2F06%2F22%2FGCD_syn_asyn%2F</url>
    <content type="text"><![CDATA[GCD中获取各种类型的队列：12345678//获取串行的队列 dispatch_queue_t singalQueue = dispatch_queue_create("single",DISPATCH_QUEUE_SERIAL);//获取并发执行的队列dispatch_queue_t concrtQueue = dispatch_queue_create("queue", DISPATCH_QUEUE_CONCURRENT);//获取主队列dispatch_queue_t mainQueue = dispatch_get_main_queue();//获取全局的队列（并发的）dispatch_queue_t gobalqueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 串行队列异步执行任务 异步具有创建新线程的能力，会开辟新线程去执行任务； 按照串行的方式去执行任务。 如下调用方式可参考：123456- (void)singalAsynQueue&#123; //创建串行队列 dispatch_queue_t singalQueue = dispatch_queue_create("singal", DISPATCH_QUEUE_SERIAL); //在singalQueue中异步执行任务(该方法实现在本文后续中) [self asynWithQueue: singalQueue]; &#125; 串行队列同步执行任务 同步不具有创建新的线程的能力， 不会开辟新的线程去执行任务，会在当前的程序的主线程中去执行任务； 按照串行的方式去执行任务。 如下调用方式可参考：123456- (void)singalSynQueue&#123; //创建串行队列 dispatch_queue_t singalQueue = dispatch_queue_create("singal", DISPATCH_QUEUE_SERIAL); //在singalQueue中同步执行任务(该方法实现在本文后续中) [self synWithQueue: singalQueue];&#125; 并发队列异步执行任务（常用） 异步具有创建新的线程的能力，会开辟新的线程去执行任务，不会在当前的程序的主线程中去执行任务； 按照并发的方式去执行任务。 如下调用方式可参考：12345678- (void)concrtAsynQueue&#123; //创建并发执行的队列// dispatch_queue_t concrtQueue = dispatch_queue_create("concrtQueue", DISPATCH_QUEUE_CONCURRENT); //获取全局的队列 dispatch_queue_t concrtQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //在concrtQueue中异步执行任务(该方法实现在本文后续中) [self asynWithQueue:concrtQueue];&#125; 并发队列同步执行任务 同步不具有创建新的线程的能力， 不会开辟新的线程去执行任务，会在当前的程序的主线程中去执行任务； 按照同步的方式去执行任务。 如下调用方式可参考：12345678- (void)concrtSynQueue&#123; //创建并发执行的队列// dispatch_queue_t concrtQueue = dispatch_queue_create("concrtQueue", DISPATCH_QUEUE_CONCURRENT); //获取全局的队列 dispatch_queue_t concrtQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //在concrtQueue中同步执行任务(该方法实现在本文后续中) [self synWithQueue:concrtQueue];&#125; 主队列的同步(会造成程序的死锁) 如下：123456- (void)mainSynQueue&#123; //获取主队列 dispatch_queue_t mainQueue = dispatch_get_main_queue(); //在mainQueue中同步执行任务(该方法实现在本文后续中) [self synWithQueue:mainQueue];&#125; 主队列的异步(在主线程中顺序执行) 新添加到主队列中的任务会放到队列的最尾部，等到当前主线程中的任务结束之后然后再从队列的头部取出依次执行（FIFO）先进先出。 如下调用方式可参考：123456- (void)mainAsynQueue&#123; //获取主队列 dispatch_queue_t mainQueue = dispatch_get_main_queue(); //在mainQueue中异步执行任务(该方法实现在本文后续中) [self asynWithQueue:mainQueue]; &#125; 异步方法的实现123456789101112131415161718192021- (void)asynWithQueue:(dispatch_queue_t)queue&#123; NSLog(@"%@",[NSThread currentThread]); dispatch_async(queue, ^&#123; NSLog(@"----1----%@",[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@"----2----%@",[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@"----3----%@",[NSThread currentThread]); &#125;); dispatch_async(queue, ^&#123; NSLog(@"----4----%@",[NSThread currentThread]); &#125;); NSLog(@"--------end------------");&#125; 同步方法的实现123456789101112131415161718192021- (void)synWithQueue:(dispatch_queue_t)queue&#123; NSLog(@"%@",[NSThread currentThread]); dispatch_sync(queue, ^&#123; NSLog(@"----1----%@",[NSThread currentThread]); &#125;); dispatch_sync(queue, ^&#123; NSLog(@"----2----%@",[NSThread currentThread]); &#125;); dispatch_sync(queue, ^&#123; NSLog(@"----3----%@",[NSThread currentThread]); &#125;); dispatch_sync(queue, ^&#123; NSLog(@"----4----%@",[NSThread currentThread]); &#125;); NSLog(@"--------end------------");&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
</search>