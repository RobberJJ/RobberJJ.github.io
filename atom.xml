<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ro.bber</title>
  <subtitle>Road endless its long and far, I will seek up and down.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://robberjj.github.io/"/>
  <updated>2018-12-03T07:04:51.857Z</updated>
  <id>https://robberjj.github.io/</id>
  
  <author>
    <name>Ro.bber</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift Tips - 简单实用的特殊标记（MAKE &amp; TODO &amp; FIXME）</title>
    <link href="https://robberjj.github.io/2018/12/03/Swift-Tips-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8%E7%9A%84%E7%89%B9%E6%AE%8A%E6%A0%87%E8%AE%B0-MAKE-TODO-FIXME/"/>
    <id>https://robberjj.github.io/2018/12/03/Swift-Tips-简单实用的特殊标记-MAKE-TODO-FIXME/</id>
    <published>2018-12-03T06:45:23.000Z</published>
    <updated>2018-12-03T07:04:51.857Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们在代码编写过程中，为了更好的理解，亦或是为了其他的目的，而希望可以通过简单的方式，迅速的完成标记。</p>
<p>在我们熟悉的 <code>OC</code> 中我们有两种标记方式：</p>
<p>其中一种是 <code>#pragram mark - xxx</code> 方式。</p>
<a id="more"></a>
<p>而另一种是下面这种：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// <span class="doctag">TODO:</span> 标示处有功能代码待编写，使用方法：// <span class="doctag">TODO:</span></span></div><div class="line"><span class="comment">// <span class="doctag">FIXME:</span> 标示处代码需要修正，使用方法：// <span class="doctag">FIXME:</span></span></div><div class="line"><span class="comment">// !!!: 标示处代码需要注意，使用方法：// !!!:</span></div><div class="line"><span class="comment">// ???: 标示处代码有疑问，使用方法：// ???:</span></div><div class="line"><span class="comment">// MARK: 标记，和#pragma mark效果相同，使用方法：// MARK:</span></div></pre></td></tr></table></figure>
<p>当然，我们也是可以加上分割线<code>-</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// <span class="doctag">TODO:</span> - 标示处有功能代码待编写，使用方法：// <span class="doctag">TODO:</span></span></div><div class="line"><span class="comment">// <span class="doctag">FIXME:</span> - 标示处代码需要修正，使用方法：// <span class="doctag">FIXME:</span></span></div><div class="line"><span class="comment">// !!!: - 标示处代码需要注意，使用方法：// !!!:</span></div><div class="line"><span class="comment">// ???: - 标示处代码有疑问，使用方法：// ???:</span></div><div class="line"><span class="comment">// MARK: - 标记，和#pragma mark效果相同，使用方法：// MARK:</span></div><div class="line"></div><div class="line"><span class="comment">// MARK: -</span></div></pre></td></tr></table></figure>
<p>在Xcode 10上展示可谓是由很好的颜值&amp;清晰度：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6080248-bb1ae0741489ab84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6944660C-17FF-4ADB-B5FF-D4AA694C2633.png"></p>
<p>但是，在swift中，<code>#pragram mark - xxx</code> 的方式并不能被编译器识别，万幸的是另外一种中的 <code>MARK:</code> &amp; <code>TODO:</code> &amp; <code>FIXME:</code> 依旧还是可以使用的。（包括可以加上分割线 <code>-</code> ）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6080248-9708ac3a3d3728ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="41F87AD0-34E6-4B0E-8308-386D5B49CABC.png"></p>
<p>可以看到，根据在代码中标记的位置，可以清晰的显示出对应的层次。</p>
<p>啊哈！以上。</p>
<p>希望以上可以对你有些帮助。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常我们在代码编写过程中，为了更好的理解，亦或是为了其他的目的，而希望可以通过简单的方式，迅速的完成标记。&lt;/p&gt;
&lt;p&gt;在我们熟悉的 &lt;code&gt;OC&lt;/code&gt; 中我们有两种标记方式：&lt;/p&gt;
&lt;p&gt;其中一种是 &lt;code&gt;#pragram mark - xxx&lt;/code&gt; 方式。&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="https://robberjj.github.io/categories/swift/"/>
    
    
      <category term="iOS" scheme="https://robberjj.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://robberjj.github.io/tags/Swift/"/>
    
      <category term="Swift Tips" scheme="https://robberjj.github.io/tags/Swift-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Swift Tips - if let/var &amp; guard let/var 全解析</title>
    <link href="https://robberjj.github.io/2018/11/30/Swift-Tips-if-let-var-guard-let-var-%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>https://robberjj.github.io/2018/11/30/Swift-Tips-if-let-var-guard-let-var-全解析/</id>
    <published>2018-11-30T05:57:39.000Z</published>
    <updated>2018-11-30T10:28:30.687Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题引出："><a href="#问题引出：" class="headerlink" title="问题引出："></a>问题引出：</h3><p><em>swift</em> 神奇的引入了一个类型——<em><strong>可选类型（optionals）</strong></em>。</p>
<p>但是，我们要是按照以往（比如OC）的套路在使用可选类型定义的常量的时候，又会让你崩溃抓狂。</p>
<p>因为 <em>swift</em> 是类型安全的语言，所以可选类型的常量在 <code>if</code> 判断之后仍然需要 <em>解包(<code>!</code>)</em> 。如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name: <span class="type">String</span>? = <span class="string">"老王"</span></div><div class="line"><span class="keyword">let</span> age: <span class="type">Int</span>? = <span class="number">10</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> name != <span class="literal">nil</span> &amp;&amp; age != <span class="literal">nil</span> &#123;</div><div class="line">    <span class="built_in">print</span>(name! + <span class="type">String</span>(age!))     <span class="comment">// 输出:老王10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>倘若，你不加上 <code>!</code> ，根本就不会让你编译通过，而，加上呢？又会如此的麻烦。难道优雅的 <em>swift</em> 就没有解决办法吗？</p>
<a id="more"></a>
<p>答案，显然是有的—— <em><strong><code>if let</code></strong></em> 。</p>
<h3 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a><code>if let</code></h3><p> <code>if let</code> 的标准套路：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> constantName = someOptional &#123;</div><div class="line">   <span class="comment">//statements using 'constantName' </span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">// the value of someOptional is not set (or nil).</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>诚如上面的栗子，倘若通过 <code>if let</code> 加以实现，就不需要 <em>解包(<code>!</code>)</em> 的操作了,甚至可以添加多个条件，<code>,</code> 隔开即可:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name: <span class="type">String</span>? = <span class="string">"老王"</span></div><div class="line"><span class="keyword">let</span> age: <span class="type">Int</span>? = <span class="number">10</span></div><div class="line"></div><div class="line"><span class="comment">// if let 连用,判断对象的值是否为'nil'</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> nameNew = name,</div><div class="line">    <span class="keyword">let</span> ageNew = age &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 进入分支后,nameNew 和 ageNew 一定有值</span></div><div class="line">    <span class="built_in">print</span>(nameNew + <span class="type">String</span>(ageNew)) <span class="comment">// 输出:老王10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>需要注意的是：</strong><code>if let</code> 转换的 <em>常量</em> 的作用域只是在 <code>if let {}</code>中。</p>
<h3 id="if-var"><a href="#if-var" class="headerlink" title="if var"></a><code>if var</code></h3><p><code>if var</code> 与 <code>if let</code> 的用法、语法都是基本相同的，唯一的区别是 <code>if var</code> 转换出来是 <em>变量</em> ，并且，这个 <em>变量</em>  在其作用域 <code>{}</code> 内是可以修改其值的。如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name: <span class="type">String</span>? = <span class="string">"老王"</span></div><div class="line"><span class="keyword">let</span> age: <span class="type">Int</span>? = <span class="number">10</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">var</span> nameNew = name,</div><div class="line">    <span class="keyword">let</span> ageNew = age &#123;</div><div class="line">    <span class="comment">// 'var'修饰,可以修改'nameNew'的值,'let'修改的不可以修改</span></div><div class="line">    nameNew = <span class="string">"老李"</span></div><div class="line">    <span class="built_in">print</span>(nameNew + <span class="type">String</span>(ageNew))     <span class="comment">// 输出:老李10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然 <code>if var</code> 在其作用域 <code>{}</code> 内是可以修改其值的，但是问题是，更改的值出了作用域之后就失效了，所以通常在实际开发中，并没有太常用。</p>
<p>到这里，文章开始的问题已经被优雅的 <code>swift</code> 化解了，但是依旧不是很完美，正如上面提到的 <code>if let/var</code> 的缺点：<strong>作用域太狭窄</strong> 。</p>
<p>所以， <code>swift</code> 当然不可能止步于此。</p>
<p><strong>良心推荐：</strong> <em><strong><code>guard let/var</code></strong></em></p>
<h3 id="guard-let-var"><a href="#guard-let-var" class="headerlink" title="guard let/var"></a><code>guard let/var</code></h3><p>我们通常说 <code>guard</code> 是为了守护一定有值。套路如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">guard</span> <span class="keyword">let</span>/<span class="keyword">var</span> constantName = expression <span class="keyword">else</span> &#123; </div><div class="line">    <span class="keyword">return</span> value</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如，上面的栗子我们就可以这么写了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name: <span class="type">String</span>? = <span class="string">"老王"</span></div><div class="line"><span class="keyword">let</span> age: <span class="type">Int</span>? = <span class="number">10</span></div><div class="line"></div><div class="line"><span class="keyword">guard</span> <span class="keyword">let</span> nameNew = name,</div><div class="line">    <span class="keyword">let</span> ageNew = age <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"姓名 或 年龄 为nil"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 代码执行至此, nameNew 和 ageNew 一定有值</span></div><div class="line"><span class="built_in">print</span>(nameNew + <span class="type">String</span>(ageNew))     <span class="comment">// 输出:老王10</span></div></pre></td></tr></table></figure>
<p><code>guard</code> 就保证了它之后的代码相关值是肯定有的。</p>
<p><code>guard</code> 仅在条件为假时运行，并且将通过诸如return，break，continue或thrown之类的控制转移语句退出代码块。它提供的这种 <em>提前退出</em> 意味着更快的执行。</p>
<p>而且，语法上少了一层括号，更简洁一些，不是吗？</p>
<p><strong>更重要的是：</strong> <code>guard let/var</code> 弥补了 <code>if let/var</code> 的缺陷，可以在 <code>{}</code> 以外的地方继续使用甚至修改（<code>var</code>）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name: <span class="type">String</span>? = <span class="string">"老王"</span></div><div class="line"><span class="keyword">let</span> age: <span class="type">Int</span>? = <span class="number">10</span></div><div class="line"></div><div class="line"><span class="keyword">guard</span> <span class="keyword">var</span> nameNew = name,</div><div class="line">    <span class="keyword">let</span> ageNew = age <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 'var'修饰,可以修改'nameNew'的值,'let'修改的不可以修改</span></div><div class="line">    nameNew = <span class="string">"老李"</span></div><div class="line">    <span class="built_in">print</span>(nameNew + <span class="type">String</span>(ageNew))     <span class="comment">// 输出:老李10</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(nameNew + <span class="type">String</span>(ageNew))     <span class="comment">// 输出:老李10</span></div><div class="line"></div><div class="line">nameNew = <span class="string">"老张"</span></div><div class="line"><span class="built_in">print</span>(nameNew + <span class="type">String</span>(ageNew))     <span class="comment">// 输出:老张10</span></div></pre></td></tr></table></figure>
<p>搞定收工！</p>
<p>至此，有没有解决你的疑问了？评论告诉我。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题引出：&quot;&gt;&lt;a href=&quot;#问题引出：&quot; class=&quot;headerlink&quot; title=&quot;问题引出：&quot;&gt;&lt;/a&gt;问题引出：&lt;/h3&gt;&lt;p&gt;&lt;em&gt;swift&lt;/em&gt; 神奇的引入了一个类型——&lt;em&gt;&lt;strong&gt;可选类型（optionals）&lt;/strong&gt;&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;但是，我们要是按照以往（比如OC）的套路在使用可选类型定义的常量的时候，又会让你崩溃抓狂。&lt;/p&gt;
&lt;p&gt;因为 &lt;em&gt;swift&lt;/em&gt; 是类型安全的语言，所以可选类型的常量在 &lt;code&gt;if&lt;/code&gt; 判断之后仍然需要 &lt;em&gt;解包(&lt;code&gt;!&lt;/code&gt;)&lt;/em&gt; 。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;? = &lt;span class=&quot;string&quot;&gt;&quot;老王&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; age: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;? = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; name != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; age != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(name! + &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;(age!))     &lt;span class=&quot;comment&quot;&gt;// 输出:老王10&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;倘若，你不加上 &lt;code&gt;!&lt;/code&gt; ，根本就不会让你编译通过，而，加上呢？又会如此的麻烦。难道优雅的 &lt;em&gt;swift&lt;/em&gt; 就没有解决办法吗？&lt;/p&gt;
    
    </summary>
    
      <category term="swift" scheme="https://robberjj.github.io/categories/swift/"/>
    
    
      <category term="iOS" scheme="https://robberjj.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://robberjj.github.io/tags/Swift/"/>
    
      <category term="Swift Tips" scheme="https://robberjj.github.io/tags/Swift-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Swift Tips - 访问控制(private &amp; fileprivate &amp; internal &amp; public &amp; open)</title>
    <link href="https://robberjj.github.io/2018/11/29/Swift-Tips-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-private-fileprivate-internal-public-open/"/>
    <id>https://robberjj.github.io/2018/11/29/Swift-Tips-访问控制-private-fileprivate-internal-public-open/</id>
    <published>2018-11-29T01:34:30.000Z</published>
    <updated>2018-11-30T05:59:00.212Z</updated>
    
    <content type="html"><![CDATA[<p>在 Swift 语言中，访问修饰符有五种，分别为 <strong>private</strong>，<strong>fileprivate</strong>，<strong>internal</strong>，<strong>public</strong> 和 <strong>open</strong>。</p>
<blockquote>
<p>其中 <strong>fileprivate</strong> 和 <strong>open</strong> 是 Swift 3 新添加的。由于过去 Swift 对于访问权限的控制，不是基于类的，而是基于文件的。这样会有问题，所以 Swift 3 新增了两个修饰符对原来的 <strong>private</strong>、<strong>public</strong> 进行细分。</p>
</blockquote>
<a id="more"></a>
<p>下面分别说说各种修饰符的范围&amp;区别：</p>
<ul>
<li><strong>private</strong>（<em>Class级别</em>）<br><em>private</em> 访问级别所修饰的 <strong>属性</strong> 或者 <strong>方法</strong> 只能在 <strong>当前类</strong> 里访问。<br><strong>注意</strong>：Swift4 中，<strong>extension</strong> 里也可以访问 <em>private</em> 的属性。</li>
</ul>
<ul>
<li><p><strong>fileprivate</strong>（<em>File级别</em>）<br><em>fileprivate</em> 访问级别所修饰的 <strong>属性</strong> 或者 <strong>方法</strong> 在 <strong>当前的 Swift 源文件</strong> 里可以访问。</p>
</li>
<li><p><strong>internal</strong>（<em>Module级别，Default</em>，internal修饰符可写可不写）</p>
<ul>
<li><em>internal</em> 访问级别所修饰的 <strong>属性</strong> 或 <strong>方法</strong> 在源代码所在的 <strong>整个模块</strong> 都可以访问。</li>
<li>如果是框架或者库代码，则在整个 <strong>框架内部</strong> 都可以访问，框架由外部代码所引用时，则不可以访问。</li>
<li>如果是 App 代码，也是在 <strong>整个 App 代码</strong>，也是在 <strong>整个 App 内部</strong> 可以访问。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>public</strong>（<em>开放级别，但是有些限制</em>）<br>可以被 <strong>任何人</strong> 访问。<br><strong>但</strong>，其他 module 中不可以被 <strong>override</strong> &amp; <strong>继承</strong> ，而在 <strong>module</strong> 内可以被 <strong>override</strong> &amp; <strong>继承</strong> 。</p>
</li>
<li><p><strong>open</strong>（<em>开放级别，无限制</em>）<br>可以被 <strong>任何人</strong> 使用，包括 <strong>override</strong> &amp; <strong>继承</strong> 。</p>
</li>
</ul>
<p><strong>总结</strong>，5种修饰符访问权限排序如下：</p>
<p><em><strong>open</strong> &gt; <strong>public</strong> &gt; <strong>interal</strong> &gt; <strong>fileprivate</strong> &gt; <strong>private</strong></em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Swift 语言中，访问修饰符有五种，分别为 &lt;strong&gt;private&lt;/strong&gt;，&lt;strong&gt;fileprivate&lt;/strong&gt;，&lt;strong&gt;internal&lt;/strong&gt;，&lt;strong&gt;public&lt;/strong&gt; 和 &lt;strong&gt;open&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其中 &lt;strong&gt;fileprivate&lt;/strong&gt; 和 &lt;strong&gt;open&lt;/strong&gt; 是 Swift 3 新添加的。由于过去 Swift 对于访问权限的控制，不是基于类的，而是基于文件的。这样会有问题，所以 Swift 3 新增了两个修饰符对原来的 &lt;strong&gt;private&lt;/strong&gt;、&lt;strong&gt;public&lt;/strong&gt; 进行细分。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="swift" scheme="https://robberjj.github.io/categories/swift/"/>
    
    
      <category term="iOS" scheme="https://robberjj.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://robberjj.github.io/tags/Swift/"/>
    
      <category term="Swift Tips" scheme="https://robberjj.github.io/tags/Swift-Tips/"/>
    
  </entry>
  
  <entry>
    <title>Swift Tips - as、as!、as?三种类型转换操作符区别</title>
    <link href="https://robberjj.github.io/2018/11/27/Swift-Tips-as%E3%80%81as-%E3%80%81as-%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%8C%BA%E5%88%AB/"/>
    <id>https://robberjj.github.io/2018/11/27/Swift-Tips-as、as-、as-三种类型转换操作符区别/</id>
    <published>2018-11-27T07:51:51.000Z</published>
    <updated>2018-11-30T05:58:50.610Z</updated>
    
    <content type="html"><![CDATA[<p>这里整理总结下 as、as!、as? 这三种类型转换操作符的异同，以及各自的使用场景。</p>
<h4 id="as使用场合"><a href="#as使用场合" class="headerlink" title="as使用场合"></a>as使用场合</h4><ul>
<li>从派生类转换为基类，向上转型（upcasts）</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Animal</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> cat = <span class="type">Cat</span>()</div><div class="line"></div><div class="line"><span class="keyword">let</span> animal = cat <span class="keyword">as</span> <span class="type">Animal</span></div></pre></td></tr></table></figure>
<ul>
<li>消除二义性，数值类型转换</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> num1 = <span class="number">42</span> <span class="keyword">as</span> <span class="type">CGFloat</span></div><div class="line"><span class="keyword">let</span> num2 = <span class="number">42</span> <span class="keyword">as</span> <span class="type">Int</span></div><div class="line"><span class="keyword">let</span> num3 = <span class="number">42.5</span> <span class="keyword">as</span> <span class="type">Int</span></div><div class="line"><span class="keyword">let</span> num4 = (<span class="number">42</span> / <span class="number">2</span>) <span class="keyword">as</span> <span class="type">Double</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>switch 语句中进行模式匹配<br>如果不知道一个对象是什么类型，你可以通过switch语法检测它的类型，并且尝试在不同的情况下使用对应的类型进行相应的处理。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> animal &#123;</div><div class="line"><span class="keyword">case</span> <span class="keyword">let</span> cat <span class="keyword">as</span> <span class="type">Cat</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"如果是Cat类型对象，则做相应处理"</span>)</div><div class="line"><span class="keyword">case</span> <span class="keyword">let</span> dog <span class="keyword">as</span> <span class="type">Dog</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"如果是Dog类型对象，则做相应处理"</span>)</div><div class="line"><span class="keyword">default</span>: <span class="keyword">break</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="as-使用场合"><a href="#as-使用场合" class="headerlink" title="as!使用场合"></a>as!使用场合</h4><p>向下转型（Downcasting）时使用。由于是强制类型转换，如果转换失败会报 runtime 运行错误。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Animal</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">let</span> animal :<span class="type">Animal</span>  = <span class="type">Cat</span>()</div><div class="line"><span class="keyword">let</span> cat = animal <span class="keyword">as</span>! <span class="type">Cat</span></div></pre></td></tr></table></figure></p>
<h4 id="as-使用场合-1"><a href="#as-使用场合-1" class="headerlink" title="as?使用场合"></a>as?使用场合</h4><p>as? 和 as! 操作符的转换规则完全一样。但 as? 如果转换不成功的时候便会返回一个 nil 对象。成功的话返回可选类型值（optional），需要我们拆包使用。<br>由于 as? 在转换失败的时候也不会出现错误，所以对于如果能确保100%会成功的转换则可使用 as!，否则使用 as?<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> animal:<span class="type">Animal</span> = <span class="type">Cat</span>()</div><div class="line"> </div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> cat = animal <span class="keyword">as</span>? <span class="type">Cat</span>&#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"cat is not nil"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"cat is nil"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里整理总结下 as、as!、as? 这三种类型转换操作符的异同，以及各自的使用场景。&lt;/p&gt;
&lt;h4 id=&quot;as使用场合&quot;&gt;&lt;a href=&quot;#as使用场合&quot; class=&quot;headerlink&quot; title=&quot;as使用场合&quot;&gt;&lt;/a&gt;as使用场合&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;从派生类转换为基类，向上转型（upcasts）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Animal&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Cat&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;Animal&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; cat = &lt;span class=&quot;type&quot;&gt;Cat&lt;/span&gt;()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; animal = cat &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Animal&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;消除二义性，数值类型转换&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; num1 = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;CGFloat&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; num2 = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; num3 = &lt;span class=&quot;number&quot;&gt;42.5&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; num4 = (&lt;span class=&quot;number&quot;&gt;42&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="swift" scheme="https://robberjj.github.io/categories/swift/"/>
    
    
      <category term="iOS" scheme="https://robberjj.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://robberjj.github.io/tags/Swift/"/>
    
      <category term="Swift Tips" scheme="https://robberjj.github.io/tags/Swift-Tips/"/>
    
  </entry>
  
  <entry>
    <title>grep命令常用参数</title>
    <link href="https://robberjj.github.io/2018/09/26/GrepCommonParams/"/>
    <id>https://robberjj.github.io/2018/09/26/GrepCommonParams/</id>
    <published>2018-09-26T06:39:50.000Z</published>
    <updated>2018-11-08T04:18:54.498Z</updated>
    
    <content type="html"><![CDATA[<p><code>-A num, --after-context=num</code> - 打印出找到的匹配行后num行。这个跟-B，-C类似功能，主要用于查看上下文。</p>
<p><code>-B num, --before-context=num</code> - 打印出找到的匹配行前num行。</p>
<p><code>-C[num, --context=num]</code> - 打印出找到的匹配行前后num行，相当于-A num -B num。<br><a id="more"></a> </p>
<p><code>-c, --count</code> - 统计出匹配的总行数，同一行有两个匹配也只算一行。</p>
<p><code>--colour=[when, --color=[when]]</code> - 将匹配的字符标记为彩色，when可以是’never’，‘auto’或’always’。</p>
<p><code>-e pattern, --regexp=pattern</code> - 制定在搜索中使用的匹配模式，多用于指定多个匹配模式的情况。</p>
<p><code>-H</code> - 在每一行前面打印出匹配的文件名，在多个文件的情况下这个是默认选项。</p>
<p><code>-h</code> - 在多个文件的情况下不打印出匹配的文件名。</p>
<p><code>-n</code> - 打印出匹配所在行的行数。</p>
<p><code>-i, --ignore-case</code> - 查找时忽略大小写。</p>
<p><code>-R, -r, --recursive</code> - 递归的去查找子目录下的文件。</p>
<p><code>-v, --invert-match</code> - 打印出不匹配的行。</p>
<p><code>-w, --word-regexp</code> - 只匹配整个单词。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;-A num, --after-context=num&lt;/code&gt; - 打印出找到的匹配行后num行。这个跟-B，-C类似功能，主要用于查看上下文。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-B num, --before-context=num&lt;/code&gt; - 打印出找到的匹配行前num行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-C[num, --context=num]&lt;/code&gt; - 打印出找到的匹配行前后num行，相当于-A num -B num。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://robberjj.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="grep" scheme="https://robberjj.github.io/tags/grep/"/>
    
  </entry>
  
  <entry>
    <title>git clone --depth=1之后拉取其他分支</title>
    <link href="https://robberjj.github.io/2018/09/25/GitDepthOtherBr/"/>
    <id>https://robberjj.github.io/2018/09/25/GitDepthOtherBr/</id>
    <published>2018-09-25T08:25:50.000Z</published>
    <updated>2018-11-08T04:19:09.946Z</updated>
    
    <content type="html"><![CDATA[<p>当项目过大时，<code>git clone</code>会出现超时失败，这时候我们可以只拉去最新的一次或者几次<code>commit</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone --depth=1 xxxxxx</div></pre></td></tr></table></figure>
<p>有时候，我们总是图一时之快，而忽略了其他的问题。</p>
<a id="more"></a> 
<p>你可能很快会发现，拉下来的只是默认的分支，而要想拉取其他分支代码的时候，一脸懵逼，有木有？？</p>
<p>其实也很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git remote set-branches origin &apos;remote_branch_name&apos;</div><div class="line">$ git fetch --depth 1 origin remote_branch_name</div><div class="line">$ git checkout remote_branch_name</div></pre></td></tr></table></figure></p>
<p>搞定收工。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当项目过大时，&lt;code&gt;git clone&lt;/code&gt;会出现超时失败，这时候我们可以只拉去最新的一次或者几次&lt;code&gt;commit&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git clone --depth=1 xxxxxx&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有时候，我们总是图一时之快，而忽略了其他的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://robberjj.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="git" scheme="https://robberjj.github.io/tags/git/"/>
    
      <category term="depth" scheme="https://robberjj.github.io/tags/depth/"/>
    
      <category term="分支" scheme="https://robberjj.github.io/tags/%E5%88%86%E6%94%AF/"/>
    
      <category term="clone" scheme="https://robberjj.github.io/tags/clone/"/>
    
  </entry>
  
  <entry>
    <title>Vim一次复制，多次粘贴</title>
    <link href="https://robberjj.github.io/2018/09/08/VimOneCopyMutablePaste/"/>
    <id>https://robberjj.github.io/2018/09/08/VimOneCopyMutablePaste/</id>
    <published>2018-09-08T06:09:50.000Z</published>
    <updated>2018-11-08T04:19:19.380Z</updated>
    
    <content type="html"><![CDATA[<p>我们平常在使用Vim时候，通过<code>viwy</code>或者<code>yy</code>等复制操作之后，<code>p</code>操作粘贴的时候，只能粘贴一次，想要粘贴多次怎么办？</p>
<blockquote>
<p>解决方案：在使用<code>p</code>的是时候使用<code>&quot;0p</code>，这样就能无限制的一直粘贴了。</p>
</blockquote>
<p>可是，为什么呢？</p>
<a id="more"></a> 
<p>因为，寄存器位置<code>0</code>的地方存放的就是最近复制的内容。（使用<code>:reg</code>可以查看寄存器存储列表）</p>
<p>类似的使用<code>xxp</code>就能粘贴相应位置的内容了。（<code>xx</code>标识reg列表前面的序号）</p>
<p>哈哈，是不是很神奇？！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们平常在使用Vim时候，通过&lt;code&gt;viwy&lt;/code&gt;或者&lt;code&gt;yy&lt;/code&gt;等复制操作之后，&lt;code&gt;p&lt;/code&gt;操作粘贴的时候，只能粘贴一次，想要粘贴多次怎么办？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;解决方案：在使用&lt;code&gt;p&lt;/code&gt;的是时候使用&lt;code&gt;&amp;quot;0p&lt;/code&gt;，这样就能无限制的一直粘贴了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可是，为什么呢？&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://robberjj.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="vim" scheme="https://robberjj.github.io/tags/vim/"/>
    
      <category term="copy" scheme="https://robberjj.github.io/tags/copy/"/>
    
      <category term="复制" scheme="https://robberjj.github.io/tags/%E5%A4%8D%E5%88%B6/"/>
    
      <category term="粘贴" scheme="https://robberjj.github.io/tags/%E7%B2%98%E8%B4%B4/"/>
    
  </entry>
  
  <entry>
    <title>Html/Xml中的转义字符</title>
    <link href="https://robberjj.github.io/2018/08/29/CharTransferred/"/>
    <id>https://robberjj.github.io/2018/08/29/CharTransferred/</id>
    <published>2018-08-29T10:06:50.000Z</published>
    <updated>2018-11-08T04:19:24.026Z</updated>
    
    <content type="html"><![CDATA[<p>HTML中的转义字符<br>　HTML中&lt;, &gt;，&amp;等有特殊含义，(前两个字符用于链接签，&amp;用于转义)，不能直接使用。使用这三个字符时，应使用它们的转义序列，如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">转义字符</th>
<th style="text-align:center">源字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;amp; 或 &amp;</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">和</td>
</tr>
<tr>
<td style="text-align:center">&amp;lt; 或 &lt;</td>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于号</td>
</tr>
<tr>
<td style="text-align:center">&amp;gt; 或 &gt;</td>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于号</td>
</tr>
<tr>
<td style="text-align:center">&amp;quot;</td>
<td style="text-align:center">“</td>
<td style="text-align:center">双引号</td>
</tr>
<tr>
<td style="text-align:center">&amp;nbsp;</td>
<td style="text-align:center"></td>
<td style="text-align:center">空格</td>
</tr>
<tr>
<td style="text-align:center">&amp;copy;</td>
<td style="text-align:center">©</td>
<td style="text-align:center">版权符</td>
</tr>
<tr>
<td style="text-align:center">&amp;reg</td>
<td style="text-align:center">®</td>
<td style="text-align:center">注册符</td>
</tr>
</tbody>
</table>
<a id="more"></a> 
<blockquote>
<p>需要说明的是：<br>   a. 转义序列各字符间不能有空格；<br>   b. 转义序列必须以”；”结束；<br>   c. 单独的&amp;不被认为是转义开始；<br>   d. 区分大小写。</p>
</blockquote>
<p>XML转义字符<br>       不合法的XML字符必须被替换为相应的实体。<br>　　下面是五个在XML文档中预定义好的实体：</p>
<table>
<thead>
<tr>
<th style="text-align:center">转义字符</th>
<th style="text-align:center">源字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;amp;</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">和</td>
</tr>
<tr>
<td style="text-align:center">&amp;lt; 或 &lt;</td>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于号</td>
</tr>
<tr>
<td style="text-align:center">&amp;gt; 或 &gt;</td>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于号</td>
</tr>
<tr>
<td style="text-align:center">&amp;quot;</td>
<td style="text-align:center">“</td>
<td style="text-align:center">双引号</td>
</tr>
<tr>
<td style="text-align:center">&amp;quot;</td>
<td style="text-align:center">‘</td>
<td style="text-align:center">单引号</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意: 只有”&lt;” 字符和”&amp;”字符对于XML来说是严格禁止使用的。剩下的都是合法的，为了减少出错，使用实体是一个好习惯。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML中的转义字符&lt;br&gt;　HTML中&amp;lt;, &amp;gt;，&amp;amp;等有特殊含义，(前两个字符用于链接签，&amp;amp;用于转义)，不能直接使用。使用这三个字符时，应使用它们的转义序列，如下所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;转义字符&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;源字符&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&amp;amp;amp; 或 &amp;amp;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&amp;amp;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;和&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&amp;amp;lt; 或 &amp;lt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&amp;lt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;小于号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&amp;amp;gt; 或 &amp;gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&amp;gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;大于号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&amp;amp;quot;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;“&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;双引号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&amp;amp;nbsp;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&amp;amp;copy;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;©&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;版权符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&amp;amp;reg&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;®&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;注册符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://robberjj.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Html" scheme="https://robberjj.github.io/tags/Html/"/>
    
      <category term="xml" scheme="https://robberjj.github.io/tags/xml/"/>
    
      <category term="转义" scheme="https://robberjj.github.io/tags/%E8%BD%AC%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>iOS编码规范</title>
    <link href="https://robberjj.github.io/2018/08/08/iOSEncoding/"/>
    <id>https://robberjj.github.io/2018/08/08/iOSEncoding/</id>
    <published>2018-08-08T09:25:50.000Z</published>
    <updated>2018-11-08T04:19:30.281Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文档旨在总结出一份通用的编码规范，欢迎随时探讨补充。</p>
</blockquote>
<a id="more"></a> 
<h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><ul>
<li>不要在工程里使用Tab键，使用空格来进行缩进。在Xcode &gt; Preferences &gt; Text Editing将Tab和自动缩进都设置为4个空格。（Google的标准是使用两个空格来缩进，但这里还是推荐使用Xcode默认的设置。）</li>
<li>方法之间应该要有一个空行来帮助代码看起来清晰且有组织。 方法内的空行应该用来分离功能，但是通常不同的功能应该用新的方法来定义。</li>
</ul>
<h4 id="方法的书写"><a href="#方法的书写" class="headerlink" title="方法的书写"></a>方法的书写</h4><p>一个典型的Objective-C函数应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)writeVideoFrameWithData:(NSData *)frameData timeStamp:(int)timeStamp &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>-</code>和<code>(void)</code>之间应该有一个空格，第一个大括号<code>{</code>的位置在函数所在行的末尾，同样应该有一个空格。</p>
<blockquote>
<p>在使用<code>{</code>的位置都遵循<a href="https://en.wikipedia.org/wiki/Indent_style#K.26R_style" target="_blank" rel="external">Egyptian风格</a> (又称 K&amp;R 风格，代码段括号的开始位于一行的末尾，而不是另外起一行的风格。)，比如，控制语句 (if-else, for, switch)。</p>
</blockquote>
<p>如果一个函数有特别多的参数或者名称很长，应该将其按照<code>:</code>来对齐分行显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-(id)initWithModel:(IPCModle)model</div><div class="line">       ConnectType:(IPCConnectType)connectType</div><div class="line">        Resolution:(IPCResolution)resolution</div><div class="line">          AuthName:(NSString *)authName</div><div class="line">          Password:(NSString *)password</div><div class="line">               MAC:(NSString *)mac</div><div class="line">              AzIp:(NSString *)az_ip</div><div class="line">             AzDns:(NSString *)az_dns</div><div class="line">             Token:(NSString *)token</div><div class="line">             Email:(NSString *)email</div><div class="line">          Delegate:(id&lt;IPCConnectHandlerDelegate&gt;)delegate;</div></pre></td></tr></table></figure>
<p>在分行时，如果第一段名称过短，后续名称可以以Tab的长度（4个空格）为单位进行缩进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)short:(GTMFoo *)theFoo</div><div class="line">        longKeyword:(NSRect)theRect</div><div class="line">  evenLongerKeyword:(float)theInterval</div><div class="line">              error:(NSError **)theError &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>函数调用的格式和书写差不多，可以按照函数的长短来选择写在一行或者分成多行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//写在一行</div><div class="line">[myObject doFooWith:arg1 name:arg2 error:arg3];</div><div class="line"></div><div class="line">//分行写，按照&apos;:&apos;对齐</div><div class="line">[myObject doFooWith:arg1</div><div class="line">               name:arg2</div><div class="line">              error:arg3];</div><div class="line"></div><div class="line">//第一段名称过短的话后续可以进行缩进</div><div class="line">[myObj short:arg1</div><div class="line">          longKeyword:arg2</div><div class="line">    evenLongerKeyword:arg3</div><div class="line">                error:arg4];</div></pre></td></tr></table></figure>
<h4 id="public和-private标记符"><a href="#public和-private标记符" class="headerlink" title="@public和@private标记符"></a>@public和@private标记符</h4><p>@public和@private标记符应该以<strong>一个空格</strong>来进行缩进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@interface MyClass : NSObject &#123;</div><div class="line"> @public</div><div class="line">  ...</div><div class="line"> @private</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="协议（Protocols）"><a href="#协议（Protocols）" class="headerlink" title="协议（Protocols）"></a>协议（Protocols）</h4><p>在书写协议的时候注意用<code>&lt;&gt;</code>括起来的协议和类型名之间是没有空格的，比如<code>IPCConnectHandler()&lt;IPCPreconnectorDelegate&gt;</code>,这个规则适用所有书写协议的地方，包括函数声明、类声明、实例变量等等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@interface MyProtocoledClass : NSObject&lt;NSWindowDelegate&gt; &#123;</div><div class="line"> @private</div><div class="line">    id&lt;MyFancyDelegate&gt; _delegate;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setDelegate:(id&lt;MyFancyDelegate&gt;)aDelegate;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="闭包（Blocks）"><a href="#闭包（Blocks）" class="headerlink" title="闭包（Blocks）"></a>闭包（Blocks）</h4><p>根据block的长度，有不同的书写规则：</p>
<ul>
<li>较短的block可以写在一行内。</li>
<li>如果分行显示的话，block的右括号<code>}</code>应该和调用block那行代码的第一个非空字符对齐。</li>
<li>block内的代码采用<strong>4个空格</strong>的缩进。</li>
<li>如果block过于庞大，应该单独声明成一个变量来使用。</li>
<li><code>^</code>和<code>(</code>之间，<code>^</code>和<code>{</code>之间都没有空格，参数列表的右括号<code>)</code>和<code>{</code>之间有一个空格。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">//较短的block写在一行内</div><div class="line">[operation setCompletionBlock:^&#123; [self onOperationDone]; &#125;];</div><div class="line"></div><div class="line">//分行书写的block，内部使用4空格缩进</div><div class="line">[operation setCompletionBlock:^&#123;</div><div class="line">    [self.delegate newDataAvailable];</div><div class="line">&#125;];</div><div class="line"></div><div class="line">//使用C语言API调用的block遵循同样的书写规则</div><div class="line">dispatch_async(_fileIOQueue, ^&#123;</div><div class="line">    NSString* path = [self sessionFilePath];</div><div class="line">    if (path) &#123;</div><div class="line">      // ...</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//较长的block关键字可以缩进后在新行书写，注意block的右括号&apos;&#125;&apos;和调用block那行代码的第一个非空字符对齐</div><div class="line">[[SessionService sharedService]</div><div class="line">    loadWindowWithCompletionBlock:^(SessionWindow *window) &#123;</div><div class="line">        if (window) &#123;</div><div class="line">          [self windowDidLoad:window];</div><div class="line">        &#125; else &#123;</div><div class="line">          [self errorLoadingWindow];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">//较长的block参数列表同样可以缩进后在新行书写</div><div class="line">[[SessionService sharedService]</div><div class="line">    loadWindowWithCompletionBlock:</div><div class="line">        ^(SessionWindow *window) &#123;</div><div class="line">            if (window) &#123;</div><div class="line">              [self windowDidLoad:window];</div><div class="line">            &#125; else &#123;</div><div class="line">              [self errorLoadingWindow];</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line"></div><div class="line">//庞大的block应该单独定义成变量使用</div><div class="line">void (^largeBlock)(void) = ^&#123;</div><div class="line">    // ...</div><div class="line">&#125;;</div><div class="line">[_operationQueue addOperationWithBlock:largeBlock];</div><div class="line"></div><div class="line">//在一个调用中使用多个block，注意到他们不是像函数那样通过&apos;:&apos;对齐的，而是同时进行了4个空格的缩进</div><div class="line">[myObject doSomethingWith:arg1</div><div class="line">    firstBlock:^(Foo *a) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">    secondBlock:^(Bar *b) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<h4 id="数据结构的语法糖"><a href="#数据结构的语法糖" class="headerlink" title="数据结构的语法糖"></a>数据结构的语法糖</h4><p>应该使用可读性更好的语法糖来构造<code>NSArray</code>，<code>NSDictionary</code>等数据结构，避免使用冗长的<code>alloc</code>,<code>init</code>方法。</p>
<p>如果构造代码写在一行，需要在括号两端留有一个空格，使得被构造的元素于与构造语法区分开来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//正确，在语法糖的&quot;[]&quot;或者&quot;&#123;&#125;&quot;两端留有空格</div><div class="line">NSArray *array = @[ [foo description], @&quot;Another String&quot;, [bar description] ];</div><div class="line">NSDictionary *dict = @&#123; NSForegroundColorAttributeName : [NSColor redColor] &#125;;</div><div class="line"></div><div class="line">//不正确，不留有空格降低了可读性</div><div class="line">NSArray* array = @[[foo description], [bar description]];</div><div class="line">NSDictionary* dict = @&#123;NSForegroundColorAttributeName: [NSColor redColor]&#125;;</div></pre></td></tr></table></figure>
<p>如果构造代码不写在一行内，构造元素需要使用<strong>两个空格</strong>来进行缩进，右括号<code>]</code>或者<code>}</code>写在新的一行，并且与调用语法糖那行代码的第一个非空字符对齐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[</div><div class="line">  @&quot;This&quot;,</div><div class="line">  @&quot;is&quot;,</div><div class="line">  @&quot;an&quot;,</div><div class="line">  @&quot;array&quot;</div><div class="line">];</div><div class="line"></div><div class="line">NSDictionary *dictionary = @&#123;</div><div class="line">  NSFontAttributeName : [NSFont fontWithName:@&quot;Helvetica-Bold&quot; size:12],</div><div class="line">  NSForegroundColorAttributeName : fontColor</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>构造字典时，字典的Key和Value与中间的冒号<code>:</code>都要留有一个空格，多行书写时，也可以将Value对齐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//正确，冒号&apos;:&apos;前后留有一个空格</div><div class="line">NSDictionary *option1 = @&#123;</div><div class="line">  NSFontAttributeName : [NSFont fontWithName:@&quot;Helvetica-Bold&quot; size:12],</div><div class="line">  NSForegroundColorAttributeName : fontColor</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//正确，按照Value来对齐</div><div class="line">NSDictionary *option2 = @&#123;</div><div class="line">  NSFontAttributeName :            [NSFont fontWithName:@&quot;Arial&quot; size:12],</div><div class="line">  NSForegroundColorAttributeName : fontColor</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//错误，冒号前应该有一个空格</div><div class="line">NSDictionary *wrong = @&#123;</div><div class="line">  AKey:       @&quot;b&quot;,</div><div class="line">  BLongerKey: @&quot;c&quot;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//错误，每一个元素要么单独成为一行，要么全部写在一行内</div><div class="line">NSDictionary *alsoWrong= @&#123; AKey : @&quot;a&quot;,</div><div class="line">                            BLongerKey : @&quot;b&quot; &#125;;</div><div class="line"></div><div class="line">//错误，在冒号前只能有一个空格，冒号后才可以考虑按照Value对齐</div><div class="line">NSDictionary *stillWrong = @&#123;</div><div class="line">  AKey       : @&quot;b&quot;,</div><div class="line">  BLongerKey : @&quot;c&quot;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><h4 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h4><ul>
<li><h5 id="清晰"><a href="#清晰" class="headerlink" title="清晰"></a>清晰</h5></li>
</ul>
<p>命名应该尽可能的清晰和简洁，但在Objective-C中，清晰比简洁更重要。由于Xcode强大的自动补全功能，我们不必担心名称过长的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//清晰</div><div class="line">insertObject:atIndex:</div><div class="line"></div><div class="line">//不清晰，insert的对象类型和at的位置属性没有说明</div><div class="line">insert:at:</div><div class="line"></div><div class="line">//清晰</div><div class="line">removeObjectAtIndex:</div><div class="line"></div><div class="line">//不清晰，remove的对象类型没有说明，参数的作用没有说明</div><div class="line">remove:</div></pre></td></tr></table></figure>
<p>不要使用单词的简写，拼写出完整的单词：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//清晰</div><div class="line">destinationSelection</div><div class="line">setBackgroundColor:</div><div class="line"></div><div class="line">//不清晰，不要使用简写</div><div class="line">destSel</div><div class="line">setBkgdColor:</div></pre></td></tr></table></figure>
<p>然而，有部分单词简写在Objective-C编码过程中是非常常用的，以至于成为了一种规范，这些简写可以在代码中直接使用，下面列举了部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">alloc   == Allocate					max    == Maximum</div><div class="line">alt     == Alternate				min    == Minimum</div><div class="line">app     == Application				msg    == Message</div><div class="line">calc    == Calculate				nib    == Interface Builder archive</div><div class="line">dealloc == Deallocate				pboard == Pasteboard</div><div class="line">func    == Function					rect   == Rectangle</div><div class="line">horiz   == Horizontal				Rep    == Representation (used in class name such as NSBitmapImageRep).</div><div class="line">info    == Information				temp   == Temporary</div><div class="line">init    == Initialize				vert   == Vertical</div><div class="line">int     == Integer</div></pre></td></tr></table></figure>
<p>命名方法或者函数时要避免歧义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//有歧义，是返回sendPort还是send一个Port？</div><div class="line">sendPort</div><div class="line"></div><div class="line">//有歧义，是返回一个名字属性的值还是display一个name的动作？</div><div class="line">displayName</div></pre></td></tr></table></figure>
<ul>
<li><h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h5></li>
</ul>
<p>整个工程的命名风格要保持一致性，最好和苹果SDK的代码保持统一。不同类中完成相似功能的方法应该叫一样的名字，比如我们总是用<code>count</code>来返回集合的个数，不能在A类中使用<code>count</code>而在B类中使用<code>getNumber</code>。</p>
<ul>
<li><h5 id="使用前缀"><a href="#使用前缀" class="headerlink" title="使用前缀"></a>使用前缀</h5></li>
</ul>
<p>如果代码需要打包成Framework给别的工程使用，或者工程项目非常庞大，需要拆分成不同的模块，使用命名前缀是非常有用的。</p>
<ol>
<li>前缀由大写的字母缩写组成，比如Cocoa中<code>NS</code>前缀代表Founation框架中的类，<code>IB</code>则代表Interface Builder框架。</li>
<li>可以在为类、协议、函数、常量以及typedef宏命名的时候使用前缀，但注意<strong>不要</strong>为成员变量或者方法使用前缀，因为他们本身就包含在类的命名空间内。</li>
<li>命名前缀的时候不要和苹果SDK框架冲突。</li>
</ol>
<h4 id="命名类和协议-Class-amp-Protocol"><a href="#命名类和协议-Class-amp-Protocol" class="headerlink" title="命名类和协议(Class &amp; Protocol)"></a>命名类和协议(Class &amp; Protocol)</h4><p>类名以大写字母开头，应该包含一个<em>名词</em>来表示它代表的对象类型，同时可以加上必要的前缀，比如<code>NSString</code>, <code>NSDate</code>, <code>NSScanner</code>, <code>NSApplication</code>等等。</p>
<p>而协议名称应该清晰地表示它所执行的行为，而且要和类名区别开来，所以通常使用<code>ing</code>词尾来命名一个协议，比如<code>NSCopying</code>,<code>NSLocking</code>。</p>
<p>有些协议本身包含了很多不相关的功能，主要用来为某一特定类服务，这时候可以直接用类名来命名这个协议，比如<code>NSObject</code>协议，它包含了id对象在生存周期内的一系列方法。</p>
<h4 id="命名头文件（Headers）"><a href="#命名头文件（Headers）" class="headerlink" title="命名头文件（Headers）"></a>命名头文件（Headers）</h4><p>源码的头文件名应该清晰地暗示它的功能和包含的内容：</p>
<ul>
<li>如果头文件内只定义了单个类或者协议，直接用类名或者协议名来命名头文件，比如<code>NSLocale.h</code>定义了<code>NSLocale</code>类。</li>
<li>如果头文件内定义了一系列的类、协议、类别，使用其中最主要的类名来命名头文件，比如<code>NSString.h</code>定义了<code>NSString</code>和<code>NSMutableString</code>。</li>
<li>每一个Framework都应该有一个和框架同名的头文件，包含了框架中所有公共类头文件的引用，比如<code>Foundation.h</code></li>
<li>Framework中有时候会实现在别的框架中类的类别扩展，这样的文件通常使用<code>被扩展的框架名</code>+<code>Additions</code>的方式来命名，比如<code>NSBundleAdditions.h</code>。</li>
</ul>
<h4 id="命名方法（Methods）"><a href="#命名方法（Methods）" class="headerlink" title="命名方法（Methods）"></a>命名方法（Methods）</h4><p>Objective-C的方法名通常都比较长，这是为了让程序有更好地可读性，按苹果的说法<em>“好的方法名应当可以以一个句子的形式朗读出来”</em>。</p>
<p>方法一般以小写字母打头，每一个后续的单词首字母大写，方法名中不应该有标点符号（<em>包括下划线</em>），有两个例外：</p>
<ul>
<li>可以用一些通用的大写字母缩写打头方法，比如<code>PDF</code>,<code>TIFF</code>等。</li>
<li>可以用带下划线的前缀来命名私有方法或者类别中的方法。</li>
</ul>
<p>如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用<code>do</code>，<code>does</code>这种多余的关键字，动词本身的暗示就足够了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//动词打头的方法表示让对象执行一个动作</div><div class="line">- (void)invokeWithTarget:(id)target;</div><div class="line">- (void)selectTabViewItem:(NSTabViewItem *)tabViewItem;</div></pre></td></tr></table></figure>
<p>如果方法是为了获取对象的一个属性值，直接用属性名称来命名这个方法，注意不要添加<code>get</code>或者其他的动词前缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//正确，使用属性名来命名方法</div><div class="line">- (NSSize)cellSize;</div><div class="line"></div><div class="line">//错误，添加了多余的动词前缀</div><div class="line">- (NSSize)calcCellSize;</div><div class="line">- (NSSize)getCellSize;</div></pre></td></tr></table></figure>
<p>对于有多个参数的方法，务必在每一个参数前都添加关键词，关键词应当清晰说明参数的作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//正确，保证每个参数都有关键词修饰</div><div class="line">- (void)sendAction:(SEL)aSelector toObject:(id)anObject forAllCells:(BOOL)flag;</div><div class="line"></div><div class="line">//错误，遗漏关键词</div><div class="line">- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;</div><div class="line"></div><div class="line">//正确</div><div class="line">- (id)viewWithTag:(NSInteger)aTag;</div><div class="line"></div><div class="line">//错误，关键词的作用不清晰</div><div class="line">- (id)taggedView:(int)aTag;</div></pre></td></tr></table></figure>
<p>不要用<code>and</code>来连接两个参数，通常<code>and</code>用来表示方法执行了两个相对独立的操作（<em>从设计上来说，这时候应该拆分成两个独立的方法</em>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//错误，不要使用&quot;and&quot;来连接参数</div><div class="line">- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;</div><div class="line"></div><div class="line">//正确，使用&quot;and&quot;来表示两个相对独立的操作</div><div class="line">- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;</div></pre></td></tr></table></figure>
<p>方法的参数命名也有一些需要注意的地方:</p>
<ul>
<li>和方法名类似，参数的第一个字母小写，后面的每一个单词首字母大写</li>
<li>不要再方法名中使用类似<code>pointer</code>,<code>ptr</code>这样的字眼去表示指针，参数本身的类型足以说明</li>
<li>不要使用只有一两个字母的参数名</li>
<li>不要使用简写，拼出完整的单词</li>
</ul>
<p>下面列举了一些常用参数名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">...action:(SEL)aSelector</div><div class="line">...alignment:(int)mode</div><div class="line">...atIndex:(int)index</div><div class="line">...content:(NSRect)aRect</div><div class="line">...doubleValue:(double)aDouble</div><div class="line">...floatValue:(float)aFloat</div><div class="line">...font:(NSFont *)fontObj</div><div class="line">...frame:(NSRect)frameRect</div><div class="line">...intValue:(int)anInt</div><div class="line">...keyEquivalent:(NSString *)charCode</div><div class="line">...length:(int)numBytes</div><div class="line">...point:(NSPoint)aPoint</div><div class="line">...stringValue:(NSString *)aString</div><div class="line">...tag:(int)anInt</div><div class="line">...target:(id)anObject</div><div class="line">...title:(NSString *)aString</div></pre></td></tr></table></figure>
<h4 id="存取方法（Accessor-Methods）"><a href="#存取方法（Accessor-Methods）" class="headerlink" title="存取方法（Accessor Methods）"></a>存取方法（Accessor Methods）</h4><p>存取方法是指用来获取和设置类属性值的方法，属性的不同类型，对应着不同的存取方法规范：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//属性是一个名词时的存取方法范式</div><div class="line">- (type)noun;</div><div class="line">- (void)setNoun:(type)aNoun;</div><div class="line">//栗子</div><div class="line">- (NSString *)title;</div><div class="line">- (void)setTitle:(NSString *)aTitle;</div><div class="line"></div><div class="line">//属性是一个形容词时存取方法的范式</div><div class="line">- (BOOL)isAdjective;</div><div class="line">- (void)setAdjective:(BOOL)flag;</div><div class="line">//栗子</div><div class="line">- (BOOL)isEditable;</div><div class="line">- (void)setEditable:(BOOL)flag;</div><div class="line"></div><div class="line">//属性是一个动词时存取方法的范式</div><div class="line">- (BOOL)verbObject;</div><div class="line">- (void)setVerbObject:(BOOL)flag;</div><div class="line">//栗子</div><div class="line">- (BOOL)showsAlpha;</div><div class="line">- (void)setShowsAlpha:(BOOL)flag;</div></pre></td></tr></table></figure>
<p>命名存取方法时不要将动词转化为被动形式来使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//正确</div><div class="line">- (void)setAcceptsGlyphInfo:(BOOL)flag;</div><div class="line">- (BOOL)acceptsGlyphInfo;</div><div class="line"></div><div class="line">//错误，不要使用动词的被动形式</div><div class="line">- (void)setGlyphInfoAccepted:(BOOL)flag;</div><div class="line">- (BOOL)glyphInfoAccepted;</div></pre></td></tr></table></figure>
<p>可以使用<code>can</code>,<code>should</code>,<code>will</code>等词来协助表达存取方法的意思，但不要使用<code>do</code>,和<code>does</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//正确</div><div class="line">- (void)setCanHide:(BOOL)flag;</div><div class="line">- (BOOL)canHide;</div><div class="line">- (void)setShouldCloseDocument:(BOOL)flag;</div><div class="line">- (BOOL)shouldCloseDocument;</div><div class="line"></div><div class="line">//错误，不要使用&quot;do&quot;或者&quot;does&quot;</div><div class="line">- (void)setDoesAcceptGlyphInfo:(BOOL)flag;</div><div class="line">- (BOOL)doesAcceptGlyphInfo;</div></pre></td></tr></table></figure>
<p>为什么Objective-C中不适用<code>get</code>前缀来表示属性获取方法？因为<code>get</code>在Objective-C中通常只用来表示从函数指针返回值的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//三个参数都是作为函数的返回值来使用的，这样的函数名可以使用&quot;get&quot;前缀</div><div class="line">- (void)getLineDash:(float *)pattern count:(int *)count phase:(float *)phase;</div></pre></td></tr></table></figure>
<h4 id="命名委托（Delegate）"><a href="#命名委托（Delegate）" class="headerlink" title="命名委托（Delegate）"></a>命名委托（Delegate）</h4><p>当特定的事件发生时，对象会触发它注册的委托方法。委托是Objective-C中常用的传递消息的方式。委托有它固定的命名范式。</p>
<p>一个委托方法的第一个参数是触发它的对象，第一个关键词是触发对象的类名，除非委托方法只有一个名为<code>sender</code>的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//第一个关键词为触发委托的类名</div><div class="line">- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(int)row;</div><div class="line">- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;</div><div class="line"></div><div class="line">//当只有一个&quot;sender&quot;参数时可以省略类名</div><div class="line">- (BOOL)applicationOpenUntitledFile:(NSApplication *)sender;</div></pre></td></tr></table></figure>
<p>根据委托方法触发的时机和目的，使用<code>should</code>,<code>will</code>,<code>did</code>等关键词</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)browserDidScroll:(NSBrowser *)sender;</div><div class="line"></div><div class="line">- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window;、</div><div class="line"></div><div class="line">- (BOOL)windowShouldClose:(id)sender;</div></pre></td></tr></table></figure>
<h4 id="集合操作类方法（Collection-Methods）"><a href="#集合操作类方法（Collection-Methods）" class="headerlink" title="集合操作类方法（Collection Methods）"></a>集合操作类方法（Collection Methods）</h4><p>有些对象管理着一系列其它对象或者元素的集合，需要使用类似“增删查改”的方法来对集合进行操作，这些方法的命名范式一般为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//集合操作范式</div><div class="line">- (void)addElement:(elementType)anObj;</div><div class="line">- (void)removeElement:(elementType)anObj;</div><div class="line">- (NSArray *)elements;</div><div class="line"></div><div class="line">//栗子</div><div class="line">- (void)addLayoutManager:(NSLayoutManager *)obj;</div><div class="line">- (void)removeLayoutManager:(NSLayoutManager *)obj;</div><div class="line">- (NSArray *)layoutManagers;</div></pre></td></tr></table></figure>
<p>注意，如果返回的集合是无序的，使用<code>NSSet</code>来代替<code>NSArray</code>。如果需要将元素插入到特定的位置，使用类似于这样的命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)insertLayoutManager:(NSLayoutManager *)obj atIndex:(int)index;</div><div class="line">- (void)removeLayoutManagerAtIndex:(int)index;</div></pre></td></tr></table></figure>
<p>如果管理的集合元素中有指向管理对象的指针，要设置成<code>weak</code>类型以防止引用循环。</p>
<p>下面是SDK中<code>NSWindow</code>类的集合操作方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)addChildWindow:(NSWindow *)childWin ordered:(NSWindowOrderingMode)place;</div><div class="line">- (void)removeChildWindow:(NSWindow *)childWin;</div><div class="line">- (NSArray *)childWindows;</div><div class="line">- (NSWindow *)parentWindow;</div><div class="line">- (void)setParentWindow:(NSWindow *)window;</div></pre></td></tr></table></figure>
<h4 id="命名函数（Functions）"><a href="#命名函数（Functions）" class="headerlink" title="命名函数（Functions）"></a>命名函数（Functions）</h4><p>在很多场合仍然需要用到函数，比如说如果一个对象是一个单例，那么应该使用函数来代替类方法执行相关操作。</p>
<p>函数的命名和方法有一些不同，主要是：</p>
<ul>
<li>函数名称一般带有缩写前缀，表示方法所在的框架。</li>
<li>前缀后的单词以“驼峰”表示法显示，第一个单词首字母大写。</li>
</ul>
<p>函数名的第一个单词通常是一个动词，表示方法执行的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSHighlightRect</div><div class="line">NSDeallocateObject</div></pre></td></tr></table></figure>
<p>如果函数返回其参数的某个属性，省略动词：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unsigned int NSEventMaskFromType(NSEventType type)</div><div class="line">float NSHeight(NSRect aRect)</div></pre></td></tr></table></figure>
<p>如果函数通过指针参数来返回值，需要在函数名中使用<code>Get</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const char *NSGetSizeAndAlignment(const char *typePtr, unsigned int *sizep, unsigned int *alignp)</div></pre></td></tr></table></figure>
<p>函数的返回类型是BOOL时的命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL NSDecimalIsNotANumber(const NSDecimal *decimal)</div></pre></td></tr></table></figure>
<h4 id="命名属性和实例变量（Properties-amp-Instance-Variables）"><a href="#命名属性和实例变量（Properties-amp-Instance-Variables）" class="headerlink" title="命名属性和实例变量（Properties&amp;Instance Variables）"></a>命名属性和实例变量（Properties&amp;Instance Variables）</h4><p>属性和对象的存取方法相关联，属性的第一个字母小写，后续单词首字母大写，不必添加前缀。属性按功能命名成名词或者动词：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//名词属性</div><div class="line">@property (strong) NSString *title;</div><div class="line"></div><div class="line">//动词属性</div><div class="line">@property (assign) BOOL showsAlpha;</div></pre></td></tr></table></figure>
<p>属性也可以命名成形容词，这时候通常会指定一个带有<code>is</code>前缀的get方法来提高可读性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (assign, getter=isEditable) BOOL editable;</div></pre></td></tr></table></figure>
<p>命名实例变量，在变量名前加上<code>_</code>前缀（<em>有些有历史的代码会将<code>_</code>放在后面</em>），其它和命名属性一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@implementation MyClass &#123;</div><div class="line">    BOOL _showsTitle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一般来说，类需要对使用者隐藏数据存储的细节，所以不要将实例方法定义成公共可访问的接口，可以使用<code>@private</code>，<code>@protected</code>前缀。</p>
<p><em>按苹果的说法，不建议在除了<code>init</code>和<code>dealloc</code>方法以外的地方直接访问实例变量，但很多人认为直接访问会让代码更加清晰可读，只在需要计算或者执行操作的时候才使用存取方法访问，我就是这种习惯，所以这里不作要求。</em></p>
<h4 id="命名常量（Constants）"><a href="#命名常量（Constants）" class="headerlink" title="命名常量（Constants）"></a>命名常量（Constants）</h4><p>如果要定义一组相关的常量，尽量使用枚举类型（enumerations），枚举类型的命名规则和函数的命名规则相同。<br>建议使用 <code>NS_ENUM</code> 和 <code>NS_OPTIONS</code> 宏来定义枚举类型，参见官方的 <a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html" target="_blank" rel="external">Adopting Modern Objective-C</a> 一文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//定义一个枚举</div><div class="line">typedef NS_ENUM(NSInteger, NSMatrixMode) &#123;</div><div class="line">    NSRadioModeMatrix,</div><div class="line">    NSHighlightModeMatrix,</div><div class="line">    NSListModeMatrix,</div><div class="line">    NSTrackModeMatrix</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>定义bit map：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef NS_OPTIONS(NSUInteger, NSWindowMask) &#123;</div><div class="line">    NSBorderlessWindowMask      = 0,</div><div class="line">    NSTitledWindowMask          = 1 &lt;&lt; 0,</div><div class="line">    NSClosableWindowMask        = 1 &lt;&lt; 1,</div><div class="line">    NSMiniaturizableWindowMask  = 1 &lt;&lt; 2,</div><div class="line">    NSResizableWindowMask       = 1 &lt;&lt; 3</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用<code>const</code>定义浮点型或者单个的整数型常量，如果要定义一组相关的整数常量，应该优先使用枚举。常量的命名规范和函数相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const float NSLightGray;</div></pre></td></tr></table></figure>
<p>不要使用<code>#define</code>宏来定义常量，如果是整型常量，尽量使用枚举，浮点型常量，使用<code>const</code>定义。<code>#define</code>通常用来给编译器决定是否编译某块代码，比如常用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#ifdef DEBUG</div></pre></td></tr></table></figure>
<p>注意到一般由编译器定义的宏会在前后都有一个<code>__</code>，比如<em><code>__MACH__</code></em>。</p>
<h4 id="命名通知（Notifications）"><a href="#命名通知（Notifications）" class="headerlink" title="命名通知（Notifications）"></a>命名通知（Notifications）</h4><p>通知常用于在模块间传递消息，所以通知要尽可能地表示出发生的事件，通知的命名范式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[触发通知的类名] + [Did | Will] + [动作] + Notification</div></pre></td></tr></table></figure>
<p>栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSApplicationDidBecomeActiveNotification</div><div class="line">NSWindowDidMiniaturizeNotification</div><div class="line">NSTextViewDidChangeSelectionNotification</div><div class="line">NSColorPanelColorDidChangeNotification</div></pre></td></tr></table></figure>
<h4 id="命名类别（Categories）"><a href="#命名类别（Categories）" class="headerlink" title="命名类别（Categories）"></a>命名类别（Categories）</h4><p>虽然我们知道这样写很丑, 但是我们应该要在我们的 category 方法前加上自己的小写前缀以及下划线，比如<code>- (id)zoc_myCategoryMethod</code>。 这种实践同样<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html#//apple_ref/doc/uid/TP40011210-CH6-SW4" target="_blank" rel="external">被苹果推荐</a>。</p>
<p>一个好的实践是在 category 名中使用前缀。</p>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSDate (ZOCTimeExtensions)</div><div class="line">- (NSString *)zoc_timeAgoShort;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>读没有注释代码的痛苦你我都体会过，好的注释不仅能让人轻松读懂你的程序，还能提升代码的逼格。注意注释是为了让别人看懂，而不是仅仅你自己。</p>
<h4 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h4><p>每一个文件都<strong>必须</strong>写文件注释，文件注释通常包含</p>
<ul>
<li>文件所在模块</li>
<li>作者信息</li>
<li>历史版本信息</li>
<li>版权信息</li>
<li>文件包含的内容，作用</li>
</ul>
<p>一段良好文件注释的栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/*******************************************************************************</div><div class="line">	Copyright (C), 2011-2013, Andrew Min Chang</div><div class="line"></div><div class="line">	File name: 	AMCCommonLib.h</div><div class="line">	Author:		Andrew Chang (Zhang Min) </div><div class="line">	E-mail:		LaplaceZhang@126.com</div><div class="line">	</div><div class="line">	Description: 	</div><div class="line">			This file provide some covenient tool in calling library tools. One can easily include </div><div class="line">		library headers he wants by declaring the corresponding macros. </div><div class="line">			I hope this file is not only a header, but also a useful Linux library note.</div><div class="line">			</div><div class="line">	History:</div><div class="line">		2012-??-??: On about come date around middle of Year 2012, file created as &quot;commonLib.h&quot;</div><div class="line">		2012-08-20: Add shared memory library; add message queue.</div><div class="line">		2012-08-21: Add socket library (local)</div><div class="line">		2012-08-22: Add math library</div><div class="line">		2012-08-23: Add socket library (internet)</div><div class="line">		2012-08-24: Add daemon function</div><div class="line">		2012-10-10: Change file name as &quot;AMCCommonLib.h&quot;</div><div class="line">		2012-12-04: Add UDP support in AMC socket library</div><div class="line">		2013-01-07: Add basic data type such as &quot;sint8_t&quot;</div><div class="line">		2013-01-18: Add CFG_LIB_STR_NUM.</div><div class="line">		2013-01-22: Add CFG_LIB_TIMER.</div><div class="line">		2013-01-22: Remove CFG_LIB_DATA_TYPE because there is already AMCDataTypes.h</div><div class="line"></div><div class="line">	Copyright information: </div><div class="line">			This file was intended to be under GPL protocol. However, I may use this library</div><div class="line">		in my work as I am an employee. And my company may require me to keep it secret. </div><div class="line">		Therefore, this file is neither open source nor under GPL control. </div><div class="line">		</div><div class="line">********************************************************************************/</div></pre></td></tr></table></figure>
<p><em>文件注释的格式通常不作要求，能清晰易读就可以了，但在整个工程中风格要统一。</em></p>
<h4 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h4><p>好的代码应该是“自解释”（self-documenting）的，但仍然需要详细的注释来说明参数的意义、返回值、功能以及可能的副作用。</p>
<p>方法、函数、类、协议、类别的定义都需要注释，推荐采用Apple的标准注释风格，好处是可以在引用的地方<code>alt+点击</code>自动弹出注释，非常方便。</p>
<p>有很多可以自动生成注释格式的插件，推荐使用系统自带方法注释功能（<code>Cmd + Alt + /</code>）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/6080248-cb62b50bcbc1fed5.gif?imageMogr2/auto-orient/strip" alt="Screenshot"></p>
<p>一些良好的注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  Create a new preconnector to replace the old one with given mac address.</div><div class="line"> *  NOTICE: We DO NOT stop the old preconnector, so handle it by yourself.</div><div class="line"> *</div><div class="line"> *  @param type       Connect type the preconnector use.</div><div class="line"> *  @param macAddress Preconnector&apos;s mac address.</div><div class="line"> */</div><div class="line">- (void)refreshConnectorWithConnectType:(IPCConnectType)type  Mac:(NSString *)macAddress;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  Stop current preconnecting when application is going to background.</div><div class="line"> */</div><div class="line">-(void)stopRunning;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  Get the COPY of cloud device with a given mac address.</div><div class="line"> *</div><div class="line"> *  @param macAddress Mac address of the device.</div><div class="line"> *</div><div class="line"> *  @return Instance of IPCCloudDevice.</div><div class="line"> */</div><div class="line">-(IPCCloudDevice *)getCloudDeviceWithMac:(NSString *)macAddress;</div><div class="line"></div><div class="line">// A delegate for NSApplication to handle notifications about app</div><div class="line">// launch and shutdown. Owned by the main app controller.</div><div class="line">@interface MyAppDelegate : NSObject &#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>协议、委托的注释要明确说明其被触发的条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/** Delegate - Sent when failed to init connection, like p2p failed. */</div><div class="line">-(void)initConnectionDidFailed:(IPCConnectHandler *)handler;</div></pre></td></tr></table></figure>
<p>如果在注释中要引用参数名或者方法函数名，使用<code>||</code>将参数或者方法括起来以避免歧义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// Sometimes we need |count| to be less than zero.</div><div class="line"></div><div class="line">// Remember to call |StringWithoutSpaces(&quot;foo bar baz&quot;)|</div></pre></td></tr></table></figure>
<p><strong>定义在头文件里的接口方法、属性必须要有注释！</strong></p>
<h3 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h3><p>每个人都有自己的编码风格，这里总结了一些比较好的Cocoa编程风格和注意点。</p>
<h4 id="不要使用尤达表达式"><a href="#不要使用尤达表达式" class="headerlink" title="不要使用尤达表达式"></a>不要使用尤达表达式</h4><p>尤达表达式是指，拿一个常量去和变量比较而不是拿变量去和常量比较。它就像是在表达 “蓝色是不是天空的颜色” 或者 “高个是不是这个男人的属性” 而不是 “天空是不是蓝的” 或者 “这个男人是不是高个子的”</p>
<p> <strong>推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if ([myValue isEqual:@42]) &#123; ...</div></pre></td></tr></table></figure>
<p><strong>不推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if ([@42 isEqual:myValue]) &#123; ...</div></pre></td></tr></table></figure>
<h4 id="黄金大道"><a href="#黄金大道" class="headerlink" title="黄金大道"></a>黄金大道</h4><p>在使用条件语句编程时，代码的左边距应该是一条“黄金”或者“快乐”的大道。 也就是说，不要嵌套 <code>if</code> 语句。使用多个 return 可以避免增加循环的复杂度，并提高代码的可读性。因为方法的重要部分没有嵌套在分支里面，并且你可以很清楚地找到相关的代码。</p>
<p><strong>推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)someMethod &#123;</div><div class="line">  if (![someOther boolValue]) &#123;</div><div class="line">      return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  //Do something important</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>不推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)someMethod &#123;</div><div class="line">  if ([someOther boolValue]) &#123;</div><div class="line">    //Do something important</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="复杂的表达式"><a href="#复杂的表达式" class="headerlink" title="复杂的表达式"></a>复杂的表达式</h4><p>当你有一个复杂的 if 子句的时候，你应该把它们提取出来赋给一个 BOOL 变量，这样可以让逻辑更清楚，而且让每个子句的意义体现出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BOOL nameContainsSwift  = [sessionName containsString:@&quot;Swift&quot;];</div><div class="line">BOOL isCurrentYear      = [sessionDateCompontents year] == 2014;</div><div class="line">BOOL isSwiftSession     = nameContainsSwift &amp;&amp; isCurrentYear;</div><div class="line"></div><div class="line">if (isSwiftSession) &#123;</div><div class="line">    // Do something very cool</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>三元运算符 ? 应该只用在它能让代码更加清楚的地方。 一个条件语句的所有的变量应该是已经被求值了的。类似 if 语句，计算多个条件子句通常会让语句更加难以理解。或者可以把它们重构到实例变量里面。</p>
<p><strong>推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = a &gt; b ? x : y;</div></pre></td></tr></table></figure>
<p><strong>不推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = a &gt; b ? x = c &gt; d ? c : d : y;</div></pre></td></tr></table></figure>
<p>当三元运算符的第二个参数（if 分支）返回和条件语句中已经检查的对象一样的对象的时候，下面的表达方式更灵巧：</p>
<p><strong>推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = object ? : [self createObject];</div></pre></td></tr></table></figure>
<p><strong>不推荐:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = object ? object : [self createObject];</div></pre></td></tr></table></figure>
<h4 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h4><h5 id="Pragma-Mark"><a href="#Pragma-Mark" class="headerlink" title="Pragma Mark"></a>Pragma Mark</h5><p><code>#pragma mark -</code> 是一个在类内部组织代码并且帮助你分组方法实现的好办法。 我们建议使用 <code>#pragma mark -</code> 来分离:</p>
<ul>
<li>不同功能组的方法</li>
<li>protocols 的实现</li>
<li>对父类方法的重写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">- (void)dealloc &#123; /* ... */ &#125;</div><div class="line">- (instancetype)init &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">#pragma mark - View Lifecycle （View 的生命周期）</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123; /* ... */ &#125;</div><div class="line">- (void)viewWillAppear:(BOOL)animated &#123; /* ... */ &#125;</div><div class="line">- (void)didReceiveMemoryWarning &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">#pragma mark - Custom Accessors （自定义访问器）</div><div class="line"></div><div class="line">- (void)setCustomProperty:(id)value &#123; /* ... */ &#125;</div><div class="line">- (id)customProperty &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">#pragma mark - IBActions  </div><div class="line"></div><div class="line">- (IBAction)submitData:(id)sender &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">#pragma mark - Public </div><div class="line"></div><div class="line">- (void)publicMethod &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">#pragma mark - Private</div><div class="line"></div><div class="line">- (void)zoc_privateMethod &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">#pragma mark - UITableViewDataSource</div><div class="line"></div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; /* ... */ &#125;</div><div class="line"></div><div class="line">#pragma mark - ZOCSuperclass</div><div class="line"></div><div class="line">// ... 重载来自 ZOCSuperclass 的方法</div><div class="line"></div><div class="line">#pragma mark - NSObject</div><div class="line"></div><div class="line">- (NSString *)description &#123; /* ... */ &#125;</div></pre></td></tr></table></figure>
<p>上面的标记能明显分离和组织代码。你还可以用 cmd+Click 来快速跳转到符号定义地方。 但是小心，即使 paragma mark 是一门手艺，但是它不是让你类里面方法数量增加的一个理由：类里面有太多方法说明类做了太多事情，需要考虑重构了。</p>
<h5 id="关于-pragma"><a href="#关于-pragma" class="headerlink" title="关于 pragma"></a>关于 pragma</h5><p>在 <a href="http://raptureinvenice.com/pragmas-arent-just-for-marks" target="_blank" rel="external">http://raptureinvenice.com/pragmas-arent-just-for-marks</a> 有很好的关于 pragma 的讨论了，在这边我们再做部分说明。</p>
<p>大多数 iOS 开发者平时并没有和很多编译器选项打交道。一些选项是对控制严格检查（或者不检查）你的代码或者错误的。有时候，你想要用 pragma 直接产生一个异常，临时打断编译器的行为。</p>
<p>当你使用ARC的时候，编译器帮你插入了内存管理相关的调用。但是这样可能产生一些烦人的事情。比如你使用 <code>NSSelectorFromString</code> 来动态地产生一个 selector 调用的时候，ARC不知道这个方法是哪个并且不知道应该用那种内存管理方法，你会被提示 <code>performSelector may cause a leak because its selector is unknown（执行 selector 可能导致泄漏，因为这个 selector 是未知的）</code>.</p>
<p>如果你知道你的代码不会导致内存泄露，你可以通过加入这些代码忽略这些警告</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</div><div class="line"></div><div class="line">[myObj performSelector:mySelector withObject:name];</div><div class="line"></div><div class="line">#pragma clang diagnostic pop</div></pre></td></tr></table></figure>
<p>注意我们是如何在相关代码上下文中用 pragma 停用 -Warc-performSelector-leaks 检查的。这确保我们没有全局禁用。如果全局禁用，可能会导致错误。</p>
<p>全部的选项可以在 <a href="http://clang.llvm.org/docs/UsersManual.html" target="_blank" rel="external">The Clang User’s Manual</a> 找到并且学习。</p>
<h5 id="忽略没用使用变量的编译警告"><a href="#忽略没用使用变量的编译警告" class="headerlink" title="忽略没用使用变量的编译警告"></a>忽略没用使用变量的编译警告</h5><p>告诉你申明的变量它将不会被使用，这种做法很有用。大多数情况下，你希望移除这些引用来（稍微地）提高性能，但是有时候你希望保留它们。为什么？或许它们以后有用，或者有些特性只是暂时移除。无论如何，一个消除这些警告的好方法是用相关语句进行注解，使用 <code>#pragma unused()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)giveMeFive</div><div class="line">&#123;</div><div class="line">    NSString *foo;</div><div class="line">    #pragma unused (foo)</div><div class="line"></div><div class="line">    return 5;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在你的代码不用任何编译警告了。注意你的 pragma 需要标记到问题代码之下。</p>
<h4 id="明确编译器警告和错误"><a href="#明确编译器警告和错误" class="headerlink" title="明确编译器警告和错误"></a>明确编译器警告和错误</h4><p>编译器是一个机器人，它会标记你代码中被 Clang 规则定义为错误的地方。但是，你总是比 Clang 更聪明。通常，你会发现一些讨厌的代码会导致这个问题，但是暂时却解决不了。你可以这样明确一个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)divide:(NSInteger)dividend by:(NSInteger)divisor</div><div class="line">&#123;</div><div class="line">    #error Whoa, buddy, you need to check for zero here!</div><div class="line">    return (dividend / divisor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类似的，你可以这样标明一个警告</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (float)divide:(float)dividend by:(float)divisor</div><div class="line">&#123;</div><div class="line">    #warning Dude, don&apos;t compare floating point numbers like this!</div><div class="line">    if (divisor != 0.0) &#123;</div><div class="line">        return (dividend / divisor);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        return NAN;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="NSCache"><a href="#NSCache" class="headerlink" title="NSCache"></a>NSCache</h4><ul>
<li>构建缓存时选用NSCache 而非NSDictionary</li>
</ul>
<p>如果我们缓存使用得当，那么应用程序的响应速度就会提高。只有那种“重新计算起来很费事的数据，才值得放入缓存”，比如那些需要从网络获取或从磁盘读取的数据。</p>
<p>在构建缓存的时候很多人习惯用NSDictionary或者NSMutableDictionary，但是作者建议大家使用NSCache，它作为管理缓存的类，有很多特点要优于字典，因为它本来就是为了管理缓存而设计的。</p>
<ul>
<li>NSCache优于NSDictionary的几点：<ul>
<li>当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。</li>
<li>NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。</li>
<li>NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。</li>
</ul>
</li>
</ul>
<h4 id="不要使用new方法"><a href="#不要使用new方法" class="headerlink" title="不要使用new方法"></a>不要使用new方法</h4><p>尽管很多时候能用<code>new</code>代替<code>alloc init</code>方法，但这可能会导致调试内存时出现不可预料的问题。Cocoa的规范就是使用<code>alloc init</code>方法，使用<code>new</code>会让一些读者困惑。</p>
<h4 id="import和-include"><a href="#import和-include" class="headerlink" title="#import和#include"></a>#import和#include</h4><p><code>#import</code>是Cocoa中常用的引用头文件的方式，它能自动防止重复引用文件，什么时候使用<code>#import</code>，什么时候使用<code>#include</code>呢？</p>
<ul>
<li>当引用的是一个Objective-C或者Objective-C++的头文件时，使用<code>#import</code></li>
<li>当引用的是一个C或者C++的头文件时，使用<code>#include</code>，这时必须要保证被引用的文件提供了保护域（#define guard）。</li>
</ul>
<p>栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#import &lt;Cocoa/Cocoa.h&gt;</div><div class="line">#include &lt;CoreFoundation/CoreFoundation.h&gt;</div><div class="line">#import &quot;GTMFoo.h&quot;</div><div class="line">#include &quot;base/basictypes.h&quot;</div></pre></td></tr></table></figure>
<p>为什么不全部使用<code>#import</code>呢？主要是为了保证代码在不同平台间共享时不出现问题。</p>
<h4 id="引用框架的根头文件"><a href="#引用框架的根头文件" class="headerlink" title="引用框架的根头文件"></a>引用框架的根头文件</h4><p>上面提到过，每一个框架都会有一个和框架同名的头文件，它包含了框架内接口的所有引用，在使用框架的时候，应该直接引用这个根头文件，而不是其它子模块的头文件，即使是你只用到了其中的一小部分，编译器会自动完成优化的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//正确，引用根头文件</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">//错误，不要单独引用框架内的其它头文件</div><div class="line">#import &lt;Foundation/NSArray.h&gt;</div><div class="line">#import &lt;Foundation/NSString.h&gt;</div></pre></td></tr></table></figure>
<h4 id="BOOL的使用"><a href="#BOOL的使用" class="headerlink" title="BOOL的使用"></a>BOOL的使用</h4><p>BOOL在Objective-C中被定义为<code>signed char</code>类型，这意味着一个BOOL类型的变量不仅仅可以表示<code>YES</code>(1)和<code>NO</code>(0)两个值，所以永远<strong>不要</strong>将BOOL类型变量直接和<code>YES</code>比较：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//错误，无法确定|great|的值是否是YES(1)，不要将BOOL值直接与YES比较</div><div class="line">BOOL great = [foo isGreat];</div><div class="line">if (great == YES)</div><div class="line">  // ...be great!</div><div class="line"></div><div class="line">//正确</div><div class="line">BOOL great = [foo isGreat];</div><div class="line">if (great)</div><div class="line">  // ...be great!</div></pre></td></tr></table></figure>
<p>同样的，也不要将其它类型的值作为BOOL来返回，这种情况下，BOOL变量只会取值的最后一个字节来赋值，这样很可能会取到0（NO）。但是，一些逻辑操作符比如<code>&amp;&amp;</code>,<code>||</code>,<code>!</code>的返回是可以直接赋给BOOL的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//错误，不要将其它类型转化为BOOL返回</div><div class="line">- (BOOL)isBold &#123;</div><div class="line">  return [self fontTraits] &amp; NSFontBoldTrait;</div><div class="line">&#125;</div><div class="line">- (BOOL)isValid &#123;</div><div class="line">  return [self stringValue];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//正确</div><div class="line">- (BOOL)isBold &#123;</div><div class="line">  return ([self fontTraits] &amp; NSFontBoldTrait) ? YES : NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//正确，逻辑操作符可以直接转化为BOOL</div><div class="line">- (BOOL)isValid &#123;</div><div class="line">  return [self stringValue] != nil;</div><div class="line">&#125;</div><div class="line">- (BOOL)isEnabled &#123;</div><div class="line">  return [self isValid] &amp;&amp; [self isBold];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外BOOL类型可以和<code>_Bool</code>,<code>bool</code>相互转化，但是<strong>不能</strong>和<code>Boolean</code>转化。</p>
<h4 id="在init和dealloc中不要用存取方法访问实例变量"><a href="#在init和dealloc中不要用存取方法访问实例变量" class="headerlink" title="在init和dealloc中不要用存取方法访问实例变量"></a>在init和dealloc中不要用存取方法访问实例变量</h4><p>当<code>init``dealloc</code>方法被执行时，类的运行时环境不是处于正常状态的，使用存取方法访问变量可能会导致不可预料的结果，因此应当在这两个方法内直接访问实例变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//正确，直接访问实例变量</div><div class="line">- (instancetype)init &#123;</div><div class="line">  self = [super init];</div><div class="line">  if (self) &#123;</div><div class="line">    _bar = [[NSMutableString alloc] init];</div><div class="line">  &#125;</div><div class="line">  return self;</div><div class="line">&#125;</div><div class="line">- (void)dealloc &#123;</div><div class="line">  [_bar release];</div><div class="line">  [super dealloc];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//错误，不要通过存取方法访问</div><div class="line">- (instancetype)init &#123;</div><div class="line">  self = [super init];</div><div class="line">  if (self) &#123;</div><div class="line">    self.bar = [NSMutableString string];</div><div class="line">  &#125;</div><div class="line">  return self;</div><div class="line">&#125;</div><div class="line">- (void)dealloc &#123;</div><div class="line">  self.bar = nil;</div><div class="line">  [super dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="保证NSString在赋值时被复制"><a href="#保证NSString在赋值时被复制" class="headerlink" title="保证NSString在赋值时被复制"></a>保证NSString在赋值时被复制</h4><p><code>NSString</code>非常常用，在它被传递或者赋值时应当保证是以复制（copy）的方式进行的，这样可以防止在不知情的情况下String的值被其它对象修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)setFoo:(NSString *)aFoo &#123;</div><div class="line">  _foo = [aFoo copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用NSNumber的语法糖"><a href="#使用NSNumber的语法糖" class="headerlink" title="使用NSNumber的语法糖"></a>使用NSNumber的语法糖</h4><p>使用带有<code>@</code>符号的语法糖来生成NSNumber对象能使代码更简洁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSNumber *fortyTwo = @42;</div><div class="line">NSNumber *piOverTwo = @(M_PI / 2);</div><div class="line">enum &#123;</div><div class="line">  kMyEnum = 2;</div><div class="line">&#125;;</div><div class="line">NSNumber *myEnum = @(kMyEnum);</div></pre></td></tr></table></figure>
<h4 id="nil检查"><a href="#nil检查" class="headerlink" title="nil检查"></a>nil检查</h4><p>因为在Objective-C中向nil对象发送命令是不会抛出异常或者导致崩溃的，只是完全的“什么都不干”，所以，只在程序中使用nil来做逻辑上的检查。</p>
<p>另外，不要使用诸如<code>nil == Object</code>或者<code>Object == nil</code>的形式来判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//正确，直接判断</div><div class="line">if (!objc) &#123;</div><div class="line">	...	</div><div class="line">&#125;</div><div class="line"></div><div class="line">//错误，不要使用nil == Object的形式</div><div class="line">if (nil == objc) &#123;</div><div class="line">	...	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Delegate要使用弱引用"><a href="#Delegate要使用弱引用" class="headerlink" title="Delegate要使用弱引用"></a>Delegate要使用弱引用</h4><p>一个类的Delegate对象通常还引用着类本身，这样很容易造成引用循环的问题，所以类的Delegate属性要设置为弱引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/** delegate */</div><div class="line">@property (nonatomic, weak) id &lt;IPCConnectHandlerDelegate&gt; delegate;</div></pre></td></tr></table></figure>
<h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><p>使用dispatch_once来生成单例，<strong>建议单例类方法名命名保持一致</strong>。</p>
<p>推荐这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedInstance </div><div class="line">&#123; </div><div class="line"> static id sharedInstance = nil; </div><div class="line"> static dispatch_once_t onceToken = 0;</div><div class="line">       dispatch_once(&amp;onceToken, ^&#123; </div><div class="line">  sharedInstance = [[self alloc] init];</div><div class="line">  &#125;); </div><div class="line"> return sharedInstance; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Block循环引用问题"><a href="#Block循环引用问题" class="headerlink" title="Block循环引用问题"></a>Block循环引用问题</h4><p>当使用代码块和异步分发的时候，要注意避免引用循环。 总是使用 <code>weak</code> 来引用对象，避免引用循环。（译者注：这里更为优雅的方式是采用影子变量@weakify/@strongify <a href="https://github.com/jspahrsummers/libextobjc/blob/master/extobjc/EXTScope.h" target="_blank" rel="external">这里有更为详细的说明</a>） 此外，把持有 block 的属性设置为 nil (比如 <code>self.completionBlock = nil</code>) 是一个好的实践。它会打破 block 捕获的作用域带来的引用循环。</p>
<p><strong>例子:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__weak __typeof(self) weakSelf = self;</div><div class="line">[self executeBlock:^(NSData *data, NSError *error) &#123;</div><div class="line">    [weakSelf doSomethingWithData:data];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><strong>不要这样:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[self executeBlock:^(NSData *data, NSError *error) &#123;</div><div class="line">    [self doSomethingWithData:data];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><strong>多个语句的例子:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">__weak __typeof(self)weakSelf = self;</div><div class="line">[self executeBlock:^(NSData *data, NSError *error) &#123;</div><div class="line">    __strong __typeof(weakSelf) strongSelf = weakSelf;</div><div class="line">    if (strongSelf) &#123;</div><div class="line">        [strongSelf doSomethingWithData:data];</div><div class="line">        [strongSelf doSomethingWithData:data];</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><strong>不要这样:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__weak __typeof(self)weakSelf = self;</div><div class="line">[self executeBlock:^(NSData *data, NSError *error) &#123;</div><div class="line">    [weakSelf doSomethingWithData:data];</div><div class="line">    [weakSelf doSomethingWithData:data];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>你应该把这两行代码作为 snippet 加到 Xcode 里面并且总是这样使用它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__weak __typeof(self)weakSelf = self;</div><div class="line">__strong __typeof(weakSelf)strongSelf = weakSelf;</div></pre></td></tr></table></figure>
<p>这里我们来讨论下 block 里面的 self 的 <code>__weak</code> 和 <code>__strong</code> 限定词的一些微妙的地方。简而言之，我们可以参考 self 在 block 里面的三种不同情况。</p>
<ol>
<li>直接在 block 里面使用关键词 self</li>
<li>在 block 外定义一个 <code>__weak</code> 的 引用到 self，并且在 block 里面使用这个弱引用</li>
<li>在 block 外定义一个 <code>__weak</code> 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 <code>__strong</code>的引用。</li>
</ol>
<p><strong>方案 1. 直接在 block 里面使用关键词 self</strong></p>
<p>如果我们直接在 block 里面用 self 关键字，对象会在 block 的定义时候被 retain，（实际上 block 是 <a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW4" target="_blank" rel="external">copied</a>但是为了简单我们可以忽略这个）。</p>
<p>一个 const 的对 self 的引用在 block 里面有自己的位置并且它会影响对象的引用计数。</p>
<p>如果这个block被其他的类使用并且(或者)彼此间传来传去，我们可能想要在 block 中保留 self，就像其他在 block 中使用的对象一样. 因为他们是block执行所需要的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_block_t completionBlock = ^&#123;</div><div class="line">    NSLog(@&quot;%@&quot;, self);</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyViewController *myController = [[MyViewController alloc] init...];</div><div class="line">[self presentViewController:myController</div><div class="line">                   animated:YES</div><div class="line">                 completion:completionHandler];</div></pre></td></tr></table></figure>
<p>没啥大不了。但是如果通过一个属性中的 <code>self</code> 保留 了这个 block（就像下面的例程一样）,对象( self )保留了 block 会怎么样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">self.completionHandler = ^&#123;</div><div class="line">    NSLog(@&quot;%@&quot;, self);</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyViewController *myController = [[MyViewController alloc] init...];</div><div class="line">[self presentViewController:myController</div><div class="line">                   animated:YES</div><div class="line">                 completion:self.completionHandler];</div></pre></td></tr></table></figure>
<p>这就是有名的 retain cycle, 并且我们通常应该避免它。这种情况下我们收到 CLANG 的警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Capturing &apos;self&apos; strongly in this block is likely to lead to a retain cycle （在 block 里面发现了 `self` 的强引用，可能会导致循环引用）</div></pre></td></tr></table></figure>
<p>所以 <code>__weak</code> 就有用武之地了。</p>
<p><strong>方案 2. 在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用</strong></p>
<p>这样会避免循坏引用，也是通常情况下我们的block作为类的属性被self retain 的时候会做的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">self.completionHandler = ^&#123;</div><div class="line">    NSLog(@&quot;%@&quot;, weakSelf);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">MyViewController *myController = [[MyViewController alloc] init...];</div><div class="line">[self presentViewController:myController</div><div class="line">                   animated:YES</div><div class="line">                 completion:self.completionHandler];</div></pre></td></tr></table></figure>
<p>这个情况下 block 没有 retain 对象并且对象在属性里面 retain 了 block 。所以这样我们能保证了安全的访问 self。 不过糟糕的是，它可能被设置成 nil 的。问题是：如何让 self 在 block 里面安全地被销毁。</p>
<p>考虑这么个情况：block 作为属性(property)赋值的结果，从一个对象被复制到另一个对象(如 myController)，在这个复制的 block 执行之前，前者（即之前的那个对象）已经被解除分配。</p>
<p>下面的更有意思。</p>
<p><strong>方案 3. 在 block 外定义一个 <strong>weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个</strong>strong 的引用</strong></p>
<p>你可能会想，首先，这是避免 retain cycle 警告的一个技巧。这不是重点，这个 self 的强引用是在block 执行时 被创建的，但是否使用 self 在 block 定义时就已经定下来了， 因此self (在block执行时) 会被 retain。</p>
<p><a href="http://developer.apple.com/library/mac/#releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Apple 文档</a> 中表示 “为了 non-trivial cycles ，你应该这样” ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">MyViewController *myController = [[MyViewController alloc] init...];</div><div class="line">// ...</div><div class="line">MyViewController * __weak weakMyController = myController;</div><div class="line">myController.completionHandler =  ^(NSInteger result) &#123;</div><div class="line">    MyViewController *strongMyController = weakMyController;</div><div class="line">    if (strongMyController) &#123;</div><div class="line">        // ...</div><div class="line">        [strongMyController dismissViewControllerAnimated:YES completion:nil];</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        // Probably nothing...</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>首先，我觉得这个例子看起来是错误的。如果 block 本身在 completionHandler 属性中被 retain 了，那么 self 如何被 delloc 和在 block 之外赋值为 nil 呢? completionHandler 属性可以被声明为 <code>assign</code> 或者 <code>unsafe_unretained</code> 的，来允许对象在 block 被传递之后被销毁。</p>
<p>我不能理解这样做的理由，如果其他对象需要这个对象（self），block 被传递的时候应该 retain 对象，所以 block 应该不被作为属性存储。这种情况下不应该用 <code>__weak</code>/<code>__strong</code></p>
<p>总之，其他情况下，希望 weakSelf 变成 nil 的话，就像第二种情况解释那么写（在 block 之外定义一个弱应用并且在 block 里面使用）。</p>
<p>还有，Apple的 “trivial block” 是什么呢。我们的理解是 trivial block 是一个不被传送的 block ，它在一个良好定义和控制的作用域里面，weak 修饰只是为了避免循环引用。</p>
<p>虽然有 Kazuki Sakamoto 和 Tomohiko Furumoto) 讨论的 <a href="http://dhoerl.wordpress.com/2013/04/23/i-finally-figured-out-weakself-and-strongself/" target="_blank" rel="external">一</a> <a href="http://blog.random-ideas.net/?p=160" target="_blank" rel="external">些</a> <a href="http://stackoverflow.com/questions/7904568/disappearing-reference-to-self-in-a-block-under-arc" target="_blank" rel="external">的</a> <a href="http://stackoverflow.com/questions/12218767/objective-c-blocks-and-memory-management" target="_blank" rel="external">在线</a> <a href="https://github.com/AFNetworking/AFNetworking/issues/807" target="_blank" rel="external">参考</a>, <a href="https://twitter.com/mattjgalloway" target="_blank" rel="external">Matt Galloway</a> 的 (<a href="http://www.effectiveobjectivec.com/" target="_blank" rel="external">Effective Objective-C 2.0</a> 和 <a href="http://www.amazon.it/Pro-Multithreading-Memory-Management-Ios/dp/1430241160" target="_blank" rel="external">Pro Multithreading and Memory Management for iOS and OS X</a> ，大多数开发者始终没有弄清楚概念。</p>
<p>在 block 内用强引用的优点是，抢占执行的时候的鲁棒性。在 block 执行的时候, 再次温故下上面的三个例子：</p>
<p><strong>方案 1. 直接在 block 里面使用关键词 self</strong></p>
<p>如果 block 被属性 retain，self 和 block 之间会有一个循环引用并且它们不会再被释放。如果 block 被传送并且被其他的对象 copy 了，self 在每一个 copy 里面被 retain</p>
<p><strong>方案 2. 在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用</strong></p>
<p>不管 block 是否通过属性被 retain ，这里都不会发生循环引用。如果 block 被传递或者 copy 了，在执行的时候，weakSelf 可能已经变成 nil。</p>
<p>block 的执行可以抢占，而且对 weakSelf 指针的调用时序不同可以导致不同的结果(如：在一个特定的时序下 weakSelf 可能会变成 nil )。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">dispatch_block_t block =  ^&#123;</div><div class="line">    [weakSelf doSomething]; // weakSelf != nil</div><div class="line">    // preemption, weakSelf turned nil</div><div class="line">    [weakSelf doSomethingElse]; // weakSelf == nil</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>方案 3. 在 block 外定义一个 <strong>weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个</strong>strong 的引用。</strong></p>
<p>不管 block 是否通过属性被 retain ，这里也不会发生循环引用。如果 block 被传递到其他对象并且被复制了，执行的时候，weakSelf 可能被nil，因为强引用被赋值并且不会变成nil的时候，我们确保对象 在 block 调用的完整周期里面被 retain了，如果抢占发生了，随后的对 strongSelf 的执行会继续并且会产生一样的值。如果 strongSelf 的执行到 nil，那么在 block 不能正确执行前已经返回了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">myObj.myBlock =  ^&#123;</div><div class="line">    __strong typeof(self) strongSelf = weakSelf;</div><div class="line">    if (strongSelf) &#123;</div><div class="line">      [strongSelf doSomething]; // strongSelf != nil</div><div class="line">      // preemption, strongSelf still not nil（抢占的时候，strongSelf 还是非 nil 的)</div><div class="line">      [strongSelf doSomethingElse]; // strongSelf != nil</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        // Probably nothing...</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在ARC条件中，如果尝试用 <code>-&gt;</code> 符号访问一个实例变量，编译器会给出非常清晰的错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dereferencing a __weak pointer is not allowed due to possible null value caused by race condition, assign it to a strong variable first. (对一个 __weak 指针的解引用不允许的，因为可能在竞态条件里面变成 null, 所以先把他定义成 strong 的属性)</div></pre></td></tr></table></figure>
<p>可以用下面的代码展示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">myObj.myBlock =  ^&#123;</div><div class="line">    id localVal = weakSelf-&gt;someIVar;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在最后</p>
<ul>
<li><strong>方案 1</strong>: 只能在 block 不是作为一个 property 的时候使用，否则会导致 retain cycle。</li>
<li><strong>方案 2</strong>: 当 block 被声明为一个 property 的时候使用。</li>
<li><strong>方案 3</strong>: 和并发执行有关。当涉及异步的服务的时候，block 可以在之后被执行，并且不会发生关于 self 是否存在的问题。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文档旨在总结出一份通用的编码规范，欢迎随时探讨补充。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://robberjj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://robberjj.github.io/tags/iOS/"/>
    
      <category term="规范" scheme="https://robberjj.github.io/tags/%E8%A7%84%E8%8C%83/"/>
    
      <category term="编码" scheme="https://robberjj.github.io/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Mac上的那些效率神器</title>
    <link href="https://robberjj.github.io/2018/07/16/ArtifactsOnMac/"/>
    <id>https://robberjj.github.io/2018/07/16/ArtifactsOnMac/</id>
    <published>2018-07-16T08:56:50.000Z</published>
    <updated>2018-11-27T07:29:18.558Z</updated>
    
    <content type="html"><![CDATA[<h4 id="No-1-Alfred-点我装备"><a href="#No-1-Alfred-点我装备" class="headerlink" title="No.1  Alfred 点我装备"></a>No.1  <em>Alfred</em> <a href="https://www.alfredapp.com/" target="_blank" rel="external">点我装备</a></h4><p>这顶神奇的魔法帽到底能干啥？<br>这绝对可以称得上一款神器，简单的一句话概括就是——只有你想不到的，没有Alfred做不到的。</p>
<p>哈哈~~是不是很夸张？！  一会儿再来下定论</p>
<a id="more"></a> 
<p>在这里我只是举一个简单的栗子，通常我们遇到不懂的英文单词，基本是这么一个操作过程：</p>
<ul>
<li>copy单词</li>
<li>打开翻译应用（比如自带词典）</li>
<li>输入或粘贴查询单词</li>
<li>翻译应用输出查询结果</li>
<li>查询过后，一般都需要 Cmd+Q 退出应用（或者 Cmd+H 隐藏词典，亦或 Cmd+Tab 切换回上一个应用）</li>
</ul>
<p>或者是下面的步骤：</p>
<ul>
<li>copy单词</li>
<li>手动打开浏览器</li>
<li>进入谷歌首页</li>
<li>选中输入框</li>
<li>输入或粘贴查询单词，然后空格并加上「翻译」两个字，然后再回车</li>
<li>等待浏览器展示查询结果;</li>
</ul>
<p>而用Alfred是只需要：</p>
<ul>
<li>选中单词</li>
<li>CMD+Y（假如快捷键你设置的是这个）</li>
</ul>
<p>Done！！</p>
<h5 id="那么问题来了，Alfred到底具体能做什么？"><a href="#那么问题来了，Alfred到底具体能做什么？" class="headerlink" title="那么问题来了，Alfred到底具体能做什么？"></a>那么问题来了，Alfred到底具体能做什么？</h5><p>默认情况下，Alfred 至少能胜任 15 项工作：</p>
<ol>
<li>应用搜索</li>
<li>文件或目录搜索</li>
<li>文本内容搜索</li>
<li>标记搜索</li>
<li>快捷网页搜索</li>
<li>书签搜索</li>
<li>计算器</li>
<li>词典搜索</li>
<li>通讯录搜索</li>
<li>剪切板搜索</li>
<li>代码片段搜索</li>
<li>iTunes 管理</li>
<li>1Password 搜索</li>
<li>系统常用命令快捷操作</li>
<li>直接唤起指定终端并执行命令</li>
</ol>
<p><a href="https://sspai.com/post/44624" target="_blank" rel="external">这里</a>做了很详细的说明。</p>
<p>当然，Alfred真正核心的功能在于——<strong>Workflow</strong> 。</p>
<p>Alfred 几乎可以做任何自动化工作流的事情（只要能用代码描述这个工作流就行），它能彻底改变了你对 Mac 的认知。</p>
<p>网上有很多大神们写好的<code>workflow</code>，可以搜一搜，然后体验体验，在我们可以自己为所欲为之前，坚定一下信心。</p>
<h4 id="No-2-Things-3-点我装备"><a href="#No-2-Things-3-点我装备" class="headerlink" title="No.2 Things 3 点我装备"></a>No.2 <em>Things 3</em> <a href="https://culturedcode.com/things/" target="_blank" rel="external">点我装备</a></h4><p>一句话总结：<strong>GTD神器，简洁但不简单。</strong></p>
<h4 id="No-3-Moom-点我装备"><a href="#No-3-Moom-点我装备" class="headerlink" title="No.3 Moom 点我装备"></a>No.3 <em>Moom</em> <a href="https://manytricks.com/moom/" target="_blank" rel="external">点我装备</a></h4><p>一款窗口布局的神器。<br>支持自定义快捷键实现相应的窗口布局。</p>
<h4 id="No-3-CheatSheet-点我装备"><a href="#No-3-CheatSheet-点我装备" class="headerlink" title="No.3 CheatSheet 点我装备"></a>No.3 <em>CheatSheet</em> <a href="https://mediaatelier.com/CheatSheet/" target="_blank" rel="external">点我装备</a></h4><p>一键直观查看App的快捷键列表。</p>
<p>说道快捷键，是的，快捷键会很大程度上提高你的效率，Mac上就自带了很多的快捷键，记住这些快捷键招式，就能立马神装出山了。<br>具体可以参见<a href="https://www.jianshu.com/p/00bb1b9189c0" target="_blank" rel="external">这里</a>。</p>
<h4 id="No-4-Vim"><a href="#No-4-Vim" class="headerlink" title="No.4 Vim"></a>No.4 <em>Vim</em></h4><p>细心一些我们会发现，当前主流的IDE，或者以前曾经主流过的，或者未来即将成为主流的，总会有一套Vim相关的插件。<br>其实，这就已经很能说明问题了。</p>
<p>Vim在手，天下我有的赶脚，有木有？！</p>
<p>Vim各类IDE的插件安装在这里就不详细阐述了，推荐几个Atom上神装吧，仅供参考：</p>
<ul>
<li><a href="https://github.com/t9md/atom-vim-mode-plus" target="_blank" rel="external">Vim Mode Plus</a><blockquote>
<p>Vim主要功能插件，不多说，究竟怎么爽，谁用谁知道。</p>
</blockquote>
</li>
<li><a href="https://atom.io/packages/relative-numbers" target="_blank" rel="external">relative-numbers</a><blockquote>
<p>相对行数在Vim中的重要地位不言而喻了，这款插件能够直观的看出彼此的相对行数。</p>
</blockquote>
</li>
<li><a href="https://atom.io/packages/minimap" target="_blank" rel="external">minimap</a><blockquote>
<p>Sublime 右侧的mini视图，对，就是这货。</p>
</blockquote>
</li>
<li><a href="https://atom.io/packages/activate-power-mode" target="_blank" rel="external">activate-power-mode</a><blockquote>
<p>这款插件绝对会让你有一种敲代码如同跳舞的动感，呃，提醒一句，注意休息眼睛。哈哈~~</p>
</blockquote>
</li>
</ul>
<p>当然，Atom的插件还有很多，可以去他的<a href="https://atom.io/packages/" target="_blank" rel="external">官网</a>淘出你需要的。</p>
<h4 id="No-5-iTerm-点击装备"><a href="#No-5-iTerm-点击装备" class="headerlink" title="No.5 iTerm 点击装备"></a>No.5 <em>iTerm</em> <a href="https://www.iterm2.com/" target="_blank" rel="external">点击装备</a></h4><p><code>iTerm2</code>+ <code>oh my zsh</code>的组合，为你打造最强Mac终端便不只是梦。<br>个性化的主题，私人订制属于自己的格调。<br>一堆定义好的<code>alias</code>，省心省力，爽的飞起！</p>
<h4 id="No-6-Vimium"><a href="#No-6-Vimium" class="headerlink" title="No.6 Vimium"></a>No.6 <em>Vimium</em></h4><ul>
<li>chrome下的Vim插件，让你浏览网页也能有Vim操作的快感。<br>点击<a href="https://sspai.com/post/27723" target="_blank" rel="external">这里</a>了解</li>
</ul>
<h4 id="No-7-Surfingkeys"><a href="#No-7-Surfingkeys" class="headerlink" title="No.7 Surfingkeys"></a>No.7 <em>Surfingkeys</em></h4><ul>
<li>chrome下的Vim插件，Vimium的强化版本。<br>点击<a href="https://github.com/brookhong/Surfingkeys" target="_blank" rel="external">这里</a>了解</li>
</ul>
<p>最后，放上Vim快捷键的几张图，欢迎收藏：<br><img src="https://upload-images.jianshu.io/upload_images/6080248-804fa34b20f5d806.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vim文字版.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/6080248-b631711cd75dff0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vim入门版.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/6080248-693a8cccf9e14a5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vim进阶版.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/6080248-ebf562cde5fbc69c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vim增强版.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/6080248-29e1a78e12cfdca9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vim.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;No-1-Alfred-点我装备&quot;&gt;&lt;a href=&quot;#No-1-Alfred-点我装备&quot; class=&quot;headerlink&quot; title=&quot;No.1  Alfred 点我装备&quot;&gt;&lt;/a&gt;No.1  &lt;em&gt;Alfred&lt;/em&gt; &lt;a href=&quot;https://www.alfredapp.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点我装备&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;这顶神奇的魔法帽到底能干啥？&lt;br&gt;这绝对可以称得上一款神器，简单的一句话概括就是——只有你想不到的，没有Alfred做不到的。&lt;/p&gt;
&lt;p&gt;哈哈~~是不是很夸张？！  一会儿再来下定论&lt;/p&gt;
    
    </summary>
    
      <category term="mac" scheme="https://robberjj.github.io/categories/mac/"/>
    
    
      <category term="Mac" scheme="https://robberjj.github.io/tags/Mac/"/>
    
      <category term="效率" scheme="https://robberjj.github.io/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="app" scheme="https://robberjj.github.io/tags/app/"/>
    
  </entry>
  
  <entry>
    <title>Mac上的那些个快捷键们</title>
    <link href="https://robberjj.github.io/2018/07/11/ShortcutsOnMac/"/>
    <id>https://robberjj.github.io/2018/07/11/ShortcutsOnMac/</id>
    <published>2018-07-11T06:47:50.000Z</published>
    <updated>2018-11-08T04:19:52.712Z</updated>
    
    <content type="html"><![CDATA[<p>入了Mac的坑，在为其魅力折服的同时，不免时不时的会有一些挥之不去的痛点。</p>
<p>其实在Mac上有一大堆的快捷键，可以让你的效率有一个质的提高。</p>
<blockquote>
<p>⌘（command）<br>⌥（option/alt）<br>⇧（shift）<br>⇪（caps lock）<br>⌃（control/ctrl）<br>⇤/⇥(Tab)</p>
</blockquote>
<p>在这里官方给出了快捷键的说明。<a href="https://support.apple.com/zh-cn/ht201236" target="_blank" rel="external">点我直达</a><br>显然，快捷键量很大，全部记住并熟练应用不太可能，可以根据自己的习惯，逐渐的形成自己的套路，然后替身自己的工作(娱乐)效率。</p>
<a id="more"></a> 
<p>当然，<code>⌘ + Q(W/O/N)</code>、<code>⌘ + X(C/V/F/S/A)</code>之流就不说了，太常用，大家都知道。<br>下面主要列举一下我自己感觉比较效率，但是又容易被忽视的快捷键：<br><code>⌘ + ` </code>在同一个应用的各个标签页中切换。<br><code>⌘ + ⇤(⇥)</code>在打开的应用中切换到下一个最近使用的应用,按住可切换到其他应用，亦可配合触摸板或者鼠标选中某个应用<br><code>⌘ + T</code>打开新的标签<br><code>⌘ + H</code>隐藏当前应用<br><code>⌘ + Alt + H</code>隐藏除了当前应用外的其他应用<br><code>⌘ + M</code>最小化当前应用<br><code>⌘ + Alt + M</code>最小化除了当前应用外的其他应用<br><code>⌘ + Shift + 3</code> 截取整个屏幕，并保存图片到桌面<br><code>⌘ + Shift + 4</code> 自定义截图大小，按下 Space 键，可以选择窗口截图<br><code>⌃ + ←(→)</code>可以切换屏幕<br><code>⌘ + ,</code>打开偏好设置<br>……</p>
<p>类似的快捷键其实还有很多很多，根据自身的习惯取舍吧。</p>
<p>快捷键的初衷，其实是想让效率能够提升，是想工作(娱乐)起来更有效率。<br>但是问题来了，快捷键记少了总感觉不够用，而想要记更多的快捷键，难免成为一种负担。</p>
<p><code>CheatSheet</code>，一款App，一键查看所有快捷键的App。<a href="https://mediaatelier.com/CheatSheet/" target="_blank" rel="external">点我速度装备</a></p>
<p>其实在Mac上还要一些隐藏的或者说是并没有明说的快捷键。(Apple经常干这事儿，发现的时候总有些喜怒交加)。</p>
<p>在mac上，很多时候在文本输入时，总想着能有一些快捷键，能让光标快速移动，殊不知，mac本身就自带这个能力。</p>
<p>如：iTerm2, 终端, safari, Chrome, QQ, SourceTree, Xcode, MindNode Pro, Pages, Keynote, 便签,  邮件等，几乎有文本输入的地方似乎都是支持的~~~</p>
<p>在这里我列举一下平时比较常用的快捷键以及帮助记忆的方法：</p>
<blockquote>
<p>注：为与emacs教程习惯一致，<code>Ctrl</code> 简写成 <code>C</code></p>
</blockquote>
<ul>
<li><code>C - a</code> 光标移到行首（abcde，a是开头）</li>
<li><code>C - e</code> 光标移到行尾（abcde，e是结尾）</li>
<li><code>C - f</code> 光标向文档结尾方向移（Forward首字母）</li>
<li><code>C - b</code> 光标向文档开头方向移（Back首字母）</li>
<li><code>C - p</code> 光标移向上一行（Previous首字母）</li>
<li><code>C - n</code> 光标移向下一行（Next首字母）</li>
<li><code>C - l</code> 使当前编辑的行居中（safari, qq）或清屏（iTerm2,终端）</li>
<li><code>C - d</code> 删除光标后的一个字符（Delete首字母）</li>
<li><code>C - k</code> 删除光标到行尾的内容（Kill首字母）</li>
<li><code>C - y</code> 将C-k删除的东西粘贴出来（Yank首字母）</li>
<li><code>C - o</code> 在光标后插入一个换行符</li>
<li><code>C - t</code> 交换光标前和光标后的字符，同时光标后移（Transpose首字母）</li>
<li><code>C - h</code> 删除光标前的一个字符</li>
</ul>
<p>Mac其实也可以很简单的输入一些特殊字符。</p>
<p>输入特殊符号：<br>版权符号: ⌥ + G = ©<br>人民币符号: ⌥ + Y = ¥<br>商标符号: ⌥ + 2 = ™<br>已经注册的商标: ⌥ + R = ®   </p>
<p>数学符号：<br>约等于: <code>⌥ + X</code> = ≈<br>度数: <code>⌥ + ⇧ + 8</code> = °<br>除号: <code>⌥ + /</code> = ÷<br>无穷: <code>⌥ + 5</code> = ∞<br>大于等于和小于等于: <code>⌥ + ,</code> 和 <code>⌥ + .</code> = ≤ 和 ≥<br>不等于: <code>⌥ + =</code> = ≠<br>圆周率: <code>⌥ + P</code> = π<br>加减: <code>⇧ + ⌥ + =</code> = ±<br>开方: <code>⌥ + V</code> = √<br>求和符号: <code>⌥ + W</code> = ∑</p>
<p><strong>是不是很神奇？！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;入了Mac的坑，在为其魅力折服的同时，不免时不时的会有一些挥之不去的痛点。&lt;/p&gt;
&lt;p&gt;其实在Mac上有一大堆的快捷键，可以让你的效率有一个质的提高。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;⌘（command）&lt;br&gt;⌥（option/alt）&lt;br&gt;⇧（shift）&lt;br&gt;⇪（caps lock）&lt;br&gt;⌃（control/ctrl）&lt;br&gt;⇤/⇥(Tab)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这里官方给出了快捷键的说明。&lt;a href=&quot;https://support.apple.com/zh-cn/ht201236&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点我直达&lt;/a&gt;&lt;br&gt;显然，快捷键量很大，全部记住并熟练应用不太可能，可以根据自己的习惯，逐渐的形成自己的套路，然后替身自己的工作(娱乐)效率。&lt;/p&gt;
    
    </summary>
    
      <category term="mac" scheme="https://robberjj.github.io/categories/mac/"/>
    
    
      <category term="Mac" scheme="https://robberjj.github.io/tags/Mac/"/>
    
      <category term="快捷键" scheme="https://robberjj.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>Development cannot be enabled while your device is locked.</title>
    <link href="https://robberjj.github.io/2018/05/16/DevelopmentNotEnabledWhileLocked/"/>
    <id>https://robberjj.github.io/2018/05/16/DevelopmentNotEnabledWhileLocked/</id>
    <published>2018-05-16T04:15:50.000Z</published>
    <updated>2018-11-08T04:19:57.921Z</updated>
    
    <content type="html"><![CDATA[<p>有时候我们真机调试的时候，会遇到这样的报错：</p>
<blockquote>
<p>Development cannot be enabled while your device is locked.</p>
</blockquote>
<p>但是！我TM手机明明解锁了啊，指纹解的锁不是？密码解的锁不是？没感应到？换个姿势再来一次？还是不行？？</p>
<p>哈哈，有同样经历的点个赞吧。</p>
<a id="more"></a> 
<p>估计是有这么个不经意的瞬间，手机首次插上mac的时候，苹果给你弹了个框框，让你<code>trust (信任)</code>它，然后我们手欠的点了<code>不trust (信任)</code>，然后它生气了，不让你用了，就是上面的局面。</p>
<p>关键的是，它从此以后就不再弹了。。。</p>
<p>我TM错了，还不行么？你回来再给我弹一次啊！！</p>
<p>后悔药：</p>
<blockquote>
<p>设置 –&gt; 通用 –&gt; 还原  –&gt; 还原位置和隐私 </p>
</blockquote>
<p>按照上面的操作之后，重插，就会弹了~~~ 不用谢我~</p>
<p>后遗症：</p>
<blockquote>
<p>位置和隐私被重置了，之前已经设置位置和隐私的APP们，你再次进去的时候，都开始积极的弹框让你赏口饭了。</p>
</blockquote>
<p>【/笑哭】🤣</p>
<p>这块儿官网其实是有说明的：<br><a href="https://support.apple.com/en-us/HT202778" target="_blank" rel="external">https://support.apple.com/en-us/HT202778</a></p>
<p>划重点:<br><img src="https://upload-images.jianshu.io/upload_images/6080248-2b5548a95f804bac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候我们真机调试的时候，会遇到这样的报错：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Development cannot be enabled while your device is locked.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是！我TM手机明明解锁了啊，指纹解的锁不是？密码解的锁不是？没感应到？换个姿势再来一次？还是不行？？&lt;/p&gt;
&lt;p&gt;哈哈，有同样经历的点个赞吧。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://robberjj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://robberjj.github.io/tags/iOS/"/>
    
      <category term="locked" scheme="https://robberjj.github.io/tags/locked/"/>
    
      <category term="XCode" scheme="https://robberjj.github.io/tags/XCode/"/>
    
  </entry>
  
  <entry>
    <title>This iPhone xxx is running iOS xxx, which may not be supported by this version of Xcode.</title>
    <link href="https://robberjj.github.io/2018/05/16/iosRunningNotSupported/"/>
    <id>https://robberjj.github.io/2018/05/16/iosRunningNotSupported/</id>
    <published>2018-05-16T04:02:06.000Z</published>
    <updated>2018-11-08T04:20:04.648Z</updated>
    
    <content type="html"><![CDATA[<p>有时候我们的iPhone紧跟apple的步伐升级最新的版本了，但是Xcode并没有及时更新到最新版本(Xcode是在很大，而且有时候是需要最新的beta版本的)，这时候真机调试的时候就会出现下面这样的问题：</p>
<blockquote>
<p>报错：<br>Could not locate device support files.<br>This iPhone 7 (Model 1660, 1778, 1779, 1780) is running iOS 11.3 (15E216), which may not be supported by this version of Xcode.</p>
</blockquote>
<p>当然，我们升级Xcode到适当的版本(iPhone是release版本，一般Xcode升级到最新的release版本，iPhone是beta版本，一般Xcode升级到最新的beta版本)，但是上面提到升级Xcode时间实在太长，急性子的我们表示等不及。</p>
<a id="more"></a> 
<p>下面介绍一种不用升级Xcode就是真机调试的方法：</p>
<p><strong>更新Xcode真机运行支持包</strong></p>
<p>Xcode真机运行支持包path在这里：Xcode路径/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport，打开后能看到这样的界面：<br><img src="https://upload-images.jianshu.io/upload_images/6080248-37130952acca05d7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DeviceSupport.jpg"></p>
<p>支持包这里下载：链接: <a href="https://pan.baidu.com/s/1eS20QS6" target="_blank" rel="external">https://pan.baidu.com/s/1eS20QS6</a> 密码: 5v35</p>
<p>之后要做的就是，需要哪一个iPhone系统的支持包，下载解压，放进去就可以了，然后插入你的手机，等Xcode解析好你的手机文件就可以真机运行了。</p>
<ul>
<li>有时候可能不生效，重启大法重启下Xcode再试试。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候我们的iPhone紧跟apple的步伐升级最新的版本了，但是Xcode并没有及时更新到最新版本(Xcode是在很大，而且有时候是需要最新的beta版本的)，这时候真机调试的时候就会出现下面这样的问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;报错：&lt;br&gt;Could not locate device support files.&lt;br&gt;This iPhone 7 (Model 1660, 1778, 1779, 1780) is running iOS 11.3 (15E216), which may not be supported by this version of Xcode.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，我们升级Xcode到适当的版本(iPhone是release版本，一般Xcode升级到最新的release版本，iPhone是beta版本，一般Xcode升级到最新的beta版本)，但是上面提到升级Xcode时间实在太长，急性子的我们表示等不及。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://robberjj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://robberjj.github.io/tags/iOS/"/>
    
      <category term="XCode" scheme="https://robberjj.github.io/tags/XCode/"/>
    
      <category term="not supported" scheme="https://robberjj.github.io/tags/not-supported/"/>
    
  </entry>
  
  <entry>
    <title>Github超过100M的大文件上传</title>
    <link href="https://robberjj.github.io/2018/05/02/githubUploadFileOver100M/"/>
    <id>https://robberjj.github.io/2018/05/02/githubUploadFileOver100M/</id>
    <published>2018-05-02T06:13:50.000Z</published>
    <updated>2018-11-08T04:20:10.023Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们commit完成之后，往Github上push的时候，单个文件大小不会超过100M，所以基本不会遇到这种情况。<br>但是，总会遇到的，当单个文件超过100M的时候，push的时候会出现下面这样的Error：</p>
<blockquote>
<p>remote: Resolving deltas: 100% (472/472), done.<br>remote: error: GH001: Large files detected.<br>You may want to try Git Large File Storage - <a href="https://git-lfs.github.com" target="_blank" rel="external">https://git-lfs.github.com</a>.</p>
</blockquote>
<a id="more"></a>
<p>或者：</p>
<blockquote>
<p>Total 3007 (delta 664), reused 0 (delta 0)<br>remote: error: GH001: Large files detected.<br>remote: error: Trace: 7b7de6b9372ee392e0f3961b05ea6f33<br>remote: error: See <a href="http://git.io/iEPt8g" target="_blank" rel="external">http://git.io/iEPt8g</a> for more information.<br>remote: error: File  XXX/XXX/XXX is 234 MB; this exceeds GitHub‘s file size limit of 100.00 MB<br>remote: error: File  XXX/XXX/XXX is 234 MB; this exceeds GitHub‘s file size limit of 100.00 MB。</p>
</blockquote>
<!-- more --> 
<p>上面错误的原因很好理解就是GitHub不允许直接上传大文件（超过100M）的文件到远程仓库，若要想继续提交可以尝试使用大文件支持库：<a href="https://link.jianshu.com/?t=https%3A%2F%2Fgit-lfs.github.com" target="_blank" rel="external">https://git-lfs.github.com</a><br>LFS使用的简单步骤：</p>
<ul>
<li>安装git - lfs到本机<br>这里没有什么难度，根据官网安装就好。</li>
</ul>
<p>之后就是提交大文件的顺序，下面是官网的顺序：</p>
<ol>
<li><p>安装Git命令行扩展。只需要设置一次Git LFS。<br>在项目目录下，执行以下命令：</p>
<blockquote>
<p>git lfs install</p>
</blockquote>
</li>
<li><p>选择您希望Git LFS管理的文件类型（或直接编辑.gitattributes）。您可以随时配置其他文件扩展名。这一步成功后会生成一个gitattributes文件</p>
<blockquote>
<p>git lfs track “<em> .a” –这里的 “ </em>.a “就是你要上传的大文件的路径</p>
</blockquote>
</li>
<li><p>添加并commit gitattributes文件</p>
<blockquote>
<p>git add .gitattributes</p>
</blockquote>
</li>
<li><p>然后再添加大文件到本地缓存区</p>
<blockquote>
<p>git add demo.a<br>git commit -m “提交.a大文件”<br>git push</p>
</blockquote>
</li>
</ol>
<p>以上，按照上述的方法，第一次上传大文件基本还是会报错，而且百思不得其解~<br>尼玛，新手入坑总是这个尿性。。</p>
<p>如下图：<br><img src="https://upload-images.jianshu.io/upload_images/6080248-b5b22f1f9d1a1f7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2200042-a1a69b95caa64404.png"></p>
<p>出现上述问题，先reset 到你刚才commit的前一个commit,(意思就是撤销刚才的commit，回到起点再来一次。)</p>
<p>第一、二步同上，第三步的时候，先将 .gitattributes文件，单独commit，然后push，完成之后，在进行第四部(第四部add 之后 执行<code>git lfs ls-files</code>应该能看见东西了)。<br>到这里应该就没问题了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常我们commit完成之后，往Github上push的时候，单个文件大小不会超过100M，所以基本不会遇到这种情况。&lt;br&gt;但是，总会遇到的，当单个文件超过100M的时候，push的时候会出现下面这样的Error：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;remote: Resolving deltas: 100% (472/472), done.&lt;br&gt;remote: error: GH001: Large files detected.&lt;br&gt;You may want to try Git Large File Storage - &lt;a href=&quot;https://git-lfs.github.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://git-lfs.github.com&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://robberjj.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="github" scheme="https://robberjj.github.io/tags/github/"/>
    
      <category term="大文件" scheme="https://robberjj.github.io/tags/%E5%A4%A7%E6%96%87%E4%BB%B6/"/>
    
      <category term="upload" scheme="https://robberjj.github.io/tags/upload/"/>
    
      <category term="上传" scheme="https://robberjj.github.io/tags/%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>OC追根溯源之Class</title>
    <link href="https://robberjj.github.io/2017/11/12/oc-class/"/>
    <id>https://robberjj.github.io/2017/11/12/oc-class/</id>
    <published>2017-11-12T04:22:55.000Z</published>
    <updated>2018-11-08T02:37:01.897Z</updated>
    
    <content type="html"><![CDATA[<p>前两天碰到一面试题：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//分辨下面res的是非</span></div><div class="line"><span class="built_in">BOOL</span> res1 = [[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</div><div class="line"><span class="built_in">BOOL</span> res2 = [[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];</div><div class="line"><span class="built_in">BOOL</span> res3 = [[Sark <span class="keyword">class</span>] isKindOfClass:[Sark <span class="keyword">class</span>]];</div><div class="line"><span class="built_in">BOOL</span> res4 = [[Sark <span class="keyword">class</span>] isMemberOfClass:[Sark <span class="keyword">class</span>]];</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在这之前，我们先了解一下相关的定义：</p>
<p><strong>Class</strong></p>
<p>在<code>objc.h</code>中<code>Class</code>是这么定义的：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// An opaque type that represents an Objective-C class.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div></pre></td></tr></table></figure></p>
<p><code>objc_class</code>又是啥呢？在<code>runtime.h</code>中能看见：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line"><span class="meta">#if !__OBJC2__</span></div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_cache *cache                                 OBJC2_UNAVAILABLE;</div><div class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p><strong>MetaClass</strong></p>
<p>上面能看到<code>Class</code>中有个<code>isa</code>参数，它是指向<code>Class</code>的<code>元类（MetaClass）</code>的指针。</p>
<p>注意到<code>isa</code>也是一个<code>Class</code>的结构体，也就是说<code>MetaClass</code>其本质也是一个<code>Class</code>。</p>
<blockquote>
<p>我们可以把Meta Class理解为 一个Class对象的Class。简单的说：</p>
<ul>
<li>当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类的方法列表里查找</li>
<li>当我们发送一个消息给一个类时，这条消息会在类的Meta Class的方法列表里查找</li>
</ul>
</blockquote>
<p>之后就有了下面的这张图：</p>
<p><img src="/imgs/ocClass.jpg" alt="Class&amp;MetaClass"></p>
<p>能看到：</p>
<ul>
<li>每个<code>Class</code>都有一个<code>isa</code>指针指向一个唯一的<code>MetaClass</code></li>
<li>每一个<code>MetaClass</code>的<code>isa</code>指针都指向最上层的<code>MetaClass</code>（图中的<code>NSObject</code>的<code>MetaClass</code>）</li>
<li>最上层的<code>MetaClass</code>的<code>isa</code>指针指向自己，形成一个回路</li>
<li>每一个<code>MetaClass</code>的<code>super class</code>指针指向它原本<code>Class</code>的 <code>Super Class</code>的<code>MetaClass</code>。</li>
<li>最上层的<code>MetaClass</code>的 <code>Super Class</code>指向<code>NSObject</code> <code>Class</code>本身</li>
<li>最上层的<code>NSObject</code> <code>Class</code>的<code>super class</code>指向 <code>nil</code></li>
</ul>
<p>接下来我们看看<code>objc</code>源码中(源码可到<a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="external">这里下载</a>)，在文件<code>Object.mm</code>内，上面相关方法的定义：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (Class)<span class="keyword">class</span> &#123;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)isKindOf:aClass</div><div class="line">&#123;</div><div class="line">	Class cls;</div><div class="line">	<span class="keyword">for</span> (cls = isa; cls; cls = cls-&gt;superclass)</div><div class="line">		<span class="keyword">if</span> (cls == (Class)aClass)</div><div class="line">			<span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">	<span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)isMemberOf:aClass</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> isa == (Class)aClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么，<code>BOOL res1 = [[NSObject class] isKindOfClass:[NSObject class]];</code>就可以这样对应起来理解了：</p>
<p><code>[NSObject class]</code>拿到的是<code>self</code>，类方法的<code>return self</code>,即上图紫色的<code>NSObject(Class)</code>。</p>
<p>根据上面<code>- (BOOL)isKindOf:aClass</code>的实现，<code>for</code>循环首先拿到的<code>cls = isa</code>,也就是<code>cls</code>为<code>NSObject(Class)</code>的<code>MetaClass</code>。显然这时候<code>cls == (Class)aClass</code>不成立。</p>
<p>随后，<code>cls = cls-&gt;superclass</code>，即<code>cls</code>变成了<code>NSObject(Class)</code>的<code>MetaClass</code>的<code>superclass</code>,根据图示可以，<code>superclass</code>指向的是<code>NSObject(Class)</code>，至此<code>cls == (Class)aClass</code>成立，返回<code>YES</code>。</p>
<p>同样的道理，分析<code>BOOL res3 = [[Sark class] isKindOfClass:[Sark class]];</code>:</p>
<p><code>[Sark class]</code>拿到的是<code>Sark(Class)</code>,而<code>- (BOOL)isKindOf:aClass</code>中<code>cls</code>拿到的值依次是<code>Sark Meta Class</code>-&gt;<code>NSObject Meta Class</code>-&gt;<code>NSObject Class</code> -&gt; <code>nil</code>,没有相等的，<code>return NO</code>。</p>
<p>剩下两个，根据<code>- (BOOL)isMemberOf:aClass</code>的实现，很容易得出结论会<code>return NO</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天碰到一面试题：&lt;br&gt;&lt;figure class=&quot;highlight mm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//分辨下面res的是非&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; res1 = [[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;] isKindOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;]];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; res2 = [[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;] isMemberOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;]];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; res3 = [[Sark &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;] isKindOfClass:[Sark &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;]];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; res4 = [[Sark &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;] isMemberOfClass:[Sark &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;]];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://robberjj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://robberjj.github.io/tags/iOS/"/>
    
      <category term="OC" scheme="https://robberjj.github.io/tags/OC/"/>
    
      <category term="Class" scheme="https://robberjj.github.io/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>mac开发之监听拦截键盘输入keycode</title>
    <link href="https://robberjj.github.io/2017/11/04/KeyCodes/"/>
    <id>https://robberjj.github.io/2017/11/04/KeyCodes/</id>
    <published>2017-11-04T03:56:06.000Z</published>
    <updated>2018-11-08T02:37:01.892Z</updated>
    
    <content type="html"><![CDATA[<p>最近在自己写一个mac上图片预览的功能，仿系统的预览，想要在预览的时候，加入快捷键，实现放大、缩小、前一张、后一张等功能。</p>
<p>因为总感觉，弄个鼠标啪啪的点，很土。。。</p>
<blockquote>
<p>PS:不上源码你说个JJ 。。。 源码在<a href="https://github.com/RobberJJ/JJImageQuickLook" target="_blank" rel="external">这里</a></p>
</blockquote>
<a id="more"></a>
<p>查阅相关资料，其实并不难实现，只需要在预览的<code>window</code>里面实现键盘的监听就好，具体如下：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//overriding  -[NSWindow keyDown:].</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)keyDown:(<span class="built_in">NSEvent</span> *)theEvent&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  keycode = [theEvent keyCode];</div><div class="line"></div><div class="line">    <span class="comment">//是否同时按下CMD</span></div><div class="line">    <span class="keyword">int</span> flags = <span class="number">0</span>;</div><div class="line">    <span class="built_in">BOOL</span> cmdkeydown = ([[<span class="built_in">NSApp</span> currentEvent] modifierFlags] &amp; <span class="built_in">NSCommandKeyMask</span>) == <span class="built_in">NSCommandKeyMask</span>;</div><div class="line">    <span class="keyword">if</span> (cmdkeydown) &#123;</div><div class="line">        flags = flags | <span class="built_in">NSCommandKeyMask</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (keycode == <span class="number">49</span>) &#123; <span class="comment">//space</span></div><div class="line">            <span class="comment">//空格键去干点啥。。</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以拿到键盘对应的 <code>key code</code>，这个值其实是固定的，比如上面的空格键键值是49。</p>
<p>那么问题来了，总不能每个键去输入一下，打个断点看看值是多少吧，太土了。。。</p>
<p>其实SDK里面是有相应的 <code>enum</code>的，位置在这里：</p>
<blockquote>
<p>Virtual key codes 在 Carbon framework 的这个文件里面 <hitoolbox events.h=""></hitoolbox></p>
</blockquote>
<p>果断add <code>Carbon.framework</code>,但是并不能<code>import &lt;HIToolbox/Events.h&gt;</code>。很奇怪，没明白。。。</p>
<p>好在这样就可以：<code>#import &lt;Carbon/Carbon.h&gt;</code></p>
<p>你就可以这样搞了：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (keycode == kVK_Space) &#123; <span class="comment">//space</span></div><div class="line">      <span class="comment">//空格键去干点啥。。</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>可以在这里找到<code>HIToolbox/Events.h</code>文件：<br><figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/Headers/Events.h</div></pre></td></tr></table></figure></p>
<p>然后你就能看见下面的这些ENUM了：</p>
<figure class="highlight mm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">	 *  Summary:</span></div><div class="line"><span class="comment">	 *    Virtual keycodes</span></div><div class="line"><span class="comment">	 *  </span></div><div class="line"><span class="comment">	 *  Discussion:</span></div><div class="line"><span class="comment">	 *    These constants are the virtual keycodes defined originally in</span></div><div class="line"><span class="comment">	 *    Inside Mac Volume V, pg. V-191. They identify physical keys on a</span></div><div class="line"><span class="comment">	 *    keyboard. Those constants with "ANSI" in the name are labeled</span></div><div class="line"><span class="comment">	 *    according to the key position on an ANSI-standard US keyboard.</span></div><div class="line"><span class="comment">	 *    For example, kVK_ANSI_A indicates the virtual keycode for the key</span></div><div class="line"><span class="comment">	 *    with the letter 'A' in the US keyboard layout. Other keyboard</span></div><div class="line"><span class="comment">	 *    layouts may have the 'A' key label on a different physical key;</span></div><div class="line"><span class="comment">	 *    in this case, pressing 'A' will generate a different virtual</span></div><div class="line"><span class="comment">	 *    keycode.</span></div><div class="line"><span class="comment">	 */</span></div><div class="line">	<span class="keyword">enum</span> &#123;</div><div class="line">	  kVK_ANSI_A                    = <span class="number">0x00</span>,</div><div class="line">	  kVK_ANSI_S                    = <span class="number">0x01</span>,</div><div class="line">	  kVK_ANSI_D                    = <span class="number">0x02</span>,</div><div class="line">	  kVK_ANSI_F                    = <span class="number">0x03</span>,</div><div class="line">	  kVK_ANSI_H                    = <span class="number">0x04</span>,</div><div class="line">	  kVK_ANSI_G                    = <span class="number">0x05</span>,</div><div class="line">	  kVK_ANSI_Z                    = <span class="number">0x06</span>,</div><div class="line">	  kVK_ANSI_X                    = <span class="number">0x07</span>,</div><div class="line">	  kVK_ANSI_C                    = <span class="number">0x08</span>,</div><div class="line">	  kVK_ANSI_V                    = <span class="number">0x09</span>,</div><div class="line">	  kVK_ANSI_B                    = <span class="number">0x0B</span>,</div><div class="line">	  kVK_ANSI_Q                    = <span class="number">0x0C</span>,</div><div class="line">	  kVK_ANSI_W                    = <span class="number">0x0D</span>,</div><div class="line">	  kVK_ANSI_E                    = <span class="number">0x0E</span>,</div><div class="line">	  kVK_ANSI_R                    = <span class="number">0x0F</span>,</div><div class="line">	  kVK_ANSI_Y                    = <span class="number">0x10</span>,</div><div class="line">	  kVK_ANSI_T                    = <span class="number">0x11</span>,</div><div class="line">	  kVK_ANSI_1                    = <span class="number">0x12</span>,</div><div class="line">	  kVK_ANSI_2                    = <span class="number">0x13</span>,</div><div class="line">	  kVK_ANSI_3                    = <span class="number">0x14</span>,</div><div class="line">	  kVK_ANSI_4                    = <span class="number">0x15</span>,</div><div class="line">	  kVK_ANSI_6                    = <span class="number">0x16</span>,</div><div class="line">	  kVK_ANSI_5                    = <span class="number">0x17</span>,</div><div class="line">	  kVK_ANSI_Equal                = <span class="number">0x18</span>,</div><div class="line">	  kVK_ANSI_9                    = <span class="number">0x19</span>,</div><div class="line">	  kVK_ANSI_7                    = <span class="number">0x1A</span>,</div><div class="line">	  kVK_ANSI_Minus                = <span class="number">0x1B</span>,</div><div class="line">	  kVK_ANSI_8                    = <span class="number">0x1C</span>,</div><div class="line">	  kVK_ANSI_0                    = <span class="number">0x1D</span>,</div><div class="line">	  kVK_ANSI_RightBracket         = <span class="number">0x1E</span>,</div><div class="line">	  kVK_ANSI_O                    = <span class="number">0x1F</span>,</div><div class="line">	  kVK_ANSI_U                    = <span class="number">0x20</span>,</div><div class="line">	  kVK_ANSI_LeftBracket          = <span class="number">0x21</span>,</div><div class="line">	  kVK_ANSI_I                    = <span class="number">0x22</span>,</div><div class="line">	  kVK_ANSI_P                    = <span class="number">0x23</span>,</div><div class="line">	  kVK_ANSI_L                    = <span class="number">0x25</span>,</div><div class="line">	  kVK_ANSI_J                    = <span class="number">0x26</span>,</div><div class="line">	  kVK_ANSI_Quote                = <span class="number">0x27</span>,</div><div class="line">	  kVK_ANSI_K                    = <span class="number">0x28</span>,</div><div class="line">	  kVK_ANSI_Semicolon            = <span class="number">0x29</span>,</div><div class="line">	  kVK_ANSI_Backslash            = <span class="number">0x2A</span>,</div><div class="line">	  kVK_ANSI_Comma                = <span class="number">0x2B</span>,</div><div class="line">	  kVK_ANSI_Slash                = <span class="number">0x2C</span>,</div><div class="line">	  kVK_ANSI_N                    = <span class="number">0x2D</span>,</div><div class="line">	  kVK_ANSI_M                    = <span class="number">0x2E</span>,</div><div class="line">	  kVK_ANSI_Period               = <span class="number">0x2F</span>,</div><div class="line">	  kVK_ANSI_Grave                = <span class="number">0x32</span>,</div><div class="line">	  kVK_ANSI_KeypadDecimal        = <span class="number">0x41</span>,</div><div class="line">	  kVK_ANSI_KeypadMultiply       = <span class="number">0x43</span>,</div><div class="line">	  kVK_ANSI_KeypadPlus           = <span class="number">0x45</span>,</div><div class="line">	  kVK_ANSI_KeypadClear          = <span class="number">0x47</span>,</div><div class="line">	  kVK_ANSI_KeypadDivide         = <span class="number">0x4B</span>,</div><div class="line">	  kVK_ANSI_KeypadEnter          = <span class="number">0x4C</span>,</div><div class="line">	  kVK_ANSI_KeypadMinus          = <span class="number">0x4E</span>,</div><div class="line">	  kVK_ANSI_KeypadEquals         = <span class="number">0x51</span>,</div><div class="line">	  kVK_ANSI_Keypad0              = <span class="number">0x52</span>,</div><div class="line">	  kVK_ANSI_Keypad1              = <span class="number">0x53</span>,</div><div class="line">	  kVK_ANSI_Keypad2              = <span class="number">0x54</span>,</div><div class="line">	  kVK_ANSI_Keypad3              = <span class="number">0x55</span>,</div><div class="line">	  kVK_ANSI_Keypad4              = <span class="number">0x56</span>,</div><div class="line">	  kVK_ANSI_Keypad5              = <span class="number">0x57</span>,</div><div class="line">	  kVK_ANSI_Keypad6              = <span class="number">0x58</span>,</div><div class="line">	  kVK_ANSI_Keypad7              = <span class="number">0x59</span>,</div><div class="line">	  kVK_ANSI_Keypad8              = <span class="number">0x5B</span>,</div><div class="line">	  kVK_ANSI_Keypad9              = <span class="number">0x5C</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="comment">/* keycodes for keys that are independent of keyboard layout*/</span></div><div class="line">	<span class="keyword">enum</span> &#123;</div><div class="line">	  kVK_Return                    = <span class="number">0x24</span>,</div><div class="line">	  kVK_Tab                       = <span class="number">0x30</span>,</div><div class="line">	  kVK_Space                     = <span class="number">0x31</span>,</div><div class="line">	  kVK_Delete                    = <span class="number">0x33</span>,</div><div class="line">	  kVK_Escape                    = <span class="number">0x35</span>,</div><div class="line">	  kVK_Command                   = <span class="number">0x37</span>,</div><div class="line">	  kVK_Shift                     = <span class="number">0x38</span>,</div><div class="line">	  kVK_CapsLock                  = <span class="number">0x39</span>,</div><div class="line">	  kVK_Option                    = <span class="number">0x3A</span>,</div><div class="line">	  kVK_Control                   = <span class="number">0x3B</span>,</div><div class="line">	  kVK_RightShift                = <span class="number">0x3C</span>,</div><div class="line">	  kVK_RightOption               = <span class="number">0x3D</span>,</div><div class="line">	  kVK_RightControl              = <span class="number">0x3E</span>,</div><div class="line">	  kVK_Function                  = <span class="number">0x3F</span>,</div><div class="line">	  kVK_F17                       = <span class="number">0x40</span>,</div><div class="line">	  kVK_VolumeUp                  = <span class="number">0x48</span>,</div><div class="line">	  kVK_VolumeDown                = <span class="number">0x49</span>,</div><div class="line">	  kVK_Mute                      = <span class="number">0x4A</span>,</div><div class="line">	  kVK_F18                       = <span class="number">0x4F</span>,</div><div class="line">	  kVK_F19                       = <span class="number">0x50</span>,</div><div class="line">	  kVK_F20                       = <span class="number">0x5A</span>,</div><div class="line">	  kVK_F5                        = <span class="number">0x60</span>,</div><div class="line">	  kVK_F6                        = <span class="number">0x61</span>,</div><div class="line">	  kVK_F7                        = <span class="number">0x62</span>,</div><div class="line">	  kVK_F3                        = <span class="number">0x63</span>,</div><div class="line">	  kVK_F8                        = <span class="number">0x64</span>,</div><div class="line">	  kVK_F9                        = <span class="number">0x65</span>,</div><div class="line">	  kVK_F11                       = <span class="number">0x67</span>,</div><div class="line">	  kVK_F13                       = <span class="number">0x69</span>,</div><div class="line">	  kVK_F16                       = <span class="number">0x6A</span>,</div><div class="line">	  kVK_F14                       = <span class="number">0x6B</span>,</div><div class="line">	  kVK_F10                       = <span class="number">0x6D</span>,</div><div class="line">	  kVK_F12                       = <span class="number">0x6F</span>,</div><div class="line">	  kVK_F15                       = <span class="number">0x71</span>,</div><div class="line">	  kVK_Help                      = <span class="number">0x72</span>,</div><div class="line">	  kVK_Home                      = <span class="number">0x73</span>,</div><div class="line">	  kVK_PageUp                    = <span class="number">0x74</span>,</div><div class="line">	  kVK_ForwardDelete             = <span class="number">0x75</span>,</div><div class="line">	  kVK_F4                        = <span class="number">0x76</span>,</div><div class="line">	  kVK_End                       = <span class="number">0x77</span>,</div><div class="line">	  kVK_F2                        = <span class="number">0x78</span>,</div><div class="line">	  kVK_PageDown                  = <span class="number">0x79</span>,</div><div class="line">	  kVK_F1                        = <span class="number">0x7A</span>,</div><div class="line">	  kVK_LeftArrow                 = <span class="number">0x7B</span>,</div><div class="line">	  kVK_RightArrow                = <span class="number">0x7C</span>,</div><div class="line">	  kVK_DownArrow                 = <span class="number">0x7D</span>,</div><div class="line">	  kVK_UpArrow                   = <span class="number">0x7E</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="comment">/* ISO keyboards only*/</span></div><div class="line">	<span class="keyword">enum</span> &#123;</div><div class="line">	  kVK_ISO_Section               = <span class="number">0x0A</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="comment">/* JIS keyboards only*/</span></div><div class="line">	<span class="keyword">enum</span> &#123;</div><div class="line">	  kVK_JIS_Yen                   = <span class="number">0x5D</span>,</div><div class="line">	  kVK_JIS_Underscore            = <span class="number">0x5E</span>,</div><div class="line">	  kVK_JIS_KeypadComma           = <span class="number">0x5F</span>,</div><div class="line">	  kVK_JIS_Eisu                  = <span class="number">0x66</span>,</div><div class="line">	  kVK_JIS_Kana                  = <span class="number">0x68</span></div><div class="line">	&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在自己写一个mac上图片预览的功能，仿系统的预览，想要在预览的时候，加入快捷键，实现放大、缩小、前一张、后一张等功能。&lt;/p&gt;
&lt;p&gt;因为总感觉，弄个鼠标啪啪的点，很土。。。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS:不上源码你说个JJ 。。。 源码在&lt;a href=&quot;https://github.com/RobberJJ/JJImageQuickLook&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://robberjj.github.io/categories/iOS/"/>
    
    
      <category term="Mac" scheme="https://robberjj.github.io/tags/Mac/"/>
    
      <category term="shortcuts" scheme="https://robberjj.github.io/tags/shortcuts/"/>
    
      <category term="KeyCodes" scheme="https://robberjj.github.io/tags/KeyCodes/"/>
    
  </entry>
  
  <entry>
    <title>This app was unable to be installed.</title>
    <link href="https://robberjj.github.io/2017/10/28/UnableInstalled-md/"/>
    <id>https://robberjj.github.io/2017/10/28/UnableInstalled-md/</id>
    <published>2017-10-28T12:31:36.000Z</published>
    <updated>2018-11-08T02:37:01.894Z</updated>
    
    <content type="html"><![CDATA[<p>今天升级XCode 9.1 beta，编译项目正常，模拟器运行出现以下错误弹框：</p>
<p><img src="/imgs/UnableInstalled.jpg" alt="UnableInstalled"></p>
<a id="more"></a>
<p>APP无法安装到模拟器上，也看不见任何提示，由于mac中存在多个XCode 版本，尝试下面命令：</p>
<blockquote>
<p>sudo xcode-select -s /Applications/Xcode-beta.app</p>
</blockquote>
<p>并不好使。</p>
<p>这种问题看不见任何其他的问题提示，有点无从查起的赶脚。</p>
<p><code>stackoverflow</code>上找到下面的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">xcrun simctl spawn booted log show</div><div class="line"></div><div class="line">//或者可以标出这个错误提示相关的，很容易看到相关的错误提示</div><div class="line">xcrun simctl spawn booted log show | grep &quot;This app was unable to be installed.</div></pre></td></tr></table></figure>
<p>然后，基本就能定位问题了，我这里出现的问题是：<br><img src="/imgs/UnableInstalled2.jpg" alt="reason"></p>
<p>Info.plist文件中缺少<code>CFBundleExecutable</code>，加上即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天升级XCode 9.1 beta，编译项目正常，模拟器运行出现以下错误弹框：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/imgs/UnableInstalled.jpg&quot; alt=&quot;UnableInstalled&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://robberjj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://robberjj.github.io/tags/iOS/"/>
    
      <category term="xcode" scheme="https://robberjj.github.io/tags/xcode/"/>
    
  </entry>
  
  <entry>
    <title>High Sierra bad interpreter</title>
    <link href="https://robberjj.github.io/2017/10/28/PodError-md/"/>
    <id>https://robberjj.github.io/2017/10/28/PodError-md/</id>
    <published>2017-10-28T12:22:11.000Z</published>
    <updated>2018-11-08T02:37:01.893Z</updated>
    
    <content type="html"><![CDATA[<p>升级到mac OS High Sierra之后，pod失败，错误如下：</p>
<blockquote>
<p>-bash: /usr/local/bin/pod: /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/bin/ruby: bad interpreter: No such file or directory</p>
</blockquote>
<p>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo gem update --system</div><div class="line">sudo gem install -n /usr/local/bin cocoapods</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;升级到mac OS High Sierra之后，pod失败，错误如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-bash: /usr/local/bin/pod: /System/Library/Frameworks/Ruby.framework/Versions/2.0
    
    </summary>
    
      <category term="iOS" scheme="https://robberjj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://robberjj.github.io/tags/iOS/"/>
    
      <category term="cocoapods" scheme="https://robberjj.github.io/tags/cocoapods/"/>
    
  </entry>
  
  <entry>
    <title>iOS build error framework not found FileProvider for architecture x86_64</title>
    <link href="https://robberjj.github.io/2017/10/28/NotFoundFileProvider-md/"/>
    <id>https://robberjj.github.io/2017/10/28/NotFoundFileProvider-md/</id>
    <published>2017-10-28T12:17:38.000Z</published>
    <updated>2018-11-08T02:37:01.893Z</updated>
    
    <content type="html"><![CDATA[<p>最近升级mac OS 到 High Sierra之后 XCode并没有立马升级，还是xcode 8.x，编译的时候，出现这样的问题：</p>
<blockquote>
<p>iOS build error: framework not found FileProvider for architecture x86_64</p>
</blockquote>
<p>解决办法：<strong>update XCode to 9.x即可</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近升级mac OS 到 High Sierra之后 XCode并没有立马升级，还是xcode 8.x，编译的时候，出现这样的问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;iOS build error: framework not found FileProvider 
    
    </summary>
    
      <category term="iOS" scheme="https://robberjj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://robberjj.github.io/tags/iOS/"/>
    
      <category term="xcode" scheme="https://robberjj.github.io/tags/xcode/"/>
    
      <category term="FileProvider" scheme="https://robberjj.github.io/tags/FileProvider/"/>
    
  </entry>
  
  <entry>
    <title>The document  could not be autosaved. The file doesn’t exist.</title>
    <link href="https://robberjj.github.io/2017/09/24/DocumentNotAutosaved/"/>
    <id>https://robberjj.github.io/2017/09/24/DocumentNotAutosaved/</id>
    <published>2017-09-24T01:32:22.000Z</published>
    <updated>2018-11-08T02:37:01.891Z</updated>
    
    <content type="html"><![CDATA[<p>有时候莫名其妙的<code>pod update</code>之后(可能是拖拽文件到pod子项目导致的，具体忘了，出现问题的时候已经忘了之前干啥了。。。囧~)，然后某一个或者几个文件就不能编辑保存了，编译不过，如下：</p>
<blockquote>
<p>The document  could not be autosaved. The file doesn’t exist.</p>
</blockquote>
<p><img src="/imgs/fileNotExist.jpg" alt="fileNotExist"></p>
<a id="more"></a>
<p>而且，这个文件并没有路径显示：</p>
<p><img src="/imgs/pathError.jpg" alt="pathError"></p>
<p>从左侧栏右键<code>Show in Finder</code>，之后可以看到该文件在项目根目录下面的<code>ProjectRootPath/Pods/Headers/Public/IMSDK/QCIMChatRoomVC.h</code></p>
<p>各种尝试不好使啊，重新pod也不管用，最终将子项目的该文件覆盖copy到上面的pods路径(<code>ProjectRootPath/Pods/Headers/Public/IMSDK/QCIMChatRoomVC.h</code>)下面，好使了。</p>
<p>以上，记一笔，出现好几次了，每次都是莫名其妙的出现了，然后莫名其妙的好了。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候莫名其妙的&lt;code&gt;pod update&lt;/code&gt;之后(可能是拖拽文件到pod子项目导致的，具体忘了，出现问题的时候已经忘了之前干啥了。。。囧~)，然后某一个或者几个文件就不能编辑保存了，编译不过，如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The document  could not be autosaved. The file doesn’t exist.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/imgs/fileNotExist.jpg&quot; alt=&quot;fileNotExist&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://robberjj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://robberjj.github.io/tags/iOS/"/>
    
      <category term="autosaved" scheme="https://robberjj.github.io/tags/autosaved/"/>
    
      <category term="exist" scheme="https://robberjj.github.io/tags/exist/"/>
    
  </entry>
  
</feed>
